# PySNMP SMI module. Autogenerated from smidump -f python MPLS-TE-STD-MIB
# by libsmi2pysnmp-0.1.3 at Mon Apr  2 20:39:21 2012,
# Python version sys.version_info(major=2, minor=7, micro=2, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( IndexIntegerNextFree, ) = mibBuilder.importSymbols("DIFFSERV-MIB", "IndexIntegerNextFree")
( InterfaceIndexOrZero, ifCounterDiscontinuityGroup, ifGeneralInformationGroup, ) = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero", "ifCounterDiscontinuityGroup", "ifGeneralInformationGroup")
( InetAddressPrefixLength, ) = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressPrefixLength")
( MplsBitRate, MplsBurstSize, MplsExtendedTunnelId, MplsLSPID, MplsOwner, MplsPathIndex, MplsPathIndexOrZero, MplsTunnelAffinity, MplsTunnelIndex, MplsTunnelInstanceIndex, TeHopAddress, TeHopAddressAS, TeHopAddressType, TeHopAddressUnnum, mplsStdMIB, ) = mibBuilder.importSymbols("MPLS-TC-STD-MIB", "MplsBitRate", "MplsBurstSize", "MplsExtendedTunnelId", "MplsLSPID", "MplsOwner", "MplsPathIndex", "MplsPathIndexOrZero", "MplsTunnelAffinity", "MplsTunnelIndex", "MplsTunnelInstanceIndex", "TeHopAddress", "TeHopAddressAS", "TeHopAddressType", "TeHopAddressUnnum", "mplsStdMIB")
( SnmpAdminString, ) = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
( ModuleCompliance, NotificationGroup, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
( Bits, Counter32, Counter64, Integer32, Integer32, ModuleIdentity, MibIdentifier, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, TimeTicks, Unsigned32, zeroDotZero, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "Counter64", "Integer32", "Integer32", "ModuleIdentity", "MibIdentifier", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "TimeTicks", "Unsigned32", "zeroDotZero")
( RowPointer, RowStatus, StorageType, TimeStamp, TruthValue, ) = mibBuilder.importSymbols("SNMPv2-TC", "RowPointer", "RowStatus", "StorageType", "TimeStamp", "TruthValue")

# Objects

mplsTeStdMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 10, 166, 3)).setRevisions(("2004-06-03 00:00",))
if mibBuilder.loadTexts: mplsTeStdMIB.setOrganization("Multiprotocol Label Switching (MPLS) Working Group")
if mibBuilder.loadTexts: mplsTeStdMIB.setContactInfo("        Cheenu Srinivasan\nBloomberg L.P.\nEmail:  cheenu@bloomberg.net\n\nArun Viswanathan\nForce10 Networks, Inc.\nEmail:  arunv@force10networks.com\n\nThomas D. Nadeau\nCisco Systems, Inc.\nEmail:  tnadeau@cisco.com\n\nComments about this document should be emailed\ndirectly to the MPLS working group mailing list at\nmpls@uu.net.")
if mibBuilder.loadTexts: mplsTeStdMIB.setDescription("Copyright (C) The Internet Society (2004). The\ninitial version of this MIB module was published\nin RFC 3812. For full legal notices see the RFC\nitself or see: http://www.ietf.org/copyrights/ianamib.html\n\nThis MIB module contains managed object definitions\n for MPLS Traffic Engineering (TE) as defined in:\n1. Extensions to RSVP for LSP Tunnels, Awduche et\n al, RFC 3209, December 2001\n2. Constraint-Based LSP Setup using LDP, Jamoussi\n\n\n\n (Editor), RFC 3212, January 2002\n3. Requirements for Traffic Engineering Over MPLS,\n Awduche, D., Malcolm, J., Agogbua, J., O'Dell, M.,\n and J. McManus, [RFC2702], September 1999")
mplsTeNotifications = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 3, 0))
mplsTeScalars = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 3, 1))
mplsTunnelConfigured = MibScalar((1, 3, 6, 1, 2, 1, 10, 166, 3, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelConfigured.setDescription("The number of tunnels configured on this device. A\ntunnel is considered configured if the\nmplsTunnelRowStatus is active(1).")
mplsTunnelActive = MibScalar((1, 3, 6, 1, 2, 1, 10, 166, 3, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelActive.setDescription("The number of tunnels active on this device. A\ntunnel is considered active if the\nmplsTunnelOperStatus is up(1).")
mplsTunnelTEDistProto = MibScalar((1, 3, 6, 1, 2, 1, 10, 166, 3, 1, 3), Bits().subtype(namedValues=NamedValues(("other", 0), ("ospf", 1), ("isis", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelTEDistProto.setDescription("The traffic engineering distribution protocol(s)\nused by this LSR. Note that an LSR may support more\nthan one distribution protocol simultaneously.")
mplsTunnelMaxHops = MibScalar((1, 3, 6, 1, 2, 1, 10, 166, 3, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelMaxHops.setDescription("The maximum number of hops that can be specified for\na tunnel on this device.")
mplsTunnelNotificationMaxRate = MibScalar((1, 3, 6, 1, 2, 1, 10, 166, 3, 1, 5), Unsigned32().clone(0)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mplsTunnelNotificationMaxRate.setDescription("This variable indicates the maximum number of\nnotifications issued per second. If events occur\nmore rapidly, the implementation may simply fail to\nemit these notifications during that period, or may\nqueue them until an appropriate time. A value of 0\nmeans no throttling is applied and events may be\nnotified at the rate at which they occur.")
mplsTeObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 3, 2))
mplsTunnelIndexNext = MibScalar((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 1), IndexIntegerNextFree().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelIndexNext.setDescription("This object contains an unused value for\n\n\n\nmplsTunnelIndex, or a zero to indicate\nthat none exist. Negative values are not allowed,\nas they do not correspond to valid values of\nmplsTunnelIndex.\n\nNote that this object offers an unused value\nfor an mplsTunnelIndex value at the ingress\nside of a tunnel. At other LSRs the value\nof mplsTunnelIndex SHOULD be taken from the\nvalue signaled by the MPLS signaling protocol.")
mplsTunnelTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 2))
if mibBuilder.loadTexts: mplsTunnelTable.setDescription("The mplsTunnelTable allows new MPLS tunnels to be\ncreated between an LSR and a remote endpoint, and\nexisting tunnels to be reconfigured or removed.\nNote that only point-to-point tunnel segments are\nsupported, although multipoint-to-point and point-\nto-multipoint connections are supported by an LSR\nacting as a cross-connect.  Each MPLS tunnel can\nthus have one out-segment originating at this LSR\nand/or one in-segment terminating at this LSR.")
mplsTunnelEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 2, 1)).setIndexNames((0, "MPLS-TE-STD-MIB", "mplsTunnelIndex"), (0, "MPLS-TE-STD-MIB", "mplsTunnelInstance"), (0, "MPLS-TE-STD-MIB", "mplsTunnelIngressLSRId"), (0, "MPLS-TE-STD-MIB", "mplsTunnelEgressLSRId"))
if mibBuilder.loadTexts: mplsTunnelEntry.setDescription("An entry in this table represents an MPLS tunnel.\nAn entry can be created by a network administrator\nor by an SNMP agent as instructed by an MPLS\nsignalling protocol. Whenever a new entry is\ncreated with mplsTunnelIsIf set to true(1), then a\ncorresponding entry is created in ifTable as well\n(see RFC 2863). The ifType of this entry is\nmplsTunnel(150).\n\nA tunnel entry needs to be uniquely identified across\na MPLS network. Indices mplsTunnelIndex and\nmplsTunnelInstance uniquely identify a tunnel on\nthe LSR originating the tunnel.  To uniquely\nidentify a tunnel across an MPLS network requires\n\n\n\nindex mplsTunnelIngressLSRId.  The last index\nmplsTunnelEgressLSRId is useful in identifying all\ninstances of a tunnel that terminate on the same\negress LSR.")
mplsTunnelIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 2, 1, 1), MplsTunnelIndex()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: mplsTunnelIndex.setDescription("Uniquely identifies a set of tunnel instances\nbetween a pair of ingress and egress LSRs.\nManagers should obtain new values for row\ncreation in this table by reading\nmplsTunnelIndexNext. When\nthe MPLS signalling protocol is rsvp(2) this value\nSHOULD be equal to the value signaled in the\nTunnel Id of the Session object. When the MPLS\nsignalling protocol is crldp(3) this value\nSHOULD be equal to the value signaled in the\nLSP ID.")
mplsTunnelInstance = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 2, 1, 2), MplsTunnelInstanceIndex()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: mplsTunnelInstance.setDescription("Uniquely identifies a particular instance of a\ntunnel between a pair of ingress and egress LSRs.\nIt is useful to identify multiple instances of\ntunnels for the purposes of backup and parallel\ntunnels. When the MPLS signaling protocol is\nrsvp(2) this value SHOULD be equal to the LSP Id\nof the Sender Template object. When the signaling\nprotocol is crldp(3) there is no equivalent\nsignaling object.")
mplsTunnelIngressLSRId = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 2, 1, 3), MplsExtendedTunnelId()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: mplsTunnelIngressLSRId.setDescription("Identity of the ingress LSR associated with this\ntunnel instance. When the MPLS signalling protocol\nis rsvp(2) this value SHOULD be equal to the Tunnel\n\n\n\nSender Address in the Sender Template object and MAY\nbe equal to the Extended Tunnel Id field in the\nSESSION object. When the MPLS signalling protocol is\ncrldp(3) this value SHOULD be equal to the Ingress\nLSR Router ID field in the LSPID TLV object.")
mplsTunnelEgressLSRId = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 2, 1, 4), MplsExtendedTunnelId()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: mplsTunnelEgressLSRId.setDescription("Identity of the egress LSR associated with this\ntunnel instance.")
mplsTunnelName = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 2, 1, 5), SnmpAdminString().clone('')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelName.setDescription("The canonical name assigned to the tunnel. This name\ncan be used to refer to the tunnel on the LSR's\nconsole port.  If mplsTunnelIsIf is set to true\nthen the ifName of the interface corresponding to\nthis tunnel should have a value equal to\nmplsTunnelName.  Also see the description of ifName\nin RFC 2863.")
mplsTunnelDescr = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 2, 1, 6), SnmpAdminString().clone('')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelDescr.setDescription("A textual string containing information about the\ntunnel.  If there is no description this object\ncontains a zero length string. This object is may\nnot be signaled by MPLS signaling protocols,\n\n\n\nconsequentally the value of this object at transit\nand egress LSRs MAY be automatically generated or\nabsent.")
mplsTunnelIsIf = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 2, 1, 7), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelIsIf.setDescription("Denotes whether or not this tunnel corresponds to an\ninterface represented in the interfaces group\ntable. Note that if this variable is set to true\nthen the ifName of the interface corresponding to\nthis tunnel should have a value equal to\nmplsTunnelName.  Also see the description of ifName\nin RFC 2863.  This object is meaningful only at the\ningress and egress LSRs.")
mplsTunnelIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 2, 1, 8), InterfaceIndexOrZero().clone('0')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelIfIndex.setDescription("If mplsTunnelIsIf is set to true, then this value\ncontains the LSR-assigned ifIndex which corresponds\nto an entry in the interfaces table.  Otherwise\nthis variable should contain the value of zero\nindicating that a valid ifIndex was not assigned to\nthis tunnel interface.")
mplsTunnelOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 2, 1, 9), MplsOwner()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelOwner.setDescription("Denotes the entity that created and is responsible\n\n\n\nfor managing this tunnel. This column is\nautomatically filled by the agent on creation of a\nrow.")
mplsTunnelRole = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 2, 1, 10), Integer().subtype(subtypeSpec=SingleValueConstraint(1,3,4,2,)).subtype(namedValues=NamedValues(("head", 1), ("transit", 2), ("tail", 3), ("headTail", 4), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelRole.setDescription("This value signifies the role that this tunnel\nentry/instance represents. This value MUST be set\nto head(1) at the originating point of the tunnel.\nThis value MUST be set to transit(2) at transit\npoints along the tunnel, if transit points are\nsupported. This value MUST be set to tail(3) at the\nterminating point of the tunnel if tunnel tails are\nsupported.\n\nThe value headTail(4) is provided for tunnels that\nbegin and end on the same LSR.")
mplsTunnelXCPointer = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 2, 1, 11), RowPointer().clone('0.0')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelXCPointer.setDescription("This variable points to a row in the mplsXCTable.\nThis table identifies the segments that compose\nthis tunnel, their characteristics, and\nrelationships to each other. A value of zeroDotZero\nindicates that no LSP has been associated with this\ntunnel yet.")
mplsTunnelSignallingProto = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 2, 1, 12), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,3,4,)).subtype(namedValues=NamedValues(("none", 1), ("rsvp", 2), ("crldp", 3), ("other", 4), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelSignallingProto.setDescription("The signalling protocol, if any, used to setup this\ntunnel.")
mplsTunnelSetupPrio = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)).clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelSetupPrio.setDescription("Indicates the setup priority of this tunnel.")
mplsTunnelHoldingPrio = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 2, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)).clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHoldingPrio.setDescription("Indicates the holding priority for this tunnel.")
mplsTunnelSessionAttributes = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 2, 1, 15), Bits().subtype(namedValues=NamedValues(("fastReroute", 0), ("mergingPermitted", 1), ("isPersistent", 2), ("isPinned", 3), ("recordRoute", 4), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelSessionAttributes.setDescription("This bit mask indicates optional session values for\nthis tunnel. The following describes these bit\nfields:\n\nfastRerouteThis flag indicates that the any tunnel\nhop may choose to reroute this tunnel without\ntearing it down.  This flag permits transit routers\nto use a local repair mechanism which may result in\nviolation of the explicit routing of this tunnel.\nWhen a fault is detected on an adjacent downstream\nlink or node, a transit router can re-route traffic\nfor fast service restoration.\n\nmergingPermitted This flag permits transit routers\nto merge this session with other RSVP sessions for\nthe purpose of reducing resource overhead on\ndownstream transit routers, thereby providing\nbetter network scaling.\n\nisPersistent  Indicates whether this tunnel should\nbe restored automatically after a failure occurs.\n\nisPinned   This flag indicates whether the loose-\nrouted hops of this tunnel are to be pinned.\n\nrecordRouteThis flag indicates whether or not the\nsignalling protocol should remember the tunnel path\nafter it has been signaled.")
mplsTunnelLocalProtectInUse = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 2, 1, 16), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelLocalProtectInUse.setDescription("Indicates that the local repair mechanism is in use\nto maintain this tunnel (usually in the face of an\noutage of the link it was previously routed over).")
mplsTunnelResourcePointer = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 2, 1, 17), RowPointer().clone('0.0')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelResourcePointer.setDescription("This variable represents a pointer to the traffic\nparameter specification for this tunnel.  This\nvalue may point at an entry in the\nmplsTunnelResourceEntry to indicate which\nmplsTunnelResourceEntry is to be assigned to this\nLSP instance.  This value may optionally point at\nan externally defined traffic parameter\nspecification table.  A value of zeroDotZero\nindicates best-effort treatment.  By having the\nsame value of this object, two or more LSPs can\nindicate resource sharing.")
mplsTunnelPrimaryInstance = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 2, 1, 18), MplsTunnelInstanceIndex().clone('0')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelPrimaryInstance.setDescription("Specifies the instance index of the primary instance\nof this tunnel. More details of the definition of\ntunnel instances and the primary tunnel instance\ncan be found in the description of the TEXTUAL-CONVENTION\nMplsTunnelInstanceIndex.")
mplsTunnelInstancePriority = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 2, 1, 19), Unsigned32().clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelInstancePriority.setDescription("This value indicates which priority, in descending\norder, with 0 indicating the lowest priority,\nwithin a group of tunnel instances. A group of\ntunnel instances is defined as a set of LSPs with\nthe same mplsTunnelIndex in this table, but with a\ndifferent mplsTunnelInstance. Tunnel instance\npriorities are used to denote the priority at which\na particular tunnel instance will supercede\nanother. Instances of tunnels containing the same\nmplsTunnelInstancePriority will be used for load\nsharing.")
mplsTunnelHopTableIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 2, 1, 20), MplsPathIndexOrZero().clone('0')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopTableIndex.setDescription("Index into the mplsTunnelHopTable entry that\nspecifies the explicit route hops for this tunnel.\nThis object is meaningful only at the head-end of\nthe tunnel.")
mplsTunnelPathInUse = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 2, 1, 21), MplsPathIndexOrZero().clone('0')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelPathInUse.setDescription("This value denotes the configured path that was\nchosen for this tunnel. This value reflects the\nsecondary index into mplsTunnelHopTable. This path\nmay not exactly match the one in\nmplsTunnelARHopTable due to the fact that some CSPF\nmodification may have taken place. See\nmplsTunnelARHopTable for the actual path being\ntaken by the tunnel. A value of zero denotes that\nno path is currently in use or available.")
mplsTunnelARHopTableIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 2, 1, 22), MplsPathIndexOrZero().clone('0')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelARHopTableIndex.setDescription("Index into the mplsTunnelARHopTable entry that\nspecifies the actual hops traversed by the tunnel.\nThis is automatically updated by the agent when the\nactual hops becomes available.")
mplsTunnelCHopTableIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 2, 1, 23), MplsPathIndexOrZero().clone('0')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelCHopTableIndex.setDescription("Index into the mplsTunnelCHopTable entry that\nspecifies the computed hops traversed by the\ntunnel. This is automatically updated by the agent\nwhen computed hops become available or when\ncomputed hops get modified.")
mplsTunnelIncludeAnyAffinity = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 2, 1, 24), MplsTunnelAffinity()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelIncludeAnyAffinity.setDescription("A link satisfies the include-any constraint if and\nonly if the constraint is zero, or the link and the\nconstraint have a resource class in common.")
mplsTunnelIncludeAllAffinity = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 2, 1, 25), MplsTunnelAffinity()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelIncludeAllAffinity.setDescription("A link satisfies the include-all constraint if and\nonly if the link contains all of the administrative\ngroups specified in the constraint.")
mplsTunnelExcludeAnyAffinity = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 2, 1, 26), MplsTunnelAffinity().clone('0')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelExcludeAnyAffinity.setDescription("A link satisfies the exclude-any constraint if and\nonly if the link contains none of the\nadministrative groups specified in the constraint.")
mplsTunnelTotalUpTime = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 2, 1, 27), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelTotalUpTime.setDescription("This value represents the aggregate up time for all\ninstances of this tunnel, if available. If this\nvalue is unavailable, it MUST return a value of 0.")
mplsTunnelInstanceUpTime = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 2, 1, 28), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelInstanceUpTime.setDescription("This value identifies the total time that this\ntunnel instance's operStatus has been Up(1).")
mplsTunnelPrimaryUpTime = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 2, 1, 29), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelPrimaryUpTime.setDescription("Specifies the total time the primary instance of\nthis tunnel has been active. The primary instance\nof this tunnel is defined in\nmplsTunnelPrimaryInstance.")
mplsTunnelPathChanges = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 2, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelPathChanges.setDescription("Specifies the number of times the actual path for\nthis tunnel instance has changed.")
mplsTunnelLastPathChange = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 2, 1, 31), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelLastPathChange.setDescription("Specifies the time since the last change to the\nactual path for this tunnel instance.")
mplsTunnelCreationTime = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 2, 1, 32), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelCreationTime.setDescription("Specifies the value of SysUpTime when the first\ninstance of this tunnel came into existence.\nThat is, when the value of mplsTunnelOperStatus\nwas first set to up(1).")
mplsTunnelStateTransitions = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 2, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelStateTransitions.setDescription("Specifies the number of times the state\n(mplsTunnelOperStatus) of this tunnel instance has\nchanged.")
mplsTunnelAdminStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 2, 1, 34), Integer().subtype(subtypeSpec=SingleValueConstraint(2,3,1,)).subtype(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelAdminStatus.setDescription("Indicates the desired operational status of this\ntunnel.")
mplsTunnelOperStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 2, 1, 35), Integer().subtype(subtypeSpec=SingleValueConstraint(2,5,7,4,6,3,1,)).subtype(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3), ("unknown", 4), ("dormant", 5), ("notPresent", 6), ("lowerLayerDown", 7), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelOperStatus.setDescription("Indicates the actual operational status of this\ntunnel, which is typically but not limited to, a\nfunction of the state of individual segments of\nthis tunnel.")
mplsTunnelRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 2, 1, 36), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelRowStatus.setDescription("This variable is used to create, modify, and/or\ndelete a row in this table.  When a row in this\ntable is in active(1) state, no objects in that row\ncan be modified by the agent except\nmplsTunnelAdminStatus, mplsTunnelRowStatus and\nmplsTunnelStorageType.")
mplsTunnelStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 2, 1, 37), StorageType().clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelStorageType.setDescription("The storage type for this tunnel entry.\nConceptual rows having the value 'permanent'\nneed not allow write-access to any columnar\nobjects in the row.")
mplsTunnelHopListIndexNext = MibScalar((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 3), MplsPathIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelHopListIndexNext.setDescription("This object contains an appropriate value to be used\nfor mplsTunnelHopListIndex when creating entries in\nthe mplsTunnelHopTable.  If the number of\nunassigned entries is exhausted, a retrieval\n\n\n\noperation will return a value of 0.  This object\nmay also return a value of 0 when the LSR is unable\nto accept conceptual row creation, for example, if\nthe mplsTunnelHopTable is implemented as read-only.\nTo obtain the value of mplsTunnelHopListIndex for a\nnew entry in the mplsTunnelHopTable, the manager\nissues a management protocol retrieval operation to\nobtain the current value of mplsTunnelHopIndex.\n\nWhen the SET is performed to create a row in the\nmplsTunnelHopTable, the Command Responder (agent)\nmust determine whether the value is indeed still\nunused; Two Network Management Applications may\nattempt to create a row (configuration entry)\nsimultaneously and use the same value. If it is\ncurrently unused, the SET succeeds and the Command\nResponder (agent) changes the value of this object,\naccording to an implementation-specific algorithm.\nIf the value is in use, however, the SET fails.  The\nNetwork Management Application must then re-read\nthis variable to obtain a new usable value.")
mplsTunnelHopTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 4))
if mibBuilder.loadTexts: mplsTunnelHopTable.setDescription("The mplsTunnelHopTable is used to indicate the hops,\nstrict or loose, for an instance of an MPLS tunnel\ndefined in mplsTunnelTable, when it is established\nvia signalling, for the outgoing direction of the\ntunnel. Thus at a transit LSR, this table contains\nthe desired path of the tunnel from this LSR\nonwards. Each row in this table is indexed by\nmplsTunnelHopListIndex which corresponds to a group\nof hop lists or path options.  Each row also has a\nsecondary index mplsTunnelHopIndex, which indicates\na group of hops (also known as a path option).\nFinally, the third index, mplsTunnelHopIndex\nindicates the specific hop information for a path\noption. In case we want to specify a particular\ninterface on the originating LSR of an outgoing\ntunnel by which we want packets to exit the LSR,\nwe specify this as the first hop for this tunnel in\nmplsTunnelHopTable.")
mplsTunnelHopEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 4, 1)).setIndexNames((0, "MPLS-TE-STD-MIB", "mplsTunnelHopListIndex"), (0, "MPLS-TE-STD-MIB", "mplsTunnelHopPathOptionIndex"), (0, "MPLS-TE-STD-MIB", "mplsTunnelHopIndex"))
if mibBuilder.loadTexts: mplsTunnelHopEntry.setDescription("An entry in this table represents a tunnel hop.  An\nentry is created by a network administrator for\nsignaled ERLSP set up by an MPLS signalling\nprotocol.")
mplsTunnelHopListIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 4, 1, 1), MplsPathIndex()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: mplsTunnelHopListIndex.setDescription("Primary index into this table identifying a\nparticular explicit route object.")
mplsTunnelHopPathOptionIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 4, 1, 2), MplsPathIndex()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: mplsTunnelHopPathOptionIndex.setDescription("Secondary index into this table identifying a\nparticular group of hops representing a particular\nconfigured path. This is otherwise known as a path\noption.")
mplsTunnelHopIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 4, 1, 3), MplsPathIndex()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: mplsTunnelHopIndex.setDescription("Tertiary index into this table identifying a\nparticular hop.")
mplsTunnelHopAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 4, 1, 4), TeHopAddressType().clone('ipv4')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopAddrType.setDescription("The Hop Address Type of this tunnel hop.\n\nThe value of this object cannot be changed\nif the value of the corresponding\nmplsTunnelHopRowStatus object is 'active'.\n\nNote that lspid(5) is a valid option only\nfor tunnels signaled via CRLDP.")
mplsTunnelHopIpAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 4, 1, 5), TeHopAddress().clone(hexValue='00000000')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopIpAddr.setDescription("The Tunnel Hop Address for this tunnel hop.\n\nThe type of this address is determined by the\nvalue of the corresponding mplsTunnelHopAddrType.\n\nThe value of this object cannot be changed\nif the value of the corresponding\nmplsTunnelHopRowStatus object is 'active'.")
mplsTunnelHopIpPrefixLen = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 4, 1, 6), InetAddressPrefixLength().clone('32')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopIpPrefixLen.setDescription("If mplsTunnelHopAddrType is set to ipv4(1) or\nipv6(2), then this value will contain an\nappropriate prefix length for the IP address in\nobject mplsTunnelHopIpAddr. Otherwise this value\nis irrelevant and should be ignored.")
mplsTunnelHopAsNumber = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 4, 1, 7), TeHopAddressAS()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopAsNumber.setDescription("If mplsTunnelHopAddrType is set to asnumber(3), then\nthis value will contain the AS number of this hop.\nOtherwise the agent should set this object to zero-\nlength string and the manager should ignore this.")
mplsTunnelHopAddrUnnum = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 4, 1, 8), TeHopAddressUnnum()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopAddrUnnum.setDescription("If mplsTunnelHopAddrType is set to unnum(4), then\nthis value will contain the interface identifier of\nthe unnumbered interface for this hop. This object\nshould be used in conjunction with\nmplsTunnelHopIpAddress which would contain the LSR\nRouter ID in this case. Otherwise the agent should\nset this object to zero-length string and the\nmanager should ignore this.")
mplsTunnelHopLspId = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 4, 1, 9), MplsLSPID()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopLspId.setDescription("If mplsTunnelHopAddrType is set to lspid(5), then\nthis value will contain the LSPID of a tunnel of\nthis hop. The present tunnel being configured is\ntunneled through this hop (using label stacking).\nThis object is otherwise insignificant and should\n\n\n\ncontain a value of 0 to indicate this fact.")
mplsTunnelHopType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 4, 1, 10), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("strict", 1), ("loose", 2), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopType.setDescription("Denotes whether this tunnel hop is routed in a\nstrict or loose fashion. The value of this object\nhas no meaning if the mplsTunnelHopInclude object\nis set to 'false'.")
mplsTunnelHopInclude = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 4, 1, 11), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopInclude.setDescription("If this value is set to true, then this indicates\nthat this hop must be included in the tunnel's\npath. If this value is set to 'false', then this hop\nmust be avoided when calculating the path for this\ntunnel. The default value of this object is 'true',\nso that by default all indicated hops are included\nin the CSPF path computation. If this object is set\nto 'false' the value of mplsTunnelHopType should be\nignored.")
mplsTunnelHopPathOptionName = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 4, 1, 12), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopPathOptionName.setDescription("The description of this series of hops as they\nrelate to the specified path option. The\nvalue of this object SHOULD be the same for\neach hop in the series that comprises a\npath option.")
mplsTunnelHopEntryPathComp = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 4, 1, 13), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("dynamic", 1), ("explicit", 2), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopEntryPathComp.setDescription("If this value is set to dynamic, then the user\nshould only specify the source and destination of\nthe path and expect that the CSPF will calculate\nthe remainder of the path.  If this value is set to\nexplicit, the user should specify the entire path\nfor the tunnel to take.  This path may contain\nstrict or loose hops.  Each hop along a specific\npath SHOULD have this object set to the same value")
mplsTunnelHopRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 4, 1, 14), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopRowStatus.setDescription("This variable is used to create, modify, and/or\ndelete a row in this table.  When a row in this\ntable is in active(1) state, no objects in that row\ncan be modified by the agent except\nmplsTunnelHopRowStatus and\nmplsTunnelHopStorageType.")
mplsTunnelHopStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 4, 1, 15), StorageType().clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelHopStorageType.setDescription("The storage type for this Hop entry. Conceptual\nrows having the value 'permanent' need not\nallow write-access to any columnar objects\nin the row.")
mplsTunnelResourceIndexNext = MibScalar((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelResourceIndexNext.setDescription("This object contains the next appropriate value to\nbe used for mplsTunnelResourceIndex when creating\nentries in the mplsTunnelResourceTable. If the\nnumber of unassigned entries is exhausted, a\nretrieval operation will return a value of 0.  This\nobject may also return a value of 0 when the LSR is\nunable to accept conceptual row creation, for\nexample, if the mplsTunnelTable is implemented as\nread-only.  To obtain the mplsTunnelResourceIndex\nvalue for a new entry, the manager must first issue\na management protocol retrieval operation to obtain\nthe current value of this object.\n\nWhen the SET is performed to create a row in the\nmplsTunnelResourceTable, the Command Responder\n(agent) must determine whether the value is indeed\nstill unused; Two Network Management Applications\nmay attempt to create a row (configuration entry)\nsimultaneously and use the same value. If it is\ncurrently unused, the SET succeeds and the Command\nResponder (agent) changes the value of this object,\naccording to an implementation-specific algorithm.\nIf the value is in use, however, the SET fails.  The\nNetwork Management Application must then re-read\nthis variable to obtain a new usable value.")
mplsTunnelResourceTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 6))
if mibBuilder.loadTexts: mplsTunnelResourceTable.setDescription("The mplsTunnelResourceTable allows a manager to\nspecify which resources are desired for an MPLS\ntunnel.  This table also allows several tunnels to\npoint to a single entry in this table, implying\nthat these tunnels should share resources.")
mplsTunnelResourceEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 6, 1)).setIndexNames((0, "MPLS-TE-STD-MIB", "mplsTunnelResourceIndex"))
if mibBuilder.loadTexts: mplsTunnelResourceEntry.setDescription("An entry in this table represents a set of resources\nfor an MPLS tunnel.  An entry can be created by a\n\n\n\nnetwork administrator or by an SNMP agent as\ninstructed by any MPLS signalling protocol.\nAn entry in this table referenced by a tunnel instance\nwith zero mplsTunnelInstance value indicates a\nconfigured set of resource parameter. An entry\nreferenced by a tunnel instance with a non-zero\nmplsTunnelInstance reflects the in-use resource\nparameters for the tunnel instance which may have\nbeen negotiated or modified by the MPLS signaling\nprotocols.")
mplsTunnelResourceIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 6, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: mplsTunnelResourceIndex.setDescription("Uniquely identifies this row.")
mplsTunnelResourceMaxRate = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 6, 1, 2), MplsBitRate()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelResourceMaxRate.setDescription("The maximum rate in bits/second.  Note that setting\nmplsTunnelResourceMaxRate,\nmplsTunnelResourceMeanRate, and\nmplsTunnelResourceMaxBurstSize to 0 indicates best-\neffort treatment.")
mplsTunnelResourceMeanRate = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 6, 1, 3), MplsBitRate()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelResourceMeanRate.setDescription("This object is copied into an instance of\nmplsTrafficParamMeanRate in the\nmplsTrafficParamTable. The OID of this table entry\nis then copied into the corresponding\nmplsInSegmentTrafficParamPtr.")
mplsTunnelResourceMaxBurstSize = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 6, 1, 4), MplsBurstSize()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelResourceMaxBurstSize.setDescription("The maximum burst size in bytes.")
mplsTunnelResourceMeanBurstSize = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 6, 1, 5), MplsBurstSize()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelResourceMeanBurstSize.setDescription("The mean burst size in bytes.  The implementations\nwhich do not implement this variable must return\na noSuchObject exception for this object and must\nnot allow a user to set this object.")
mplsTunnelResourceExBurstSize = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 6, 1, 6), MplsBurstSize()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelResourceExBurstSize.setDescription("The Excess burst size in bytes.  The implementations\nwhich do not implement this variable must return\nnoSuchObject exception for this object and must\nnot allow a user to set this value.")
mplsTunnelResourceFrequency = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 6, 1, 7), Integer().subtype(subtypeSpec=SingleValueConstraint(3,2,1,)).subtype(namedValues=NamedValues(("unspecified", 1), ("frequent", 2), ("veryFrequent", 3), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelResourceFrequency.setDescription("The granularity of the availability of committed\nrate.  The implementations which do not implement\nthis variable must return unspecified(1) for this\nvalue and must not allow a user to set this value.")
mplsTunnelResourceWeight = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 6, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelResourceWeight.setDescription("The relative weight for using excess bandwidth above\nits committed rate.  The value of 0 means that\nweight is not applicable for the CR-LSP.")
mplsTunnelResourceRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 6, 1, 9), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelResourceRowStatus.setDescription("This variable is used to create, modify, and/or\ndelete a row in this table.  When a row in this\ntable is in active(1) state, no objects in that row\ncan be modified by the agent except\nmplsTunnelResourceRowStatus and\nmplsTunnelResourceStorageType.")
mplsTunnelResourceStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 6, 1, 10), StorageType().clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelResourceStorageType.setDescription("The storage type for this Hop entry. Conceptual\nrows having the value 'permanent' need not\nallow write-access to any columnar objects\n\n\n\nin the row.")
mplsTunnelARHopTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 7))
if mibBuilder.loadTexts: mplsTunnelARHopTable.setDescription("The mplsTunnelARHopTable is used to indicate the\nhops for an MPLS tunnel defined in mplsTunnelTable,\nas reported by the MPLS signalling protocol. Thus at\na transit LSR, this table (if the table is supported\nand if the signaling protocol is recording actual\nroute information) contains the actual route of the\nwhole tunnel. If the signaling protocol is not\nrecording the actual route, this table MAY report\nthe information from the mplsTunnelHopTable or the\nmplsTunnelCHopTable.\n\nEach row in this table is indexed by\nmplsTunnelARHopListIndex. Each row also has a\nsecondary index mplsTunnelARHopIndex, corresponding\nto the next hop that this row corresponds to.\n\nPlease note that since the information necessary to\nbuild entries within this table is not provided by\nsome MPLS signalling protocols, implementation of\nthis table is optional. Furthermore, since the\ninformation in this table is actually provided by\nthe MPLS signalling protocol after the path has\nbeen set-up, the entries in this table are provided\nonly for observation, and hence, all variables in\nthis table are accessible exclusively as read-\nonly.\n\nNote also that the contents of this table may change\nwhile it is being read because of re-routing\nactivities. A network administrator may verify that\nthe actual route read is consistent by reference to\nthe mplsTunnelLastPathChange object.")
mplsTunnelARHopEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 7, 1)).setIndexNames((0, "MPLS-TE-STD-MIB", "mplsTunnelARHopListIndex"), (0, "MPLS-TE-STD-MIB", "mplsTunnelARHopIndex"))
if mibBuilder.loadTexts: mplsTunnelARHopEntry.setDescription("An entry in this table represents a tunnel hop.  An\nentry is created by the agent for signaled ERLSP\nset up by an MPLS signalling protocol.")
mplsTunnelARHopListIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 7, 1, 1), MplsPathIndex()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: mplsTunnelARHopListIndex.setDescription("Primary index into this table identifying a\nparticular recorded hop list.")
mplsTunnelARHopIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 7, 1, 2), MplsPathIndex()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: mplsTunnelARHopIndex.setDescription("Secondary index into this table identifying the\nparticular hop.")
mplsTunnelARHopAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 7, 1, 3), TeHopAddressType().clone('ipv4')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelARHopAddrType.setDescription("The Hop Address Type of this tunnel hop.\n\nNote that lspid(5) is a valid option only\nfor tunnels signaled via CRLDP.")
mplsTunnelARHopIpAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 7, 1, 4), TeHopAddress().clone(hexValue='00000000')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelARHopIpAddr.setDescription("The Tunnel Hop Address for this tunnel hop.\n\nThe type of this address is determined by the\nvalue of the corresponding mplsTunnelARHopAddrType.\nIf mplsTunnelARHopAddrType is set to unnum(4),\n then this value contains the LSR Router ID of the\n unnumbered interface. Otherwise the agent SHOULD\n set this object to the zero-length string and the\n manager should ignore this object.")
mplsTunnelARHopAddrUnnum = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 7, 1, 5), TeHopAddressUnnum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelARHopAddrUnnum.setDescription("If mplsTunnelARHopAddrType is set to unnum(4), then\nthis value will contain the interface identifier of\nthe unnumbered interface for this hop. This object\nshould be used in conjunction with\nmplsTunnelARHopIpAddr which would contain the LSR\nRouter ID in this case. Otherwise the agent should\nset this object to zero-length string and the\nmanager should ignore this.")
mplsTunnelARHopLspId = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 7, 1, 6), MplsLSPID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelARHopLspId.setDescription("If mplsTunnelARHopAddrType is set to lspid(5), then\nthis value will contain the LSP ID of this hop.\nThis object is otherwise insignificant and should\ncontain a value of 0 to indicate this fact.")
mplsTunnelCHopTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 8))
if mibBuilder.loadTexts: mplsTunnelCHopTable.setDescription("The mplsTunnelCHopTable is used to indicate the\nhops, strict or loose, for an MPLS tunnel defined\nin mplsTunnelTable, as computed by a constraint-\nbased routing protocol, based on the\nmplsTunnelHopTable for the outgoing direction of\nthe tunnel. Thus at a transit LSR, this table (if\nthe table is supported) MAY contain the path\ncomputed by the CSPF engine on (or on behalf of)\nthis LSR. Each row in this table is indexed by\nmplsTunnelCHopListIndex.  Each row also has a\nsecondary index mplsTunnelCHopIndex, corresponding\nto the next hop that this row corresponds to. In\ncase we want to specify a particular interface on\nthe originating LSR of an outgoing tunnel by which\nwe want packets to exit the LSR, we specify this as\nthe first hop for this tunnel in\nmplsTunnelCHopTable.\n\nPlease note that since the information necessary to\nbuild entries within this table may not be\nsupported by some LSRs, implementation of this\ntable is optional. Furthermore, since the\ninformation in this table describes the path\ncomputed by the CSPF engine the entries in this\ntable are read-only.")
mplsTunnelCHopEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 8, 1)).setIndexNames((0, "MPLS-TE-STD-MIB", "mplsTunnelCHopListIndex"), (0, "MPLS-TE-STD-MIB", "mplsTunnelCHopIndex"))
if mibBuilder.loadTexts: mplsTunnelCHopEntry.setDescription("An entry in this table represents a tunnel hop.  An\nentry in this table is created by a path\ncomputation engine using CSPF techniques applied to\nthe information collected by routing protocols and\nthe hops specified in the corresponding\nmplsTunnelHopTable.")
mplsTunnelCHopListIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 8, 1, 1), MplsPathIndex()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: mplsTunnelCHopListIndex.setDescription("Primary index into this table identifying a\nparticular computed hop list.")
mplsTunnelCHopIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 8, 1, 2), MplsPathIndex()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: mplsTunnelCHopIndex.setDescription("Secondary index into this table identifying the\nparticular hop.")
mplsTunnelCHopAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 8, 1, 3), TeHopAddressType().clone('ipv4')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelCHopAddrType.setDescription("The Hop Address Type of this tunnel hop.\n\nNote that lspid(5) is a valid option only\nfor tunnels signaled via CRLDP.")
mplsTunnelCHopIpAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 8, 1, 4), TeHopAddress().clone(hexValue='00000000')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelCHopIpAddr.setDescription("The Tunnel Hop Address for this tunnel hop.\n\n\n\n\nThe type of this address is determined by the\n value of the corresponding mplsTunnelCHopAddrType.\n\nIf mplsTunnelCHopAddrType is set to unnum(4), then\n this value will contain the LSR Router ID of the\n unnumbered interface. Otherwise the agent should\n set this object to the zero-length string and the\n manager SHOULD ignore this object.")
mplsTunnelCHopIpPrefixLen = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 8, 1, 5), InetAddressPrefixLength().clone('32')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelCHopIpPrefixLen.setDescription("If mplsTunnelCHopAddrType is set to ipv4(1) or\nipv6(2), then this value will contain an\nappropriate prefix length for the IP address in\nobject mplsTunnelCHopIpAddr. Otherwise this value\nis irrelevant and should be ignored.")
mplsTunnelCHopAsNumber = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 8, 1, 6), TeHopAddressAS()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelCHopAsNumber.setDescription("If mplsTunnelCHopAddrType is set to asnumber(3),\nthen this value will contain the AS number of this\nhop. Otherwise the agent should set this object to\nzero-length string and the manager should ignore\nthis.")
mplsTunnelCHopAddrUnnum = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 8, 1, 7), TeHopAddressUnnum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelCHopAddrUnnum.setDescription("If mplsTunnelCHopAddrType is set to unnum(4), then\nthis value will contain the unnumbered interface\nidentifier of this hop. This object should be used\nin conjunction with mplsTunnelCHopIpAddr which\nwould contain the LSR Router ID in this case.\n\n\n\nOtherwise the agent should set this object to zero-\nlength string and the manager should ignore this.")
mplsTunnelCHopLspId = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 8, 1, 8), MplsLSPID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelCHopLspId.setDescription("If mplsTunnelCHopAddrType is set to lspid(5), then\nthis value will contain the LSP ID of this hop.\nThis object is otherwise insignificant and should\ncontain a value of 0 to indicate this fact.")
mplsTunnelCHopType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 8, 1, 9), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("strict", 1), ("loose", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelCHopType.setDescription("Denotes whether this is tunnel hop is routed in a\nstrict or loose fashion.")
mplsTunnelPerfTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 9))
if mibBuilder.loadTexts: mplsTunnelPerfTable.setDescription("This table provides per-tunnel instance MPLS\nperformance information.")
mplsTunnelPerfEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 9, 1))
if mibBuilder.loadTexts: mplsTunnelPerfEntry.setDescription("An entry in this table is created by the LSR for\nevery tunnel.  Its is an extension to\nmplsTunnelEntry.")
mplsTunnelPerfPackets = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 9, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelPerfPackets.setDescription("Number of packets forwarded by the tunnel.\nThis object should represents the 32-bit\nvalue of the least significant part of the\n64-bit value if both mplsTunnelPerfHCPackets\nis returned.")
mplsTunnelPerfHCPackets = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 9, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelPerfHCPackets.setDescription("High capacity counter for number of packets\nforwarded by the tunnel. ")
mplsTunnelPerfErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 9, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelPerfErrors.setDescription("Number of packets dropped because of errors or for\nother reasons.")
mplsTunnelPerfBytes = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 9, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelPerfBytes.setDescription("Number of bytes forwarded by the tunnel.\nThis object should represents the 32-bit\n\n\n\nvalue of the least significant part of the\n64-bit value if both mplsTunnelPerfHCBytes\nis returned.")
mplsTunnelPerfHCBytes = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 9, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelPerfHCBytes.setDescription("High capacity counter for number of bytes forwarded\nby the tunnel.")
mplsTunnelCRLDPResTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 10))
if mibBuilder.loadTexts: mplsTunnelCRLDPResTable.setDescription("The mplsTunnelCRLDPResTable allows a manager to\nspecify which CR-LDP-specific resources are desired\nfor an MPLS tunnel if that tunnel is signaled using\nCR-LDP. Note that these attributes are in addition\nto those specified in mplsTunnelResourceTable. This\ntable also allows several tunnels to point to a\nsingle entry in this table, implying that these\ntunnels should share resources.")
mplsTunnelCRLDPResEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 10, 1)).setIndexNames((0, "MPLS-TE-STD-MIB", "mplsTunnelResourceIndex"))
if mibBuilder.loadTexts: mplsTunnelCRLDPResEntry.setDescription("An entry in this table represents a set of resources\nfor an MPLS tunnel established using CRLDP\n(mplsTunnelSignallingProto equal to crldp (3)). An\nentry can be created by a network administrator or\nby an SNMP agent as instructed by any MPLS\nsignalling protocol.")
mplsTunnelCRLDPResMeanBurstSize = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 10, 1, 1), MplsBurstSize()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelCRLDPResMeanBurstSize.setDescription("The mean burst size in bytes.")
mplsTunnelCRLDPResExBurstSize = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 10, 1, 2), MplsBurstSize()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelCRLDPResExBurstSize.setDescription("The Excess burst size in bytes.")
mplsTunnelCRLDPResFrequency = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 10, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(3,2,1,)).subtype(namedValues=NamedValues(("unspecified", 1), ("frequent", 2), ("veryFrequent", 3), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelCRLDPResFrequency.setDescription("The granularity of the availability of committed\nrate.")
mplsTunnelCRLDPResWeight = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelCRLDPResWeight.setDescription("The relative weight for using excess bandwidth above\nits committed rate.  The value of 0 means that\nweight is not applicable for the CR-LSP.")
mplsTunnelCRLDPResFlags = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 63)).clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelCRLDPResFlags.setDescription("The value of the 1 byte Flags conveyed as part of\nthe traffic parameters during the establishment of\nthe CRLSP. The bits in this object are to be\ninterpreted as follows.\n\n+--+--+--+--+--+--+--+--+\n| Res |F6|F5|F4|F3|F2|F1|\n+--+--+--+--+--+--+--+--+\n\nRes - These bits are reserved. Zero on transmission.\nIgnored on receipt.\nF1 - Corresponds to the PDR.\nF2 - Corresponds to the PBS.\nF3 - Corresponds to the CDR.\nF4 - Corresponds to the CBS.\nF5 - Corresponds to the EBS.\nF6 - Corresponds to the Weight.\n\nEach flag if is a Negotiable Flag corresponding to a\nTraffic Parameter. The Negotiable Flag value zero\ndenotes Not Negotiable and value one denotes\nNegotiable.")
mplsTunnelCRLDPResRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 10, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelCRLDPResRowStatus.setDescription("This variable is used to create, modify, and/or\ndelete a row in this table.  When a row in this\ntable is in active(1) state, no objects in that row\ncan be modified by the agent except\nmplsTunnelCRLDPResRowStatus and\nmplsTunnelCRLDPResStorageType.")
mplsTunnelCRLDPResStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 10, 1, 7), StorageType().clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTunnelCRLDPResStorageType.setDescription("The storage type for this CR-LDP Resource entry.\nConceptual rows having the value 'permanent'\nneed not allow write-access to any columnar\nobjects in the row.")
mplsTunnelNotificationEnable = MibScalar((1, 3, 6, 1, 2, 1, 10, 166, 3, 2, 11), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mplsTunnelNotificationEnable.setDescription("If this object is true, then it enables the\ngeneration of mplsTunnelUp and mplsTunnelDown\ntraps, otherwise these traps are not emitted.")
mplsTeConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 3, 3))
mplsTeGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 3, 3, 1))
mplsTeCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 3, 3, 2))

# Augmentions
mplsTunnelEntry.registerAugmentions(("MPLS-TE-STD-MIB", "mplsTunnelPerfEntry"))
mplsTunnelPerfEntry.setIndexNames(*mplsTunnelEntry.getIndexNames())

# Notifications

mplsTunnelUp = NotificationType((1, 3, 6, 1, 2, 1, 10, 166, 3, 0, 1)).setObjects(*(("MPLS-TE-STD-MIB", "mplsTunnelOperStatus"), ("MPLS-TE-STD-MIB", "mplsTunnelAdminStatus"), ) )
if mibBuilder.loadTexts: mplsTunnelUp.setDescription("This notification is generated when a\nmplsTunnelOperStatus object for one of the\nconfigured tunnels is about to leave the down state\nand transition into some other state (but not into\nthe notPresent state).  This other state is\nindicated by the included value of\nmplsTunnelOperStatus.")
mplsTunnelDown = NotificationType((1, 3, 6, 1, 2, 1, 10, 166, 3, 0, 2)).setObjects(*(("MPLS-TE-STD-MIB", "mplsTunnelOperStatus"), ("MPLS-TE-STD-MIB", "mplsTunnelAdminStatus"), ) )
if mibBuilder.loadTexts: mplsTunnelDown.setDescription("This notification is generated when a\nmplsTunnelOperStatus object for one of the\nconfigured tunnels is about to enter the down state\nfrom some other state (but not from the notPresent\nstate).  This other state is indicated by the\nincluded value of mplsTunnelOperStatus.")
mplsTunnelRerouted = NotificationType((1, 3, 6, 1, 2, 1, 10, 166, 3, 0, 3)).setObjects(*(("MPLS-TE-STD-MIB", "mplsTunnelOperStatus"), ("MPLS-TE-STD-MIB", "mplsTunnelAdminStatus"), ) )
if mibBuilder.loadTexts: mplsTunnelRerouted.setDescription("This notification is generated when a tunnel is\nrerouted. If the mplsTunnelARHopTable is used, then\nthis tunnel instance's entry in the\nmplsTunnelARHopTable MAY contain the new path for\nthis tunnel some time after this trap is issued by\nthe agent.")
mplsTunnelReoptimized = NotificationType((1, 3, 6, 1, 2, 1, 10, 166, 3, 0, 4)).setObjects(*(("MPLS-TE-STD-MIB", "mplsTunnelOperStatus"), ("MPLS-TE-STD-MIB", "mplsTunnelAdminStatus"), ) )
if mibBuilder.loadTexts: mplsTunnelReoptimized.setDescription("This notification is generated when a tunnel is\nreoptimized. If the mplsTunnelARHopTable is used,\nthen this tunnel instance's entry in the\nmplsTunnelARHopTable MAY contain the new path for\nthis tunnel some time after this trap is issued by\nthe agent.")

# Groups

mplsTunnelGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 166, 3, 3, 1, 1)).setObjects(*(("MPLS-TE-STD-MIB", "mplsTunnelPerfHCBytes"), ("MPLS-TE-STD-MIB", "mplsTunnelInstancePriority"), ("MPLS-TE-STD-MIB", "mplsTunnelARHopTableIndex"), ("MPLS-TE-STD-MIB", "mplsTunnelResourceMaxBurstSize"), ("MPLS-TE-STD-MIB", "mplsTunnelName"), ("MPLS-TE-STD-MIB", "mplsTunnelARHopLspId"), ("MPLS-TE-STD-MIB", "mplsTunnelResourceMeanRate"), ("MPLS-TE-STD-MIB", "mplsTunnelRole"), ("MPLS-TE-STD-MIB", "mplsTunnelResourceExBurstSize"), ("MPLS-TE-STD-MIB", "mplsTunnelPerfPackets"), ("MPLS-TE-STD-MIB", "mplsTunnelActive"), ("MPLS-TE-STD-MIB", "mplsTunnelNotificationEnable"), ("MPLS-TE-STD-MIB", "mplsTunnelStateTransitions"), ("MPLS-TE-STD-MIB", "mplsTunnelResourceFrequency"), ("MPLS-TE-STD-MIB", "mplsTunnelStorageType"), ("MPLS-TE-STD-MIB", "mplsTunnelIncludeAllAffinity"), ("MPLS-TE-STD-MIB", "mplsTunnelCHopIpPrefixLen"), ("MPLS-TE-STD-MIB", "mplsTunnelInstanceUpTime"), ("MPLS-TE-STD-MIB", "mplsTunnelARHopAddrUnnum"), ("MPLS-TE-STD-MIB", "mplsTunnelCHopType"), ("MPLS-TE-STD-MIB", "mplsTunnelCHopTableIndex"), ("MPLS-TE-STD-MIB", "mplsTunnelCHopIpAddr"), ("MPLS-TE-STD-MIB", "mplsTunnelPerfBytes"), ("MPLS-TE-STD-MIB", "mplsTunnelResourceStorageType"), ("MPLS-TE-STD-MIB", "mplsTunnelResourcePointer"), ("MPLS-TE-STD-MIB", "mplsTunnelIfIndex"), ("MPLS-TE-STD-MIB", "mplsTunnelCHopAddrUnnum"), ("MPLS-TE-STD-MIB", "mplsTunnelPrimaryInstance"), ("MPLS-TE-STD-MIB", "mplsTunnelIncludeAnyAffinity"), ("MPLS-TE-STD-MIB", "mplsTunnelPrimaryUpTime"), ("MPLS-TE-STD-MIB", "mplsTunnelResourceIndexNext"), ("MPLS-TE-STD-MIB", "mplsTunnelOwner"), ("MPLS-TE-STD-MIB", "mplsTunnelRowStatus"), ("MPLS-TE-STD-MIB", "mplsTunnelResourceMaxRate"), ("MPLS-TE-STD-MIB", "mplsTunnelHopTableIndex"), ("MPLS-TE-STD-MIB", "mplsTunnelCHopAsNumber"), ("MPLS-TE-STD-MIB", "mplsTunnelOperStatus"), ("MPLS-TE-STD-MIB", "mplsTunnelTotalUpTime"), ("MPLS-TE-STD-MIB", "mplsTunnelLastPathChange"), ("MPLS-TE-STD-MIB", "mplsTunnelCreationTime"), ("MPLS-TE-STD-MIB", "mplsTunnelDescr"), ("MPLS-TE-STD-MIB", "mplsTunnelARHopIpAddr"), ("MPLS-TE-STD-MIB", "mplsTunnelPathInUse"), ("MPLS-TE-STD-MIB", "mplsTunnelPerfErrors"), ("MPLS-TE-STD-MIB", "mplsTunnelPathChanges"), ("MPLS-TE-STD-MIB", "mplsTunnelResourceMeanBurstSize"), ("MPLS-TE-STD-MIB", "mplsTunnelPerfHCPackets"), ("MPLS-TE-STD-MIB", "mplsTunnelConfigured"), ("MPLS-TE-STD-MIB", "mplsTunnelCHopLspId"), ("MPLS-TE-STD-MIB", "mplsTunnelCHopAddrType"), ("MPLS-TE-STD-MIB", "mplsTunnelARHopAddrType"), ("MPLS-TE-STD-MIB", "mplsTunnelResourceRowStatus"), ("MPLS-TE-STD-MIB", "mplsTunnelAdminStatus"), ("MPLS-TE-STD-MIB", "mplsTunnelResourceWeight"), ("MPLS-TE-STD-MIB", "mplsTunnelIndexNext"), ("MPLS-TE-STD-MIB", "mplsTunnelXCPointer"), ("MPLS-TE-STD-MIB", "mplsTunnelExcludeAnyAffinity"), ) )
if mibBuilder.loadTexts: mplsTunnelGroup.setDescription("Necessary, but not sufficient, set of objects to\nimplement tunnels.  In addition, depending on the\ntype of the tunnels supported (for example,\nmanually configured or signaled, persistent or non-\npersistent, etc.), the following other groups\ndefined below are mandatory: mplsTunnelManualGroup\nand/or mplsTunnelSignaledGroup,\nmplsTunnelIsNotIntfcGroup and/or\nmplsTunnelIsIntfcGroup.")
mplsTunnelManualGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 166, 3, 3, 1, 2)).setObjects(*(("MPLS-TE-STD-MIB", "mplsTunnelSignallingProto"), ) )
if mibBuilder.loadTexts: mplsTunnelManualGroup.setDescription("Object(s) needed to implement manually configured\ntunnels.")
mplsTunnelSignaledGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 166, 3, 3, 1, 3)).setObjects(*(("MPLS-TE-STD-MIB", "mplsTunnelLocalProtectInUse"), ("MPLS-TE-STD-MIB", "mplsTunnelHopPathOptionName"), ("MPLS-TE-STD-MIB", "mplsTunnelHoldingPrio"), ("MPLS-TE-STD-MIB", "mplsTunnelHopIpPrefixLen"), ("MPLS-TE-STD-MIB", "mplsTunnelHopType"), ("MPLS-TE-STD-MIB", "mplsTunnelHopAddrUnnum"), ("MPLS-TE-STD-MIB", "mplsTunnelHopListIndexNext"), ("MPLS-TE-STD-MIB", "mplsTunnelSignallingProto"), ("MPLS-TE-STD-MIB", "mplsTunnelHopStorageType"), ("MPLS-TE-STD-MIB", "mplsTunnelHopRowStatus"), ("MPLS-TE-STD-MIB", "mplsTunnelSetupPrio"), ("MPLS-TE-STD-MIB", "mplsTunnelHopAsNumber"), ("MPLS-TE-STD-MIB", "mplsTunnelHopIpAddr"), ("MPLS-TE-STD-MIB", "mplsTunnelHopAddrType"), ("MPLS-TE-STD-MIB", "mplsTunnelSessionAttributes"), ("MPLS-TE-STD-MIB", "mplsTunnelHopLspId"), ("MPLS-TE-STD-MIB", "mplsTunnelHopInclude"), ("MPLS-TE-STD-MIB", "mplsTunnelHopEntryPathComp"), ) )
if mibBuilder.loadTexts: mplsTunnelSignaledGroup.setDescription("Objects needed to implement signaled tunnels.")
mplsTunnelScalarGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 166, 3, 3, 1, 4)).setObjects(*(("MPLS-TE-STD-MIB", "mplsTunnelNotificationMaxRate"), ("MPLS-TE-STD-MIB", "mplsTunnelMaxHops"), ("MPLS-TE-STD-MIB", "mplsTunnelConfigured"), ("MPLS-TE-STD-MIB", "mplsTunnelActive"), ("MPLS-TE-STD-MIB", "mplsTunnelTEDistProto"), ) )
if mibBuilder.loadTexts: mplsTunnelScalarGroup.setDescription("Scalar object needed to implement MPLS tunnels.")
mplsTunnelIsIntfcGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 166, 3, 3, 1, 5)).setObjects(*(("MPLS-TE-STD-MIB", "mplsTunnelIsIf"), ) )
if mibBuilder.loadTexts: mplsTunnelIsIntfcGroup.setDescription("Objects needed to implement tunnels that are\ninterfaces.")
mplsTunnelIsNotIntfcGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 166, 3, 3, 1, 6)).setObjects(*(("MPLS-TE-STD-MIB", "mplsTunnelIsIf"), ) )
if mibBuilder.loadTexts: mplsTunnelIsNotIntfcGroup.setDescription("Objects needed to implement tunnels that are not\ninterfaces.")
mplsTunnelCRLDPResOptionalGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 166, 3, 3, 1, 7)).setObjects(*(("MPLS-TE-STD-MIB", "mplsTunnelCRLDPResFrequency"), ("MPLS-TE-STD-MIB", "mplsTunnelCRLDPResMeanBurstSize"), ("MPLS-TE-STD-MIB", "mplsTunnelCRLDPResStorageType"), ("MPLS-TE-STD-MIB", "mplsTunnelCRLDPResFlags"), ("MPLS-TE-STD-MIB", "mplsTunnelCRLDPResRowStatus"), ("MPLS-TE-STD-MIB", "mplsTunnelCRLDPResExBurstSize"), ("MPLS-TE-STD-MIB", "mplsTunnelCRLDPResWeight"), ) )
if mibBuilder.loadTexts: mplsTunnelCRLDPResOptionalGroup.setDescription("Set of objects implemented for resources applicable\nfor tunnels signaled using CR-LDP.")
mplsTeNotificationGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 10, 166, 3, 3, 1, 8)).setObjects(*(("MPLS-TE-STD-MIB", "mplsTunnelDown"), ("MPLS-TE-STD-MIB", "mplsTunnelUp"), ("MPLS-TE-STD-MIB", "mplsTunnelRerouted"), ("MPLS-TE-STD-MIB", "mplsTunnelReoptimized"), ) )
if mibBuilder.loadTexts: mplsTeNotificationGroup.setDescription("Set of notifications implemented in this module.\nNone is mandatory.")

# Compliances

mplsTeModuleFullCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 166, 3, 3, 2, 1)).setObjects(*(("MPLS-TE-STD-MIB", "mplsTunnelManualGroup"), ("MPLS-TE-STD-MIB", "mplsTunnelScalarGroup"), ("MPLS-TE-STD-MIB", "mplsTunnelIsNotIntfcGroup"), ("IF-MIB", "ifGeneralInformationGroup"), ("MPLS-TE-STD-MIB", "mplsTunnelIsIntfcGroup"), ("MPLS-TE-STD-MIB", "mplsTunnelGroup"), ("MPLS-TE-STD-MIB", "mplsTunnelSignaledGroup"), ("MPLS-TE-STD-MIB", "mplsTunnelCRLDPResOptionalGroup"), ("MPLS-TE-STD-MIB", "mplsTeNotificationGroup"), ("IF-MIB", "ifCounterDiscontinuityGroup"), ) )
if mibBuilder.loadTexts: mplsTeModuleFullCompliance.setDescription("Compliance statement for agents that provide full\nsupport the MPLS-TE-STD-MIB module.")
mplsTeModuleReadOnlyCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 166, 3, 3, 2, 2)).setObjects(*(("MPLS-TE-STD-MIB", "mplsTunnelManualGroup"), ("MPLS-TE-STD-MIB", "mplsTunnelScalarGroup"), ("MPLS-TE-STD-MIB", "mplsTunnelIsNotIntfcGroup"), ("MPLS-TE-STD-MIB", "mplsTunnelIsIntfcGroup"), ("MPLS-TE-STD-MIB", "mplsTunnelGroup"), ("MPLS-TE-STD-MIB", "mplsTunnelSignaledGroup"), ("MPLS-TE-STD-MIB", "mplsTeNotificationGroup"), ("MPLS-TE-STD-MIB", "mplsTunnelCRLDPResOptionalGroup"), ) )
if mibBuilder.loadTexts: mplsTeModuleReadOnlyCompliance.setDescription("Compliance requirement for implementations that only\nprovide read-only support for MPLS-TE-STD-MIB.\nSuch devices can then be monitored but cannot be\nconfigured using this MIB modules.")

# Exports

# Module identity
mibBuilder.exportSymbols("MPLS-TE-STD-MIB", PYSNMP_MODULE_ID=mplsTeStdMIB)

# Objects
mibBuilder.exportSymbols("MPLS-TE-STD-MIB", mplsTeStdMIB=mplsTeStdMIB, mplsTeNotifications=mplsTeNotifications, mplsTeScalars=mplsTeScalars, mplsTunnelConfigured=mplsTunnelConfigured, mplsTunnelActive=mplsTunnelActive, mplsTunnelTEDistProto=mplsTunnelTEDistProto, mplsTunnelMaxHops=mplsTunnelMaxHops, mplsTunnelNotificationMaxRate=mplsTunnelNotificationMaxRate, mplsTeObjects=mplsTeObjects, mplsTunnelIndexNext=mplsTunnelIndexNext, mplsTunnelTable=mplsTunnelTable, mplsTunnelEntry=mplsTunnelEntry, mplsTunnelIndex=mplsTunnelIndex, mplsTunnelInstance=mplsTunnelInstance, mplsTunnelIngressLSRId=mplsTunnelIngressLSRId, mplsTunnelEgressLSRId=mplsTunnelEgressLSRId, mplsTunnelName=mplsTunnelName, mplsTunnelDescr=mplsTunnelDescr, mplsTunnelIsIf=mplsTunnelIsIf, mplsTunnelIfIndex=mplsTunnelIfIndex, mplsTunnelOwner=mplsTunnelOwner, mplsTunnelRole=mplsTunnelRole, mplsTunnelXCPointer=mplsTunnelXCPointer, mplsTunnelSignallingProto=mplsTunnelSignallingProto, mplsTunnelSetupPrio=mplsTunnelSetupPrio, mplsTunnelHoldingPrio=mplsTunnelHoldingPrio, mplsTunnelSessionAttributes=mplsTunnelSessionAttributes, mplsTunnelLocalProtectInUse=mplsTunnelLocalProtectInUse, mplsTunnelResourcePointer=mplsTunnelResourcePointer, mplsTunnelPrimaryInstance=mplsTunnelPrimaryInstance, mplsTunnelInstancePriority=mplsTunnelInstancePriority, mplsTunnelHopTableIndex=mplsTunnelHopTableIndex, mplsTunnelPathInUse=mplsTunnelPathInUse, mplsTunnelARHopTableIndex=mplsTunnelARHopTableIndex, mplsTunnelCHopTableIndex=mplsTunnelCHopTableIndex, mplsTunnelIncludeAnyAffinity=mplsTunnelIncludeAnyAffinity, mplsTunnelIncludeAllAffinity=mplsTunnelIncludeAllAffinity, mplsTunnelExcludeAnyAffinity=mplsTunnelExcludeAnyAffinity, mplsTunnelTotalUpTime=mplsTunnelTotalUpTime, mplsTunnelInstanceUpTime=mplsTunnelInstanceUpTime, mplsTunnelPrimaryUpTime=mplsTunnelPrimaryUpTime, mplsTunnelPathChanges=mplsTunnelPathChanges, mplsTunnelLastPathChange=mplsTunnelLastPathChange, mplsTunnelCreationTime=mplsTunnelCreationTime, mplsTunnelStateTransitions=mplsTunnelStateTransitions, mplsTunnelAdminStatus=mplsTunnelAdminStatus, mplsTunnelOperStatus=mplsTunnelOperStatus, mplsTunnelRowStatus=mplsTunnelRowStatus, mplsTunnelStorageType=mplsTunnelStorageType, mplsTunnelHopListIndexNext=mplsTunnelHopListIndexNext, mplsTunnelHopTable=mplsTunnelHopTable, mplsTunnelHopEntry=mplsTunnelHopEntry, mplsTunnelHopListIndex=mplsTunnelHopListIndex, mplsTunnelHopPathOptionIndex=mplsTunnelHopPathOptionIndex, mplsTunnelHopIndex=mplsTunnelHopIndex, mplsTunnelHopAddrType=mplsTunnelHopAddrType, mplsTunnelHopIpAddr=mplsTunnelHopIpAddr, mplsTunnelHopIpPrefixLen=mplsTunnelHopIpPrefixLen, mplsTunnelHopAsNumber=mplsTunnelHopAsNumber, mplsTunnelHopAddrUnnum=mplsTunnelHopAddrUnnum, mplsTunnelHopLspId=mplsTunnelHopLspId, mplsTunnelHopType=mplsTunnelHopType, mplsTunnelHopInclude=mplsTunnelHopInclude, mplsTunnelHopPathOptionName=mplsTunnelHopPathOptionName, mplsTunnelHopEntryPathComp=mplsTunnelHopEntryPathComp, mplsTunnelHopRowStatus=mplsTunnelHopRowStatus, mplsTunnelHopStorageType=mplsTunnelHopStorageType, mplsTunnelResourceIndexNext=mplsTunnelResourceIndexNext, mplsTunnelResourceTable=mplsTunnelResourceTable, mplsTunnelResourceEntry=mplsTunnelResourceEntry, mplsTunnelResourceIndex=mplsTunnelResourceIndex, mplsTunnelResourceMaxRate=mplsTunnelResourceMaxRate, mplsTunnelResourceMeanRate=mplsTunnelResourceMeanRate, mplsTunnelResourceMaxBurstSize=mplsTunnelResourceMaxBurstSize, mplsTunnelResourceMeanBurstSize=mplsTunnelResourceMeanBurstSize, mplsTunnelResourceExBurstSize=mplsTunnelResourceExBurstSize, mplsTunnelResourceFrequency=mplsTunnelResourceFrequency, mplsTunnelResourceWeight=mplsTunnelResourceWeight, mplsTunnelResourceRowStatus=mplsTunnelResourceRowStatus, mplsTunnelResourceStorageType=mplsTunnelResourceStorageType, mplsTunnelARHopTable=mplsTunnelARHopTable, mplsTunnelARHopEntry=mplsTunnelARHopEntry, mplsTunnelARHopListIndex=mplsTunnelARHopListIndex, mplsTunnelARHopIndex=mplsTunnelARHopIndex, mplsTunnelARHopAddrType=mplsTunnelARHopAddrType, mplsTunnelARHopIpAddr=mplsTunnelARHopIpAddr, mplsTunnelARHopAddrUnnum=mplsTunnelARHopAddrUnnum, mplsTunnelARHopLspId=mplsTunnelARHopLspId, mplsTunnelCHopTable=mplsTunnelCHopTable, mplsTunnelCHopEntry=mplsTunnelCHopEntry, mplsTunnelCHopListIndex=mplsTunnelCHopListIndex, mplsTunnelCHopIndex=mplsTunnelCHopIndex, mplsTunnelCHopAddrType=mplsTunnelCHopAddrType, mplsTunnelCHopIpAddr=mplsTunnelCHopIpAddr, mplsTunnelCHopIpPrefixLen=mplsTunnelCHopIpPrefixLen, mplsTunnelCHopAsNumber=mplsTunnelCHopAsNumber, mplsTunnelCHopAddrUnnum=mplsTunnelCHopAddrUnnum, mplsTunnelCHopLspId=mplsTunnelCHopLspId, mplsTunnelCHopType=mplsTunnelCHopType, mplsTunnelPerfTable=mplsTunnelPerfTable, mplsTunnelPerfEntry=mplsTunnelPerfEntry, mplsTunnelPerfPackets=mplsTunnelPerfPackets, mplsTunnelPerfHCPackets=mplsTunnelPerfHCPackets, mplsTunnelPerfErrors=mplsTunnelPerfErrors, mplsTunnelPerfBytes=mplsTunnelPerfBytes, mplsTunnelPerfHCBytes=mplsTunnelPerfHCBytes, mplsTunnelCRLDPResTable=mplsTunnelCRLDPResTable, mplsTunnelCRLDPResEntry=mplsTunnelCRLDPResEntry, mplsTunnelCRLDPResMeanBurstSize=mplsTunnelCRLDPResMeanBurstSize, mplsTunnelCRLDPResExBurstSize=mplsTunnelCRLDPResExBurstSize, mplsTunnelCRLDPResFrequency=mplsTunnelCRLDPResFrequency, mplsTunnelCRLDPResWeight=mplsTunnelCRLDPResWeight, mplsTunnelCRLDPResFlags=mplsTunnelCRLDPResFlags, mplsTunnelCRLDPResRowStatus=mplsTunnelCRLDPResRowStatus, mplsTunnelCRLDPResStorageType=mplsTunnelCRLDPResStorageType, mplsTunnelNotificationEnable=mplsTunnelNotificationEnable, mplsTeConformance=mplsTeConformance, mplsTeGroups=mplsTeGroups, mplsTeCompliances=mplsTeCompliances)

# Notifications
mibBuilder.exportSymbols("MPLS-TE-STD-MIB", mplsTunnelUp=mplsTunnelUp, mplsTunnelDown=mplsTunnelDown, mplsTunnelRerouted=mplsTunnelRerouted, mplsTunnelReoptimized=mplsTunnelReoptimized)

# Groups
mibBuilder.exportSymbols("MPLS-TE-STD-MIB", mplsTunnelGroup=mplsTunnelGroup, mplsTunnelManualGroup=mplsTunnelManualGroup, mplsTunnelSignaledGroup=mplsTunnelSignaledGroup, mplsTunnelScalarGroup=mplsTunnelScalarGroup, mplsTunnelIsIntfcGroup=mplsTunnelIsIntfcGroup, mplsTunnelIsNotIntfcGroup=mplsTunnelIsNotIntfcGroup, mplsTunnelCRLDPResOptionalGroup=mplsTunnelCRLDPResOptionalGroup, mplsTeNotificationGroup=mplsTeNotificationGroup)

# Compliances
mibBuilder.exportSymbols("MPLS-TE-STD-MIB", mplsTeModuleFullCompliance=mplsTeModuleFullCompliance, mplsTeModuleReadOnlyCompliance=mplsTeModuleReadOnlyCompliance)
