# PySNMP SMI module. Autogenerated from smidump -f python PKTC-IETF-SIG-MIB
# by libsmi2pysnmp-0.1.3 at Mon Apr  2 20:39:27 2012,
# Python version sys.version_info(major=2, minor=7, micro=2, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( Dscp, ) = mibBuilder.importSymbols("DIFFSERV-DSCP-TC", "Dscp")
( ifIndex, ) = mibBuilder.importSymbols("IF-MIB", "ifIndex")
( InetAddress, InetAddressType, InetPortNumber, ) = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType", "InetPortNumber")
( SnmpAdminString, ) = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
( ModuleCompliance, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup")
( Bits, Integer32, Integer32, ModuleIdentity, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, Unsigned32, mib_2, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Integer32", "Integer32", "ModuleIdentity", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "Unsigned32", "mib-2")
( RowStatus, TextualConvention, TruthValue, ) = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "TextualConvention", "TruthValue")

# Types

class DtmfCode(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(10,14,13,12,11,15,9,8,3,2,1,0,7,6,5,4,)
    namedValues = NamedValues(("dtmfcode0", 0), ("dtmfcode1", 1), ("dtmfcodeStar", 10), ("dtmfcodeHash", 11), ("dtmfcodeA", 12), ("dtmfcodeB", 13), ("dtmfcodeC", 14), ("dtmfcodeD", 15), ("dtmfcode2", 2), ("dtmfcode3", 3), ("dtmfcode4", 4), ("dtmfcode5", 5), ("dtmfcode6", 6), ("dtmfcode7", 7), ("dtmfcode8", 8), ("dtmfcode9", 9), )
    
class PktcCodecType(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(3,7,4,2,11,6,5,8,13,1,12,10,9,14,)
    namedValues = NamedValues(("other", 1), ("g726at16", 10), ("g726at24", 11), ("g726at40", 12), ("ilbc", 13), ("bv16", 14), ("unknown", 2), ("g729", 3), ("reserved", 4), ("g729E", 5), ("pcmu", 6), ("g726at32", 7), ("g728", 8), ("pcma", 9), )
    
class PktcRingCadence(OctetString):
    subtypeSpec = OctetString.subtypeSpec+ValueSizeConstraint(4,36)
    
class PktcSigType(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(2,1,)
    namedValues = NamedValues(("other", 1), ("ncs", 2), )
    
class PktcSubscriberSideSigProtocol(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(1,2,)
    namedValues = NamedValues(("fsk", 1), ("dtmf", 2), )
    
class TenthdBm(TextualConvention, Integer32):
    displayHint = "d-1"
    

# Objects

pktcIetfSigMib = ModuleIdentity((1, 3, 6, 1, 2, 1, 169)).setRevisions(("2007-12-18 00:00",))
if mibBuilder.loadTexts: pktcIetfSigMib.setOrganization("IETF IPCDN Working Group")
if mibBuilder.loadTexts: pktcIetfSigMib.setContactInfo("Sumanth Channabasappa\nCable Television Laboratories, Inc.\n858 Coal Creek Circle,\nLouisville, CO 80027, USA\nPhone: +1 303-661-3307\nEmail: Sumanth@cablelabs.com\n\nGordon Beacham\nMotorola, Inc.\n6450 Sequence Drive, Bldg. 1\nSan Diego, CA 92121, USA\nPhone: +1 858-404-2334\nEmail: gordon.beacham@motorola.com\n\nSatish Kumar Mudugere Eswaraiah\nTexas Instruments India (P) Ltd.,\nGolf view, Wind Tunnel Road\nMurugesh Palya\nBangalore 560 017, INDIA\nPhone:   +91 80 5269451\nEmail:  satish.kumar@ti.com\n\nIETF IPCDN Working Group\nGeneral Discussion: ipcdn@ietf.org\nSubscribe: http://www.ietf.org/mailman/listinfo/ipcdn\nArchive: ftp://ftp.ietf.org/ietf-mail-archive/ipcdn\nCo-Chair: Jean-Francois Mule, jf.mule@cablelabs.com\nCo-Chair: Richard Woundy, Richard_Woundy@cable.comcast.com")
if mibBuilder.loadTexts: pktcIetfSigMib.setDescription("This MIB module supplies the basic management\nobjects for the PacketCable and IPCablecom Signaling\nprotocols.  This version of the MIB includes\ncommon signaling and Network Call Signaling\n\n\n\n(NCS)-related signaling objects.\n\nCopyright (C) The IETF Trust (2008).  This version of\nthis MIB module is part of RFC 5098; see the RFC itself for\nfull legal notices.")
pktcSigNotification = MibIdentifier((1, 3, 6, 1, 2, 1, 169, 0))
pktcSigMibObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 169, 1))
pktcSigDevObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 169, 1, 1))
pktcSigDevCodecTable = MibTable((1, 3, 6, 1, 2, 1, 169, 1, 1, 1))
if mibBuilder.loadTexts: pktcSigDevCodecTable.setDescription(" This table describes the MTA-supported codec types.  An MTA\nMUST populate this table with all possible combinations of\ncodecs it supports for simultaneous operation.  For example,\nan MTA with two endpoints may be designed with a particular\nDigital Signal Processing (DSP) and memory architecture that\nallows it to support the following fixed combinations of\ncodecs for simultaneous operation:\n\nCodec Type     Maximum Number of Simultaneous Codecs\nPCMA                             3\n\nPCMA                             2\nPCMU                             1\n\nPCMA                             1\n\nPCMU                             2\n\nPCMU                             3\n\nPCMA                             1\nG729                             1\n\nG729                             2\n\nPCMU                             1\nG729                             1\n\nBased on this example, the entries in the codec table\nwould be:\n\n  pktcSigDev        pktcSigDev        pktcSigDev\nCodecComboIndex     CodecType          CodecMax\n       1               pcma                3\n       2               pcma                2\n       2               pcmu                1\n\n\n\n       3               pcma                1\n       3               pcmu                2\n       4               pcmu                3\n       5               pcma                1\n       5               g729                1\n       6               g729                2\n       7               pcmu                1\n       7               g729                1\n\nAn operator querying this table is able to determine all\npossible codec combinations the MTA is capable of\nsimultaneously supporting.\n\nThis table MUST NOT include non-voice codecs.")
pktcSigDevCodecEntry = MibTableRow((1, 3, 6, 1, 2, 1, 169, 1, 1, 1, 1)).setIndexNames((0, "PKTC-IETF-SIG-MIB", "pktcSigDevCodecComboIndex"), (0, "PKTC-IETF-SIG-MIB", "pktcSigDevCodecType"))
if mibBuilder.loadTexts: pktcSigDevCodecEntry.setDescription("Each entry represents the maximum number of active\nconnections with a particular codec the MTA is capable of\nsupporting.  Each row is indexed by a composite key\nconsisting of a number enumerating the particular codec\ncombination and the codec type.")
pktcSigDevCodecComboIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: pktcSigDevCodecComboIndex.setDescription(" The index value that enumerates a particular codec\ncombination in the pktcSigDevCodecTable.")
pktcSigDevCodecType = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 1, 1, 2), PktcCodecType()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: pktcSigDevCodecType.setDescription(" A codec type supported by this MTA.")
pktcSigDevCodecMax = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 1, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigDevCodecMax.setDescription(" The maximum number of simultaneous sessions of a\nparticular codec that the MTA can support.")
pktcSigDevEchoCancellation = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigDevEchoCancellation.setDescription(" This object specifies if the device is capable of echo\ncancellation.  The MTA MUST set this MIB object to a\nvalue of true(1) if it is capable of echo\ncancellation, and a value of false(2) if not.")
pktcSigDevSilenceSuppression = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigDevSilenceSuppression.setDescription(" This object specifies if the device is capable of\nsilence suppression (as a result of Voice Activity\nDetection).  The MTA MUST set this MIB object to a\nvalue of true(1) if it is capable of silence\nsuppression, and a value of false(2) if not.")
pktcSigDevCidSigProtocol = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 4), PktcSubscriberSideSigProtocol().clone('fsk')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevCidSigProtocol.setDescription("This object is used to configure the subscriber-line\nprotocol used for signaling on-hook caller id information.\n\n\n\nDifferent countries define different caller id signaling\nprotocols to support caller identification.\n\nSetting this object at a value fsk(1) sets the subscriber\nline protocol to be Frequency Shift Keying (FSK).\n\nSetting this object at a value dtmf(2) sets the subscriber\nline protocol to be Dual-Tone Multi-Frequency (DTMF).\n\nThe value of this MIB object MUST NOT persist across MTA\nreboots.")
pktcSigDevR0Cadence = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 5), PktcRingCadence()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevR0Cadence.setDescription(" This object specifies ring cadence 0 (a user-defined\nfield).\n\nThe value of this MIB object MUST NOT persist across MTA\nreboots.")
pktcSigDevR1Cadence = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 6), PktcRingCadence()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevR1Cadence.setDescription(" This object specifies ring cadence 1 (a user-defined\nfield).\n\nThe value of this MIB object MUST NOT persist across MTA\nreboots.")
pktcSigDevR2Cadence = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 7), PktcRingCadence()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevR2Cadence.setDescription(" This object specifies ring cadence 2 (a user-defined\nfield).\n\n\n\n\nThe value of this MIB object MUST NOT persist across MTA\nreboots.")
pktcSigDevR3Cadence = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 8), PktcRingCadence()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevR3Cadence.setDescription(" This object specifies ring cadence 3 (a user-defined\nfield).\n\nThe value of this MIB object MUST NOT persist across MTA\nreboots.")
pktcSigDevR4Cadence = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 9), PktcRingCadence()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevR4Cadence.setDescription(" This object specifies ring cadence 4 (a user-defined\nfield).\n\nThe value of this MIB object MUST NOT persist across MTA\nreboots.")
pktcSigDevR5Cadence = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 10), PktcRingCadence()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevR5Cadence.setDescription(" This object specifies ring cadence 5 (a user-defined\nfield).\n\nThe value of this MIB object MUST NOT persist across MTA\nreboots.")
pktcSigDevR6Cadence = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 11), PktcRingCadence()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevR6Cadence.setDescription(" This object specifies ring cadence 6 (a user-defined\nfield).\n\n\n\n\nThe value of this MIB object MUST NOT persist across MTA\nreboots.")
pktcSigDevR7Cadence = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 12), PktcRingCadence()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevR7Cadence.setDescription(" This object specifies ring cadence 7 (a user-defined\nfield).\n\nThe value of this MIB object MUST NOT persist across MTA\nreboots.")
pktcSigDevRgCadence = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 13), PktcRingCadence()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevRgCadence.setDescription(" This object specifies ring cadence rg (a user-defined\nfield).\n\nThe value of this MIB object MUST NOT persist across MTA\nreboots.")
pktcSigDevRsCadence = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 14), PktcRingCadence()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevRsCadence.setDescription(" This object specifies ring cadence rs (a user-defined\nfield).  The MTA MUST reject any attempt to make this object\nrepeatable.\n\nThe value of this MIB object MUST NOT persist across MTA\nreboots.")
pktcSigDefCallSigDscp = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 15), Dscp().clone('0')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDefCallSigDscp.setDescription(" The default value used in the IP header for setting the\nDifferentiated Services Code Point (DSCP) value for call\n\n\n\nsignaling.\n\nThe value of this MIB object MUST NOT persist across MTA\nreboots.")
pktcSigDefMediaStreamDscp = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 16), Dscp().clone('0')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDefMediaStreamDscp.setDescription(" This object contains the default value used in the IP\nheader for setting the Differentiated Services Code Point\n(DSCP) value for media stream packets.  The MTA MUST NOT\nupdate this object with the value supplied by the CMS in\nthe NCS messages (if present).  Any currently active\nconnections are not affected by updates to this object.\nWhen the value of this object is updated by SNMP, the MTA\nMUST use the new value as a default starting only from\nnew connections.\n\nThe value of this MIB object MUST NOT persist across MTA\nreboots.")
pktcSigCapabilityTable = MibTable((1, 3, 6, 1, 2, 1, 169, 1, 1, 17))
if mibBuilder.loadTexts: pktcSigCapabilityTable.setDescription(" This table describes the signaling types supported by this\nMTA.")
pktcSigCapabilityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 169, 1, 1, 17, 1)).setIndexNames((0, "PKTC-IETF-SIG-MIB", "pktcSigCapabilityIndex"))
if mibBuilder.loadTexts: pktcSigCapabilityEntry.setDescription(" Entries in pktcMtaDevSigCapabilityTable - list of\nsupported signaling types, versions, and vendor extensions\n\n\n\nfor this MTA.  Each entry in the list provides for one\nsignaling type and version combination.  If the device\nsupports multiple versions of the same signaling type, it\nwill require multiple entries.")
pktcSigCapabilityIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 17, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: pktcSigCapabilityIndex.setDescription(" The index value that uniquely identifies an entry in the\npktcSigCapabilityTable.")
pktcSigCapabilityType = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 17, 1, 2), PktcSigType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigCapabilityType.setDescription(" This object identifies the type of signaling used.  This\nvalue has to be associated with a single signaling\nversion.")
pktcSigCapabilityVersion = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 17, 1, 3), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigCapabilityVersion.setDescription(" Provides the version of the signaling type - reference\npktcSigCapabilityType.  Examples would be 1.0 or 2.33 etc.")
pktcSigCapabilityVendorExt = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 17, 1, 4), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigCapabilityVendorExt.setDescription(" The vendor extension allows vendors to provide a list of\n\n\n\nadditional capabilities.\n\nThe syntax for this MIB object in ABNF ([RFC5234]) is\nspecified to be zero or more occurrences of vendor\nextensions, as follows:\n\n pktcSigCapabilityVendorExt  = *(vendor-extension)\n vendor-extension = (ext symbol alphanum) DQUOTE ; DQUOTE\n ext      = DQUOTE %x58 DQUOTE\n symbol   = (DQUOTE %x2D DQUOTE)/(DQUOTE %x2D DQUOTE)\n alphanum = 1*6(ALPHA/DIGIT)")
pktcSigDefNcsReceiveUdpPort = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 18), InetPortNumber().subtype(subtypeSpec=ValueRangeConstraint(1025, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigDefNcsReceiveUdpPort.setDescription(" This object contains the MTA User Datagram Protocol (UDP)\nreceive port that is being used for NCS call signaling.\nThis object should only be changed by the configuration\nfile.\n\nUnless changed via configuration, this MIB object MUST\nreflect a value of '2427'.")
pktcSigPowerRingFrequency = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 19), Integer().subtype(subtypeSpec=SingleValueConstraint(6,3,5,7,9,2,1,8,4,)).subtype(namedValues=NamedValues(("f20Hz", 1), ("f25Hz", 2), ("f33Point33Hz", 3), ("f50Hz", 4), ("f15Hz", 5), ("f16Hz", 6), ("f22Hz", 7), ("f23Hz", 8), ("f45Hz", 9), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigPowerRingFrequency.setDescription(" This object must only be provided via the configuration\nfile during the provisioning process.  The power ring\n\n\n\nfrequency is the frequency at which the sinusoidal voltage\nmust travel down the twisted pair to make terminal\nequipment ring.  Different countries define different\nelectrical characteristics to make terminal equipment\nring.\n\nThe f20Hz setting corresponds to a power ring frequency\nof 20 Hertz.  The f25Hz setting corresponds to a power ring\nfrequency of 25 Hertz.  The f33Point33Hz setting\ncorresponds to a power ring frequency of 33.33 Hertz.  The\nf50Hz setting corresponds to a power ring frequency of 50\nHertz.  The f15Hz setting corresponds to a power ring\nfrequency of 15 Hertz.  The f16Hz setting corresponds to a\npower ring frequency of 16 Hertz.  The f22Hz setting\ncorresponds to a power ring frequency of 22 Hertz.  The\nf23Hz setting corresponds to a power ring frequency of 23\nHertz.  The f45Hz setting corresponds to a power ring\nfrequency of 45 Hertz.")
pktcSigPulseSignalTable = MibTable((1, 3, 6, 1, 2, 1, 169, 1, 1, 20))
if mibBuilder.loadTexts: pktcSigPulseSignalTable.setDescription(" The Pulse signal table defines the pulse signal operation.\nThere are nine types of international pulse signals,\nwith each signal having a set of provisionable parameters.\nThe values of the MIB objects in this table take effect\nonly if these parameters are not defined via signaling, in\nwhich case, the latter determines the values of the\nparameters.  The MIB objects in this table do not persist\nacross MTA reboots.")
pktcSigPulseSignalEntry = MibTableRow((1, 3, 6, 1, 2, 1, 169, 1, 1, 20, 1)).setIndexNames((0, "PKTC-IETF-SIG-MIB", "pktcSigPulseSignalType"))
if mibBuilder.loadTexts: pktcSigPulseSignalEntry.setDescription(" This object defines the set of parameters associated with\neach particular value of pktcSigPulseSignalType.  Each\nentry in the pktcSigPulseSignalTable is indexed by the\npktcSigPulseSignalType object.\n\n\n\nThe conceptual rows MUST NOT persist across MTA reboots.")
pktcSigPulseSignalType = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 20, 1, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(1,6,9,8,2,7,5,3,4,)).subtype(namedValues=NamedValues(("initialRing", 1), ("pulseLoopClose", 2), ("pulseLoopOpen", 3), ("enableMeterPulse", 4), ("meterPulseBurst", 5), ("pulseNoBattery", 6), ("pulseNormalPolarity", 7), ("pulseReducedBattery", 8), ("pulseReversePolarity", 9), ))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: pktcSigPulseSignalType.setDescription("There are nine types of international pulse signals.  These\nsignals are defined as follows:\ninitial ring\npulse loop close\npulse loop open\nenable meter pulse\nmeter pulse burst\npulse no battery\npulse normal polarity\npulse reduced battery\npulse reverse polarity")
pktcSigPulseSignalFrequency = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 20, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(3,2,1,)).subtype(namedValues=NamedValues(("twentyfive", 1), ("twelvethousand", 2), ("sixteenthousand", 3), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigPulseSignalFrequency.setDescription(" This object is only applicable to the initialRing,\nenableMeterPulse, and meterPulseBurst signal types.  This\nobject identifies the frequency of the generated signal.\nThe following table defines the default values for this\nobject depending on signal type:\n\npktcSigPulseSignalType     Default\ninitialRing                25\nenableMeterPulse           16000\nmeterPulseBurst            16000\n\nThe value of twentyfive MUST only be used for the\ninitialRing signal type.  The values of twelvethousand and\nsixteenthousand MUST only be used for enableMeterPulse and\nmeterPulseBurst signal types.  An attempt to set this\nobject while the value of pktcSigPulseSignalType is not\ninitialRing, enableMeterPulse, or meterPulseBurst will\nresult in an 'inconsistentValue' error.")
pktcSigPulseSignalDbLevel = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 20, 1, 3), TenthdBm().subtype(subtypeSpec=ValueRangeConstraint(-350, 0)).clone(-135)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigPulseSignalDbLevel.setDescription(" This object is only applicable to the enableMeterPulse and\nmeterPulseBurst signal types.  This is the decibel level\nfor each frequency at which tones could be generated at\nthe a and b terminals (TE connection point).  An attempt to\nset this object while the value of pktcSigPulseSignalType\nis not enableMeterPulse or meterPulseBurst will result in\nan 'inconsistentValue' error.")
pktcSigPulseSignalDuration = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 20, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigPulseSignalDuration.setDescription(" This object specifies the pulse duration for each\nsignal type.  In addition, the MTA must accept the values\nin the incremental steps specific for each signal type.\nThe following table defines the default values and the\nincremental steps for this object depending on the signal\ntype:\n\npktcSigPulseSignaltype  Default (ms)   Increment (ms)\ninitialRing                 200             50\npulseLoopClose              200             10\npulseLoopOpen               200             10\nenableMeterPulse            150             10\nmeterPulseBurst             150             10\npulseNoBattery              200             10\npulseNormalPolarity         200             10\npulseReducedBattery         200             10\npulseReversePolarity        200             10\n\nAn attempt to set this object to a value that does not\nfall on one of the increment boundaries, or on the wrong\nincrement boundary for the specific signal type, will\nresult in an 'inconsistentValue' error.")
pktcSigPulseSignalPulseInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 20, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigPulseSignalPulseInterval.setDescription(" This object specifies the repeat interval, or the period,\nfor each signal type.  In addition, the MTA must accept\nthe values in the incremental steps specific for each\nsignal type.  The following table defines the default\nvalues and the incremental steps for this object, depending\non the signal type:\n\npktcSigPulseSignaltype  Default (ms)   Increment (ms)\ninitialRing                 200             50\npulseLoopClose             1000             10\npulseLoopOpen              1000             10\n\n\n\nenableMeterPulse           1000             10\nmeterPulseBurst            1000             10\npulseNoBattery             1000             10\npulseNormalPolarity        1000             10\npulseReducedBattery        1000             10\npulseReversePolarity       1000             10\n\nAn attempt to set this object to a value that does not\nfall on one of the increment boundaries, or on the wrong\nincrement boundary for the specific signal type, will\nresult in an 'inconsistentValue' error.")
pktcSigPulseSignalRepeatCount = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 20, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigPulseSignalRepeatCount.setDescription(" This object specifies how many times to repeat a pulse.\nThis object is not used by the enableMeterPulse signal\ntype, and in that case, the value is irrelevant.  The\nfollowing table defines the default values and the valid\nranges for this object, depending on the signal type:\n\npktcSigPulseSignaltype  Default   Range\n\ninitialRing                1       1-5\npulseLoopClose             1       1-50\npulseLoopOpen              1       1-50\nenableMeterPulse      (any value)(but not used)\nmeterPulseBurst            1       1-50\npulseNoBattery             1       1-50\npulseNormalPolarity        1       1-50\npulseReducedBattery        1       1-50\npulseReversePolarity       1       1-50\n\nAn attempt to set this object to a value that does not\nfall within the range for the specific\nsignal type will result in an 'inconsistentValue' error.")
pktcSigDevCidMode = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 21), Integer().subtype(subtypeSpec=SingleValueConstraint(4,5,3,2,1,)).subtype(namedValues=NamedValues(("duringRingingETS", 1), ("dtAsETS", 2), ("rpAsETS", 3), ("lrAsETS", 4), ("lrETS", 5), )).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevCidMode.setDescription(" For on-hook caller id, pktcSigDevCidMode selects the method\nfor representing and signaling caller identification.  For\nthe duringRingingETS method, the Frequency Shift Keying\n(FSK) or the Dual-Tone Multi-Frequency (DTMF) containing\nthe caller identification information is sent between the\nfirst and second ring pattern.\n\nFor the dtAsETS,rpAsETS, lrAsETS and lrETS\nmethods, the FSK or DTMF containing the caller id\ninformation is sent before the first ring pattern.\n\nFor the dtAsETS method, the FSK or DTMF is sent after the\nDual Tone Alert Signal.  For the rpAsETS method, the FSK or\nDTMF is sent after a Ring Pulse.\n\nFor the lrAsETS method, the Line Reversal occurs first,\nthen the Dual Tone Alert Signal, and, finally, the FSK or\nDTMF is sent.\n\nFor the lrETS method, the Line Reversal occurs first,\nthen the FSK or DTMF is sent.\n\nThe value of this MIB object MUST NOT persist across MTA\nreboots.")
pktcSigDevCidAfterRing = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 22), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0,0),ValueRangeConstraint(50,2000),)).clone(550)).setMaxAccess("readwrite").setUnits("Milliseconds")
if mibBuilder.loadTexts: pktcSigDevCidAfterRing.setDescription(" This object specifies the delay between the end of first\nringing pattern and the start of the transmission of the\nFSK or DTMF containing the caller id information.  It is\nonly used when pktcSigDevCidMode is set to a value of\n'duringRingingETS'.\n\nThe following table defines the default values\nfor this MIB object, depending on the signal type\n\n\n\n(pktcSigDevCidMode), and MUST be followed:\n\nValue of pktcSigDevCidMode       Default value\n\nduringringingETS                 550 ms\ndtAsETS                          any value (not used)\nrpAsETS                          any value (not used)\nlrAsETS                          any value (not used)\nlrETS                            any value (not used)\n\nAn attempt to set this object while the value of\npktcSigDevCidMode is not duringringingETS will result in\nan 'inconsistentValue' error.\n\nThe value of this MIB object MUST NOT persist across MTA\nreboots.")
pktcSigDevCidAfterDTAS = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 23), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0,0),ValueRangeConstraint(45,500),)).clone(50)).setMaxAccess("readwrite").setUnits("Milliseconds")
if mibBuilder.loadTexts: pktcSigDevCidAfterDTAS.setDescription(" This object specifies the delay between the end of the\nDual Tone Alert Signal (DT-AS) and the start of the\ntransmission of the FSK or DTMF containing the caller id\ninformation.  This object is only used when\npktcSigDevCidMode is set to a value of 'dtAsETS' or\n'lrAsETS'.\n\nThe following table defines the default values\nfor this MIB object, depending on the signal type\n(pktcSigDevCidMode), and MUST be followed:\n\nValue of pktcSigDevCidMode       Default value\n\n\nduringringingETS                 any value (not used)\ndtAsETS                          50 ms\nrpAsETS                          any value (not used)\nlrAsETS                          50 ms\nlrETS                            any value (not used)\n\nAn attempt to set this object while the value of\n\n\n\npktcSigDevCidMode is not 'dtAsETS' or 'lrAsETS' will\nresult in an 'inconsistentValue' error.\n\nThe value of this MIB object MUST NOT persist across MTA\nreboots.")
pktcSigDevCidAfterRPAS = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 24), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0,0),ValueRangeConstraint(500,800),)).clone(650)).setMaxAccess("readwrite").setUnits("Milliseconds")
if mibBuilder.loadTexts: pktcSigDevCidAfterRPAS.setDescription(" This object specifies the delay between the end of the\nRing Pulse Alert Signal (RP-AS) and the start of the\ntransmission of the FSK or DTMF containing the caller id\ninformation.  This MIB object is only used when\npktcSigDevCidMode is set to a value of 'rpAsETS'.\nThe following table defines the default values\nfor this MIB object, depending on the signal type\n(pktcSigDevCidMode), and MUST be followed:\n\nValue of pktcSigDevCidMode       Default value\n\nduringringingETS                 any value  (not used)\ndtAsETS                          any value  (not used)\nrpAsETS                          650 ms\nlrAsETS                          any value  (not used)\nlrETS                            any value  (not used)\n\nAn attempt to set this object while the value of\npktcSigDevCidMode is not 'rpAsETS' will result in an\n'inconsistentValue' error.\n\nThe value of this MIB object MUST NOT persist across MTA\nreboots.")
pktcSigDevRingAfterCID = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 25), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0,0),ValueRangeConstraint(50,500),)).clone(250)).setMaxAccess("readwrite").setUnits("Milliseconds")
if mibBuilder.loadTexts: pktcSigDevRingAfterCID.setDescription(" This object specifies the delay between the end of the\ncomplete transmission of the FSK or DTMF containing the\ncaller id information and the start of the first ring\npattern.  It is only used when pktcSigDevCidMode is\nset to a value of 'dtAsETS', 'rpAsETS', 'lrAsETS' or\n'lrETS'.\n\nThe following table defines the default values\nfor this MIB object, depending on the signal type\n(pktcSigDevCidMode), and MUST be followed:\n\nValue of pktcSigDevCidMode       Default value\n\nduringringingETS                 any value  (not used)\ndtAsETS                          250 ms\nrpAsETS                          250 ms\nlrAsETS                          250 ms\nlrETS                            250 ms\n\nAn attempt to set this object while the value of\npktcSigDevCidMode is not 'dtAsETS', 'rpAsETS',\n'lrAsETS', or 'lrETS' will result in an 'inconsistent\nvalue' error.\n\nThe value of this MIB object MUST NOT persist across MTA\nreboots.")
pktcSigDevCidDTASAfterLR = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 26), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(50, 655)).clone(250)).setMaxAccess("readwrite").setUnits("Milliseconds")
if mibBuilder.loadTexts: pktcSigDevCidDTASAfterLR.setDescription(" This object specifies the delay between the end of the\nLine Reversal and the start of the Dual Tone Alert Signal\n(DT-AS).  This object is only used when pktcSigDevCidMode\nis set to a value of 'lrAsETS'.\n\nThe following table defines the default values\nfor this MIB object, depending on the signal type\n(pktcSigDevCidMode), and MUST be followed:\n\n\n\n\nValue of pktcSigDevCidMode       Default value\n\nduringringingETS                 any value  (not used)\ndtAsETS                          any value  (not used)\nrpAsETS                          any value  (not used)\nlrAsETS                          250 ms\nlrETS                            any value  (not used)\n\nAn attempt to set this object while the value of\npktcSigDevCidMode is not lrAsETS will result in an\n'inconsistentValue' error.\n\nThe value of this MIB object MUST NOT persist across MTA\nreboots.")
pktcSigDevVmwiMode = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 27), Integer().subtype(subtypeSpec=SingleValueConstraint(3,4,5,2,1,)).subtype(namedValues=NamedValues(("dtAsETS", 1), ("rpAsETS", 2), ("lrAsETS", 3), ("osi", 4), ("lrETS", 5), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevVmwiMode.setDescription(" For visual message waiting indicator (VMWI),\npktcSigDevVmwiMode selects the alerting signal method.  For\nthe dtAsETS, rpAsETS, lrAsETS, osi, and lrETS methods,\nthe FSK containing the VMWI information is sent after an\nalerting signal.\n\nFor the dtAsETS method, the FSK, or DTMF\nis sent after the Dual Tone Alert Signal.  For the rpAsETS\nmethod, the FSK or DTMF is sent after a Ring Pulse.\n\nFor the lrAsETS method, the Line Reversal occurs first,\nthen the Dual Tone Alert Signal, and, finally, the FSK or\nDTMF is sent.\n\nFor the OSI method, the FSK or DTMF is sent after the Open\nSwitching Interval.\n\n\n\n\nFor the lrETS method, the Line Reversal occurs first,\nthen the FSK or DTMF is sent.\n\nThe value of this MIB object MUST NOT persist across MTA\nreboots.")
pktcSigDevVmwiAfterDTAS = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 28), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0,0),ValueRangeConstraint(45,500),)).clone(50)).setMaxAccess("readwrite").setUnits("Milliseconds")
if mibBuilder.loadTexts: pktcSigDevVmwiAfterDTAS.setDescription(" This object specifies the delay between the end of the\nDual Tone Alert Signal (DT-AS) and the start of the\ntransmission of the FSK or DTMF containing the VMWI\ninformation.\n\nThis object is only used when pktcSigDevVmwiMode is\nset to a value of 'dtAsETS' or 'lrAsETS'.\n\nThe following table defines the default values\nfor this MIB object, depending on the signal type\n(pktcSigDevVmwiMode), and MUST be followed:\n\nValue of pktcSigDevVmwiMode       Default value\n\ndtAsETS                           50 ms\nrpAsETS                           any value  (not used)\nlrAsETS                           50 ms\nlrETS                             any value  (not used)\n\nAn attempt to set this object while the value of\npktcSigDevVmwiMode is not 'dtAsETS' or 'lrAsETS' will\nresult in an 'inconsistentValue' error.\n\nThe value of this MIB object MUST NOT persist across MTA\nreboots.")
pktcSigDevVmwiAfterRPAS = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 29), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0,0),ValueRangeConstraint(500,800),)).clone(650)).setMaxAccess("readwrite").setUnits("Milliseconds")
if mibBuilder.loadTexts: pktcSigDevVmwiAfterRPAS.setDescription(" This object specifies the delay between the end of the\nRing Pulse Alert Signal (RP-AS) and the start of the\ntransmission of the FSK or DTMF containing the VMWI\ninformation.\n\nThis object is only used when pktcSigDevVmwiMode is\nset to a value of 'rpAsETS'.\n\nThe following table defines the default values\nfor this MIB object, depending on the signal type\n(pktcSigDevVmwiMode), and MUST be followed:\n\nValue of pktcSigDevVmwiMode       Default value\n\ndtAsETS                           any value  (not used)\nrpAsETS                           650 ms\nlrAsETS                           any value  (not used)\nlrETS                             any value  (not used)\n\nAn attempt to set this object while the value of\npktcSigDevVmwiMode is not 'rpAsETS' will result in an\n'inconsistentValue' error.\n\nThe value of this MIB object MUST NOT persist across MTA\nreboots.")
pktcSigDevVmwiDTASAfterLR = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 30), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0,0),ValueRangeConstraint(50,655),)).clone(250)).setMaxAccess("readwrite").setUnits("Milliseconds")
if mibBuilder.loadTexts: pktcSigDevVmwiDTASAfterLR.setDescription(" This object specifies the delay between the end of the\nLine Reversal and the start of the Dual Tone Alert Signal\n(DT-AS) for VMWI information.  This object is only used\nwhen pktcSigDevVmwiMode is set to a value of 'lrAsETS'.\n\nThe following table defines the default values\nfor this MIB object, depending on the signal type\n(pktcSigDevVmwiMode), and MUST be followed:\n\n\n\n\nValue of pktcSigDevVmwiMode       Default value\n\ndtAsETS                           any value  (not used)\nrpAsETS                           any value  (not used)\nlrAsETS                           250 ms\nlrETS                             any value  (not used)\n\nAn attempt to set this object while the value of\npktcSigDevVmwiMode is not 'lrAsETS' will result in an\n'inconsistentValue' error.\n\nThe value of this MIB object MUST NOT persist across MTA\nreboots.")
pktcSigDevRingCadenceTable = MibTable((1, 3, 6, 1, 2, 1, 169, 1, 1, 31))
if mibBuilder.loadTexts: pktcSigDevRingCadenceTable.setDescription("Cadence rings are defined by the telco governing\nbody for each country.  The MTA must be able to support\nvarious ranges of cadence patterns and cadence periods.\nThe MTA will be able to support country-specific\nprovisioning of the cadence and idle period.  Each\ncadence pattern will be assigned a unique value ranging\nfrom 0-127 (inclusive) corresponding to the value of x,\nwhere x is the value sent in the cadence ringing (cr)\nsignal cr(x), requested per the appropriate NCS\nmessage, and defined in the E package.  The MTA will derive\nthe cadence periods from the ring cadence table entry, as\nprovisioned by the customer.  The MTA is allowed to provide\nappropriate default values for each of the ring cadences.\nThis table only needs to be supported when the MTA\nimplements the E package.")
pktcSigDevRingCadenceEntry = MibTableRow((1, 3, 6, 1, 2, 1, 169, 1, 1, 31, 1)).setIndexNames((0, "PKTC-IETF-SIG-MIB", "pktcSigDevRingCadenceIndex"))
if mibBuilder.loadTexts: pktcSigDevRingCadenceEntry.setDescription(" Each entry in this row corresponds to a ring cadence\nthat is being supported by the device.  The conceptual\nrows MUST NOT persist across MTA reboots.")
pktcSigDevRingCadenceIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 31, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: pktcSigDevRingCadenceIndex.setDescription(" A unique value ranging from 0 to 127 that corresponds to the\nvalue sent by the LE based on country-specific cadences,\none row per cadence cycle.  In any given system\nimplementation for a particular country, it is anticipated\nthat a small number of ring cadences will be in use.  Thus,\nthis table most likely will not be populated to its full\nsize.")
pktcSigDevRingCadence = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 31, 1, 2), PktcRingCadence()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevRingCadence.setDescription("This is the Ring Cadence.")
pktcSigDevToneTable = MibTable((1, 3, 6, 1, 2, 1, 169, 1, 1, 32))
if mibBuilder.loadTexts: pktcSigDevToneTable.setDescription(" The Tone Table defines the composition of tones and\nvarious tone operations.\n\nThe definition of the tones callWaiting1 through\ncallWaiting4 in this table MUST only contain the\naudible tone itself; the delay between tones or the value\nof the tone repeat count are not applicable for the call\nwaiting tones.\n\n\n\n\nThe delay between tones or the repeat count is controlled\nby the objects pktcSigEndPntConfigCallWaitingDelay and\npktcSigEndPntConfigCallWaitingMaxRep.  If the\npktcSigDevToneType is set to either of the values\ncallWaiting1, callWaiting2, callWaiting3, or callWaiting4,\nthen the value of the pktcSigDevToneWholeToneRepeatCount\nobject indicates that the particular frequency group is\napplicable, as a repeatable part of the tone, based on the\nvalue of the MIB object\npktcSigDevToneWholeToneRepeatCount.\n\nThe MTA MUST make sure that, after the provisioning\ncycle, the table is fully populated (i.e., for each\npossible index, an entry MUST be defined) using\nreasonable defaults for each row that was not defined\nby the provisioning information delivered via MTA\nConfiguration.\n\nThe frequency composition of each tone is defined by the\npktcSigDevMultiFreqToneTable.  For each tone type defined\nin pktcSigDevToneTable, the MTA MUST populate at least\none entry in the pktcSigDevMultiFreqToneTable.\n\nFor each particular value of pktcSigDevToneType, the\npktcSigDevToneTable table can define non-repeating and\nrepeating groups of the frequencies defined by the\npktcSigDevMultiFreqToneTable, such that each group is\nrepresented by the set of the consecutive rows\n(frequency group) in the pktcSigDevMultiFreqToneTable.\n\nObjects in this table do not persist across MTA reboots.\nFor tones with multiple frequencies refer to the MIB table\npktcSigDevMultiFreqToneTable.")
pktcSigDevToneEntry = MibTableRow((1, 3, 6, 1, 2, 1, 169, 1, 1, 32, 1)).setIndexNames((0, "PKTC-IETF-SIG-MIB", "pktcSigDevToneType"), (0, "PKTC-IETF-SIG-MIB", "pktcSigDevToneFreqGroup"))
if mibBuilder.loadTexts: pktcSigDevToneEntry.setDescription(" The different tone types that can be provisioned based on\ncountry-specific needs.\n\nEach entry contains the tone generation parameters for\na specific frequency group of the specific Tone Type.\n\n\n\nThe different parameters can be provisioned via MTA\nconfiguration based on country specific needs.\nAn MTA MUST populate all entries of this table for each\ntone type.")
pktcSigDevToneType = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 32, 1, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(13,11,10,9,12,5,7,14,3,1,15,2,17,8,4,6,16,18,19,20,21,)).subtype(namedValues=NamedValues(("busy", 1), ("callWaiting2", 10), ("callWaiting3", 11), ("callWaiting4", 12), ("alertingSignal", 13), ("specialDial", 14), ("specialInfo", 15), ("release", 16), ("congestion", 17), ("userDefined1", 18), ("userDefined2", 19), ("confirmation", 2), ("userDefined3", 20), ("userDefined4", 21), ("dial", 3), ("messageWaiting", 4), ("offHookWarning", 5), ("ringBack", 6), ("reOrder", 7), ("stutterdial", 8), ("callWaiting1", 9), ))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: pktcSigDevToneType.setDescription("A unique value that will correspond to the different\ntone types.  These tones can be provisioned based on\ncountry-specific needs.  This object defines the type\nof tone being accessed.\n\nThe alertingSignal, specialDial, specialInfo, release,\n\n\n\ncongestion, userDefined1, userDefined2, userDefined3,\nand userDefined4 tone types are used in\nthe E line package.")
pktcSigDevToneFreqGroup = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 32, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: pktcSigDevToneFreqGroup.setDescription("This MIB object represents the Tone Sequence reference\nof a multi-sequence tone.")
pktcSigDevToneFreqCounter = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 32, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigDevToneFreqCounter.setDescription("This MIB object represents the number of consecutive\nmulti-frequency tones for the particular tone type in\nthe multi-frequency table (pktcSigDevMultiFreqToneTable).\n\nSuch a sequence of the consecutive multi-frequency tones\nforms the tone group for the particular tone type in the\npktcSigDevToneTable.")
pktcSigDevToneWholeToneRepeatCount = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 32, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigDevToneWholeToneRepeatCount.setDescription("This is the repeat count, which signifies how many times\nto repeat the entire on-off cadence sequence.  Setting this\nobject may result in a cadence duration longer or shorter\nthan the overall signal duration specified by the time out\n(TO) object for a particular signal.  If the repeat count\nresults in a longer tone duration than the signal duration\nspecified by the TO, the tone duration defined by the\nTO object for a particular signal always represents\nthe overall signal duration for a tone.  In this case, the\ntone duration repeat count will not be fully exercised, and\nthe desired tone duration will be truncated per the TO\nsetting.  If the repeat count results in a shorter tone\nduration than the signal duration specified by the TO, the\ntone duration defined by the repeat count takes precedence\nover the TO and will end the signal event.  In this case,\n\n\n\nthe TO represents a time not to be exceeded for the signal.\nIt is recommended to ensure proper telephony signaling so that\nthe TO duration setting should always be longer than the\ndesired repeat count-time duration.")
pktcSigDevToneSteady = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 32, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigDevToneSteady.setDescription("This MIB object represents the steady tone status.  A value\nof 'true(1)' indicates that the steady tone is applied, and\na value of 'false(2)' indicates otherwise.\nDevices must play out the on-off cadence sequence for\nthe number of times indicated by the MIB object\n'pktcSigDevToneWholeToneRepeatCount' prior to applying the\nlast tone steadily, indefinitely.  If the MIB table\n'pktcSigDevToneTable' contains multiple rows with this\nObject set to a value of 'true(1)', the steady tone is\napplied to the last repeating frequency group of the tone.\n\nSetting this MIB object may result in a tone duration that is\nlonger or shorter than the overall signal duration\nspecified by the time out (TO) MIB object for a particular\nsignal.  If the repeat count results in a longer tone\nduration than the signal duration specified by the TO, the\ntone duration defined by the TO object for a particular\nsignal always represents the overall signal duration for a\ntone.  In this case, the tone duration repeat count will\nnot be fully exercised, and the desired tone duration will\nbe truncated per the TO setting.  If the repeat count\nresults in a shorter tone duration than the signal duration\nspecified by the TO, the tone duration defined by the\nrepeat count takes precedence over the TO and will end the\nsignal event.  In this case, the TO represents a time not to\nbe exceeded for the signal.\n\nIt is recommended to ensure proper telephony signaling that\nThe TO duration setting should always be longer than the\ndesired repeat count-time duration, plus the desired maximum\nsteady tone period.")
pktcSigDevMultiFreqToneTable = MibTable((1, 3, 6, 1, 2, 1, 169, 1, 1, 33))
if mibBuilder.loadTexts: pktcSigDevMultiFreqToneTable.setDescription(" This MIB table defines the characteristics of tones\nwith multiple frequencies.  The constraints imposed\non the tones by the MIB table pktcSigDevToneTable\nneed to be considered for MIB objects in this table\nas well.\n\nThe MTA MUST populate the corresponding row(s)\nof the pktcSigDevMultiFreqToneTable for each tone\ndefined in the pktcSigDevToneTable.\n\nThe contents of the table may be provisioned via\nMTA configuration.")
pktcSigDevMultiFreqToneEntry = MibTableRow((1, 3, 6, 1, 2, 1, 169, 1, 1, 33, 1)).setIndexNames((0, "PKTC-IETF-SIG-MIB", "pktcSigDevToneType"), (0, "PKTC-IETF-SIG-MIB", "pktcSigDevToneNumber"))
if mibBuilder.loadTexts: pktcSigDevMultiFreqToneEntry.setDescription(" The different tone types with multiple frequencies\nthat can be provisioned based on country-specific\nneeds.")
pktcSigDevToneNumber = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 33, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: pktcSigDevToneNumber.setDescription("This MIB object represents the frequency reference\nof a multi-frequency tone.")
pktcSigDevToneFirstFreqValue = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 33, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigDevToneFirstFreqValue.setDescription("This MIB object represents the value of the first\nfrequency of a tone type.  A value of zero implies\nabsence of the referenced frequency.")
pktcSigDevToneSecondFreqValue = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 33, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigDevToneSecondFreqValue.setDescription("This MIB object represents the value of the second\nfrequency of a tone type.  A value of zero implies\nabsence of the referenced frequency.")
pktcSigDevToneThirdFreqValue = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 33, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigDevToneThirdFreqValue.setDescription("This MIB object represents the value of the third\nfrequency of a tone type.  A value of zero implies\nabsence of the referenced frequency.")
pktcSigDevToneFourthFreqValue = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 33, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigDevToneFourthFreqValue.setDescription("This MIB object represents the value of the fourth\nfrequency of a tone type.  A value of zero implies\nabsence of the referenced frequency.")
pktcSigDevToneFreqMode = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 33, 1, 6), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("firstModulatedBySecond", 1), ("summation", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigDevToneFreqMode.setDescription("This MIB object provides directive on the\nmodulation or summation of the frequencies\ninvolved in the tone.\n\nIt is to be noted that while summation can\nbe done without any constraint on the number\nof frequencies, the modulation (amplitude)\nholds good only when there are two frequencies\n(first and second).\n\nThus:\n  - If the mode is set to a value of\n    'firstModulatedBySecond(1)', the first frequency\n    MUST be modulated by the second, and the remaining\n    frequencies (third and fourth) ignored.  The\n    percentage of amplitude modulation to be applied\n    is defined by the MIB object\n    pktcSigDevToneFreqAmpModePrtg.\n\n  - If the mode is set to a value of\n    'summation(2)', all the frequencies MUST be\n    summed without any modulation.")
pktcSigDevToneFreqAmpModePrtg = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 33, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigDevToneFreqAmpModePrtg.setDescription("This MIB object represents the percentage of amplitude\nmodulation applied to the second frequency\nwhen the MIB object pktcSigDevToneFreqMode is\nset to a value of 'firstModulatedBySecond (1)'.\n\nIf the MIB object pktcSigDevToneFreqMode is set to\nvalue of 'summation (2)', then this MIB object MUST be\nignored.")
pktcSigDevToneDbLevel = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 33, 1, 8), TenthdBm().subtype(subtypeSpec=ValueRangeConstraint(-250, -110)).clone(-120)).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigDevToneDbLevel.setDescription("This MIB object contains the decibel level for each\nanalog signal (tone) that is locally generated\n(versus in-band supervisory tones) and sourced to\nthe a-b terminals (TE connection point).  Each tone\nin itself may consist of multiple frequencies, as\ndefined by the MIB table pktcSigDevMultiFreqToneTable.\n\nThis MIB object reflects the desired level at\nthe Telco (POTS) a-b (T/R) terminals, including the\neffect of any MTA receiver gain (loss).  This is required\nso that locally generated tones are consistent with\nremotely generated in-band tones at the a-b terminals,\nconsistent with user expectations.\n\nThis MIB object must be set for each tone.\nWhen tones are formed by combining multi-frequencies,\nthe level of each frequency shall be set so as to result\nin the tone level specified in this object at the a-b\n(T/R) terminals.\n\nThe wide range of levels for this Object is required\nto provide signal-generator levels across the wide\nrange of gains (losses) -- but does not imply the entire\nrange is to be achievable given the range of gains (losses)\nin the MTA.")
pktcSigDevToneFreqOnDuration = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 33, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigDevToneFreqOnDuration.setDescription("This MIB object represents the duration for which the\nfrequency reference corresponding to the tone type\nis turned on.")
pktcSigDevToneFreqOffDuration = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 33, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigDevToneFreqOffDuration.setDescription("This MIB object represents the duration for which the\n\n\n\nfrequency reference corresponding to the tone type\nis turned off.")
pktcSigDevToneFreqRepeatCount = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 33, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigDevToneFreqRepeatCount.setDescription("This MIB object indicates the number of times\nto repeat the cadence cycle represented by the\non/off durations (refer to the MIB objects\npktcSigDevToneFreqOnDuration and\npktcSigDevToneFreqOffDuration).\n\nSetting this object may result in a tone duration that is\nlonger or shorter than the overall signal duration\nspecified by the time out (TO) object for the\ncorresponding tone type.  If the value of this MIB\nObject indicates a longer duration than that\nspecified by the TO, the latter overrules the former,\nand the desired tone duration will be truncated according\nto the TO.\n\nHowever, if the repeat count results in a shorter\ntone duration than the signal duration specified by\nthe TO, the tone duration defined by the repeat count\ntakes precedence over the TO and will end the signal\nevent.  In this case, the TO represents a time not to\nbe exceeded for the signal.  It is recommended, to\nensure proper telephony signaling, that the TO\nduration setting should always be longer than the\ndesired repeat count-time duration.  A value of zero\nmeans the tone sequence is to be played once but not\nrepeated.")
pktcSigDevCidDelayAfterLR = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 34), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(300, 800)).clone(400)).setMaxAccess("readwrite").setUnits("Milliseconds")
if mibBuilder.loadTexts: pktcSigDevCidDelayAfterLR.setDescription("This object specifies the delay between the end of the\nLine Reversal and the start of the FSK or DTMF signal.\nThis MIB object is used only when pktcSigDevCidMode is\nset to a value of 'lrETS'.  This timing has a range of\n300 to 800 ms.\n\n\n\nThe following table defines the default values\nfor this MIB object, depending on the signal type\n(pktcSigDevCidMode), and MUST be followed:\n\nValue of pktcSigDevCidMode       Default value\n\nduringringingETS               any value  (not used)\ndtAsETS                        any value  (not used)\nrpAsETS                        any value  (not used)\nlrAsETS                        any value  (not used)\nlrETS                          400\n\nAn attempt to set this object while the value of\npktcSigDevCidMode is not set to a value of 'lrETS' will\nresult in an 'inconsistentValue' error.\n\nThe value of this MIB object MUST NOT persist across MTA\nreboots.")
pktcSigDevCidDtmfStartCode = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 35), DtmfCode().clone('dtmfcodeA')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevCidDtmfStartCode.setDescription("This object identifies optional start codes used when\nthe MIB object pktcSigDevCidSigProtocol is set\nto a value of 'dtmf(2)'.\n\nDifferent countries define different caller id signaling\ncodes to support caller identification.  When Dual-Tone\nMulti-Frequency (DTMF) is used, the caller id digits are\npreceded by a 'start code' digit, followed by the digit\ntransmission sequence <S1>...<Sn> (where Sx represents\nthe digits 0-9), and terminated by the 'end code' digit.\n\nFor example,\n  <A><S1>...<Sn> <D><S1>...<Sn> <B><S1>...<Sn> <C>.\nThe start code for calling number delivery may be DTMF\n'A' or 'D'.  The start code for redirecting a number may be\nDTMF 'D'.  The DTMF code 'B' may be sent by the network\nas a start code for the transfer of information values,\nthrough which special events can be indicated to the\nuser.  In some countries, the '*' or '#' may be used\ninstead of 'A', 'B', 'C', or 'D'.\n\nThe value of this MIB object MUST NOT persist across MTA\n\n\n\nreboots.")
pktcSigDevCidDtmfEndCode = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 36), DtmfCode().clone('dtmfcodeC')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevCidDtmfEndCode.setDescription("This object identifies optional end codes used when the\npktcSigDevCidSigProtocol is set to a value of\n'dtmf(2)'.\n\nDifferent countries define different caller id signaling\nprotocols to support caller identification.  When\nDual-Tone Multi-Frequency (DTMF) is used, the caller id\ndigits are preceded by a 'start code' digit, followed by\nthe digit transmission sequence <S1>...<Sn> (where Sx\nrepresents the digits 0-9), and terminated by the 'end\ncode' digit.\n\nFor example,\n  <A><S1>...<Sn> <D><S1>...<Sn> <B><S1>...<Sn> <C>.\n\nThe DTMF code 'C' may be sent by the network as an\nend code for the transfer of information values, through\nwhich special events can be indicated to the user.  In\nsome countries, the '*' or '#' may be used instead of\n'A', 'B', 'C', or 'D'.\n\nThe value of this MIB object MUST NOT persist across MTA\nreboots.")
pktcSigDevVmwiSigProtocol = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 37), PktcSubscriberSideSigProtocol().clone('fsk')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevVmwiSigProtocol.setDescription("This object identifies the subscriber line protocol used\nfor signaling the information on Visual Message Waiting\nIndicator (VMWI).  Different countries define different\nVMWI signaling protocols to support VMWI service.\n\n\n\nFrequency shift keying (FSK) is most commonly used.\nDTMF is an alternative.\n\nThe value of this MIB object MUST NOT persist across MTA\nreboots.")
pktcSigDevVmwiDelayAfterLR = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 38), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0,0),ValueRangeConstraint(300,800),)).clone(400)).setMaxAccess("readwrite").setUnits("Milliseconds")
if mibBuilder.loadTexts: pktcSigDevVmwiDelayAfterLR.setDescription("This object specifies the delay between the end of the\nLine Reversal and the start of the FSK or DTMF signal.\nThis object is only used when pktcSigDevVmwiMode is\nset to a value of 'lrETS'.\nThis timing has a range of 300 to 800 ms.\n\nThe following table defines the default values\nfor this MIB object, depending on the signal type\n(pktcSigDevVmwiMode), and MUST be followed:\n\nValue of pktcSigDevVmwiMode       Default value\n\nduringringingETS                  any value  (not used)\ndtAsETS                           any value  (not used)\nrpAsETS                           any value  (not used)\nlrAsETS                           any value  (not used)\nlrETS                             400\n\nAn attempt to set this object while the value of\npktcSigDevVmwiMode is not 'lrETS' will result in an\n'inconsistentValue' error.\n\nThe value of this MIB object MUST NOT persist across MTA\nreboots.")
pktcSigDevVmwiDtmfStartCode = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 39), DtmfCode().clone('dtmfcodeA')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevVmwiDtmfStartCode.setDescription("This object identifies optional start codes used when\n\n\n\nthe pktcSigDevVmwiSigProtocol is set to a value of\n'dtmf(2)'.  Different countries define different On Hook\nData Transmission Protocol signaling codes to support\nVMWI.\n\nWhen Dual-Tone Multi-Frequency (DTMF) is used, the VMWI\ndigits are preceded by a 'start code' digit, followed\nby the digit transmission sequence <S1>...<Sn> (where\nSx represents the digits 0-9), and terminated by the 'end\ncode' digit.\n\nFor example,\n  <A><S1>...<Sn> <D><S1>...<Sn> <B><S1>...<Sn> <C>.\n\nThe start code for redirecting VMWI may be DTMF 'D'\nThe DTMF code 'B' may be sent by the network as a start\ncode for the transfer of information values, through\nwhich special events can be indicated to the user.  In\nsome countries, the '*' or '#' may be used instead of\n'A', 'B', 'C', or 'D'.\n\nThe value of this MIB object MUST NOT persist across MTA\nreboots.")
pktcSigDevVmwiDtmfEndCode = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 40), DtmfCode().clone('dtmfcodeC')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevVmwiDtmfEndCode.setDescription("This object identifies an optional end code used when the\npktcSigDevVmwiSigProtocol is set to a value of\n'dtmf(2)'.  Different countries define different on-hook\nData Transmission Protocol signaling codes to support\nVMWI.\n\nWhen Dual-Tone Multi-Frequency (DTMF) is used, the VMWI\ndigits are preceded by a 'start code' digit, followed\nby the digit transmission sequence <S1>...<Sn> (where\nSx represents the digits 0-9), and terminated by the 'end\ncode' digit.\n\nFor example,\n  <A><S1>...<Sn> <D><S1>...<Sn> <B><S1>...<Sn> <C>.\n\n\n\n\nThe DTMF code 'C' may be sent by the network as an end code\nfor the transfer of information values, through which\nspecial events can be indicated to the user.  In some\ncountries, the '*' or '#' may be used instead of 'A',\n'B', 'C', or 'D'.\n\nThe value of this MIB object MUST NOT persist across MTA\nreboots.")
pktcSigDevrpAsDtsDuration = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 41), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0,0),ValueRangeConstraint(200,500),)).clone(250)).setMaxAccess("readwrite").setUnits("Milliseconds")
if mibBuilder.loadTexts: pktcSigDevrpAsDtsDuration.setDescription(" This object specifies the duration of the rpASDTS ring\npulse prior to the start of the transmission of the\nFSK or DTMF containing the caller id information.  It is\nonly used when pktcSigDevCidMode is set to a value of\n'rpAsETS'.\n\nThe following table defines the default values\nfor this MIB object, depending on the signal type\n(pktcSigDevCidMode), and MUST be followed:\n\nValue of pktcSigDevCidMode       Default value\n\nduringringingETS                 any value  (not used)\ndtAsETS                          any value  (not used)\nrpAsETS                          250\nlrAsETS                          any value  (not used)\nlrETS                            any value  (not used)\n\nAn attempt to set this object while the value of\npktcSigDevCidMode is not 'rpAsETS' will result in\nan 'inconsistentValue' error.\n\nThe value of this MIB object MUST NOT persist across MTA\nreboots.")
pktcSigEndPntConfigObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 169, 1, 2))
pktcSigEndPntConfigTable = MibTable((1, 3, 6, 1, 2, 1, 169, 1, 2, 1))
if mibBuilder.loadTexts: pktcSigEndPntConfigTable.setDescription(" This table describes the information pertaining to each\nendpoint of the MTA.  All entries in this table represent\nthe provisioned endpoints provisioned with the information\nrequired by the MTA to maintain the NCS protocol\ncommunication with the CMS.  Each endpoint can be assigned\nto its own CMS.  If the specific endpoint does not have\nthe corresponding CMS information in this table, the\nendpoint is considered as not provisioned with voice\nservices.  Objects in this table do not persist across\nMTA reboots.")
pktcSigEndPntConfigEntry = MibTableRow((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1)).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: pktcSigEndPntConfigEntry.setDescription("Each entry in the pktcSigEndPntConfigTable represents\nrequired signaling parameters for the specific endpoint\nprovisioned with voice services.  The conceptual rows MUST\nNOT persist across MTA reboots.")
pktcSigEndPntConfigCallAgentId = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(3, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigCallAgentId.setDescription(" This object contains a string indicating the call agent\nname (e.g., ca@example.com).  The call agent name, after\nthe character '@', MUST be a fully qualified domain name\n(FQDN) and MUST have a corresponding pktcMtaDevCmsFqdn\nentry in the pktcMtaDevCmsTable.  The object\npktcMtaDevCmsFqdn is defined in the PacketCable MIBMTA\nSpecification.  For each particular endpoint, the MTA MUST\nuse the current value of this object to communicate with\nthe corresponding CMS.  The MTA MUST update this object\nwith the value of the 'Notified Entity' parameter of the\nNCS message.  Because of the high importance of this object\nto the ability of the MTA to maintain reliable NCS\ncommunication with the CMS, it is highly recommended not\nto change this object's value using SNMP during normal\noperation.")
pktcSigEndPntConfigCallAgentUdpPort = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 2), InetPortNumber().subtype(subtypeSpec=ValueRangeConstraint(1025, 65535)).clone(2727)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigCallAgentUdpPort.setDescription(" This object contains the current value of the User\nDatagram Protocol (UDP) receive port on which the\ncall agent will receive NCS from the endpoint.\nFor each particular endpoint, the MTA MUST use the current\nvalue of this object to communicate with the corresponding\nCMS.  The MTA MUST update this object with the value of the\n'Notified Entity' parameter of the NCS message.  If the\nNotified Entity parameter does not contain a CallAgent\nport, the MTA MUST update this object with the default\nvalue of 2727.  Because of the high importance of this\nobject to the ability of the MTA to maintain reliable NCS\ncommunication with the CMS, it is highly recommended not\nto change this object's value using SNMP during normal\noperation.")
pktcSigEndPntConfigPartialDialTO = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 3), Unsigned32().clone(16)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigPartialDialTO.setDescription("This object contains the value of the partial dial\ntime out.\nThe time out (TO) elements are intended to limit the time a\ntone or frequency is generated.  When this MIB object is set\nto a value of '0', the MTA MUST NOT generate the\ncorresponding frequency or tone, regardless of the\ndefinitions pertaining to frequency, tone duration, or\ncadence.")
pktcSigEndPntConfigCriticalDialTO = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 4), Unsigned32().clone(4)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigCriticalDialTO.setDescription("This object contains the value of the critical\ndial time out.\nThe time out (TO) elements are intended to limit the time a\ntone or frequency is generated.  When this MIB object is set\nto a value of '0', the MTA MUST NOT generate the\ncorresponding frequency or tone, regardless of the\ndefinitions pertaining to frequency, tone duration, or\ncadence.")
pktcSigEndPntConfigBusyToneTO = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 5), Unsigned32().clone(30)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigBusyToneTO.setDescription(" This object contains the default time out value for busy\ntone.  The MTA MUST NOT update this object with the\nvalue provided in the NCS message (if present).  If\nthe value of the object is modified by the SNMP Management\nStation, the MTA MUST use the new value as a default only\nfor a new signal requested by the NCS message.\nThe time out (TO) elements are intended to limit the time\na tone or frequency is generated.  When this MIB object is\nset to a value of '0', the MTA MUST NOT generate the\ncorresponding frequency or tone, regardless of the\ndefinitions pertaining to frequency, tone duration, or\ncadence.")
pktcSigEndPntConfigDialToneTO = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 6), Unsigned32().clone(16)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigDialToneTO.setDescription(" This object contains the default time out value for dial\ntone.  The MTA MUST NOT update this object with the\nvalue provided in the NCS message (if present).  If\n\n\n\nthe value of the object is modified by the SNMP Management\nStation, the MTA MUST use the new value as a default only\nfor a new signal requested by the NCS message.\nThe time out (TO) elements are intended to limit the time\na tone or frequency is generated.  When this MIB object is\nset to a value of '0', the MTA MUST NOT generate the\ncorresponding frequency or tone, regardless of the\ndefinitions pertaining to frequency, tone duration, or\ncadence.")
pktcSigEndPntConfigMessageWaitingTO = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 7), Unsigned32().clone(16)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigMessageWaitingTO.setDescription(" This object contains the default time out value for message\nwaiting indicator.  The MTA MUST NOT update this object\nwith the value provided in the NCS message (if\npresent).  If the value of the object is modified by the\nSNMP Manager application, the MTA MUST use the new value\nas a default only for a new signal requested by the NCS\nmessage.\nThe time out (TO) elements are intended to limit the time\na tone or frequency is generated.  When this MIB object is\nset to a value of '0', the MTA MUST NOT generate the\ncorresponding frequency or tone, regardless of the\ndefinitions pertaining to frequency, tone duration, or\ncadence.")
pktcSigEndPntConfigOffHookWarnToneTO = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 8), Unsigned32().clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigOffHookWarnToneTO.setDescription(" This object contains the default time out value for the\noff-hook warning tone.  The MTA MUST NOT update this object\nwith the value provided in the NCS message (if present).  If\nthe value of the object is modified by the SNMP Manager\n\n\n\napplication, the MTA MUST use the new value as a default\nonly for a new signal requested by the NCS message.  The\ntime out (TO) elements are intended to limit the time a tone\nor frequency is generated.  When this MIB object is set to a\nvalue of '0', the MTA MUST NOT generate the corresponding\nfrequency or tone, regardless of the definitions pertaining\nto frequency, tone duration, or cadence.")
pktcSigEndPntConfigRingingTO = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 9), Unsigned32().clone(180)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigRingingTO.setDescription(" This object contains the default time out value for\nringing.  The MTA MUST NOT update this object with the\nvalue provided in the NCS message (if present).  If\nthe value of the object is modified by the SNMP Management\nStation, the MTA MUST use the new value as a default only\nfor a new signal requested by the NCS message.\nThe time out (TO) elements are intended to limit the time\na tone or frequency is generated.  When this MIB object is\nset to a value of '0', the MTA MUST NOT generate the\ncorresponding frequency or tone, regardless of the\ndefinitions pertaining to frequency, tone duration, or\ncadence.")
pktcSigEndPntConfigRingBackTO = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 10), Unsigned32().clone(180)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigRingBackTO.setDescription(" This object contains the default time out value for ring\nback.  The MTA MUST NOT update this object with the\nvalue provided in the NCS message (if present).  If\nthe value of the object is modified by the SNMP Management\nStation, the MTA MUST use the new value as a default only\nfor a new signal requested by the NCS message.\nThe time out (TO) elements are intended to limit the time\n\n\n\na tone or frequency is generated.  When this MIB object is\nset to a value of '0', the MTA MUST NOT generate the\ncorresponding frequency or tone, regardless of the\ndefinitions pertaining to frequency, tone duration, or\ncadence.")
pktcSigEndPntConfigReorderToneTO = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 11), Unsigned32().clone(30)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigReorderToneTO.setDescription(" This object contains the default time out value for reorder\ntone.  The MTA MUST NOT update this object with the\nvalue provided in the NCS message (if present).  If\nthe value of the object is modified by the SNMP Management\nStation, the MTA MUST use the new value as a default only\nfor a new signal requested by the NCS message.\nThe time out (TO) elements are intended to limit the time\na tone or frequency is generated.  When this MIB object is\nset to a value of '0', the MTA MUST NOT generate the\ncorresponding frequency or tone, regardless of the\ndefinitions pertaining to frequency, tone duration, or\ncadence.")
pktcSigEndPntConfigStutterDialToneTO = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 12), Unsigned32().clone(16)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigStutterDialToneTO.setDescription(" This object contains the default time out value for stutter\ndial tone.  The MTA MUST NOT update this object with the\nvalue provided in the NCS message (if present).  If\nthe value of the object is modified by the SNMP Management\nStation, the MTA MUST use the new value as a default only\nfor a new signal requested by the NCS message.\nThe time out (TO) elements are intended to limit the time\na tone or frequency is generated.  When this MIB object is\nset to a value of '0', the MTA MUST NOT generate the\n\n\n\ncorresponding frequency or tone, regardless of the\ndefinitions pertaining to frequency, tone duration, or\ncadence.")
pktcSigEndPntConfigTSMax = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 13), Unsigned32().clone(20)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigTSMax.setDescription("This MIB object is used as part of an NCS\nretransmission algorithm.  Prior to any retransmission,\nthe MTA must check to make sure that the time elapsed\nsince the sending of the initial datagram does not\nexceed the value specified by this MIB object.  If more\nthan Tsmax time has elapsed, then the retransmissions\nMUST cease.\n\nRefer to the MIB object pktcSigEndPntConfigThist for\ninformation on when the endpoint becomes disconnected.")
pktcSigEndPntConfigMax1 = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 14), Unsigned32().clone(5)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigMax1.setDescription("This object contains the suspicious error threshold for\nsignaling messages.  The pktcSigEndPntConfigMax1 object\nindicates the retransmission threshold at which the MTA MAY\nactively query the domain name server (DNS) in order to\ndetect the possible change of call agent interfaces.")
pktcSigEndPntConfigMax2 = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 15), Unsigned32().clone(7)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigMax2.setDescription("This object contains the disconnect error threshold for\nsignaling messages.  The pktcSigEndPntConfigMax2 object\nindicates the retransmission threshold at which the MTA\nSHOULD contact the DNS one more time to see if any other\ninterfaces to the call agent have become available.")
pktcSigEndPntConfigMax1QEnable = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 16), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigMax1QEnable.setDescription("This object enables/disables the Max1 domain name server\n(DNS) query operation when the pktcSigEndPntConfigMax1\nthreshold has been reached.\nA value of true(1) indicates enabling, and a value of\nfalse(2) indicates disabling.")
pktcSigEndPntConfigMax2QEnable = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 17), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigMax2QEnable.setDescription("This object enables/disables the Max2 domain name server\n(DNS) query operation when the pktcSigEndPntConfigMax2\nthreshold has been reached.\nA value of true(1) indicates enabling, and a value of\nfalse(2) indicates disabling.")
pktcSigEndPntConfigMWD = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 18), Unsigned32().clone(600)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigMWD.setDescription("Maximum Waiting Delay (MWD) contains the maximum number of\nseconds an MTA waits, after powering on, before initiating\nthe restart procedure with the call agent.")
pktcSigEndPntConfigTdinit = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 19), Unsigned32().clone(15)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigTdinit.setDescription("This MIB object represents the 'disconnected' initial\nwaiting delay within the context of an MTA's 'disconnected\nprocedure'.  The 'disconnected procedure' is initiated when\nan endpoint becomes 'disconnected' while attempting to\ncommunicate with a call agent.\n\nThe 'disconnected timer' associated with the 'disconnected\nProcedure' is initialized to a random value, uniformly\ndistributed between zero and the value contained in this\nMIB object.\n\nFor more information on the usage of this timer, please\nrefer to the PacketCable NCS Specification.")
pktcSigEndPntConfigTdmin = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 20), Unsigned32().clone(15)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigTdmin.setDescription("This MIB object represents the 'disconnected' minimum\nwaiting delay within the context of an MTA's\n'disconnected procedure', specifically when local user\nactivity is detected.\nThe 'disconnected procedure' is initiated when\nan endpoint becomes 'disconnected' while attempting to\ncommunicate with a call agent.\nFor more information on the usage of this timer, please\nrefer to the PacketCable NCS Specification.")
pktcSigEndPntConfigTdmax = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 21), Unsigned32().clone(600)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigTdmax.setDescription(" This object contains the maximum number of seconds the MTA\nwaits, after a disconnect, before initiating the\ndisconnected procedure with the call agent.\n ")
pktcSigEndPntConfigRtoMax = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 22), Unsigned32().clone(4)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigRtoMax.setDescription("This object specifies the maximum number of seconds the MTA\nwaits for a response to an NCS message before initiating\na retransmission.")
pktcSigEndPntConfigRtoInit = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 23), Unsigned32().clone(200)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigRtoInit.setDescription(" This object contains the initial number of seconds for the\nretransmission timer.")
pktcSigEndPntConfigLongDurationKeepAlive = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 24), Unsigned32().clone(60)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigLongDurationKeepAlive.setDescription(" Specifies a time out value, in minutes, for sending long\nduration call notification messages.")
pktcSigEndPntConfigThist = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 25), Unsigned32().clone(30)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigThist.setDescription(" Time out period, in seconds, before no response is declared.")
pktcSigEndPntConfigStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 26), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigStatus.setDescription(" This object contains the Row Status associated with the\npktcSigEndPntConfigTable.  There are no restrictions or\ndependencies amidst the columnar objects before this\nrow can be activated or for modifications of the\ncolumnar objects when this object is set to a\nvalue of 'active(1).")
pktcSigEndPntConfigCallWaitingMaxRep = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 27), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 10)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigCallWaitingMaxRep.setDescription(" This object contains the default value of the maximum\nnumber of repetitions of the Call Waiting tone that the\nMTA will play from a single CMS request.  The MTA MUST NOT\nupdate this object with the information provided in the\nNCS message (if present).  If the value of the object is\nmodified by the SNMP Manager application, the MTA MUST use\nthe new value as a default only for a new signal\nrequested by the NCS message.")
pktcSigEndPntConfigCallWaitingDelay = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 28), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(10)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigCallWaitingDelay.setDescription(" This object contains the delay between repetitions of the\nCall Waiting tone that the MTA will play from a single CMS\nrequest.")
pktcSigEndPntStatusCallIpAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 29), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigEndPntStatusCallIpAddressType.setDescription(" This object contains the type of Internet address contained\nin the MIB object 'pktcSigEndPntStatusCallIpAddress'.\n\nSince pktcSigEndPntStatusCallIpAddress is expected to\ncontain an IP address, a value of dns(16) is disallowed.")
pktcSigEndPntStatusCallIpAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 30), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigEndPntStatusCallIpAddress.setDescription(" This MIB object contains the chosen IP address of the CMS\ncurrently being used for the corresponding endpoint.\n\nThe device determines the IP address by using DNS to\nresolve the IP address of the CMS from the FQDN stored in\nthe MIB object 'pktcSigEndPntConfigCallAgentId'.  The\nprocesses are outlined in the PacketCable NCS and Security\nspecifications, and MUST be followed by the MTA.\n\nThe IP address type contained in this MIB object is\nindicated by pktcSigEndPntStatusCallIpAddressType.")
pktcSigEndPntStatusError = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 31), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,3,)).subtype(namedValues=NamedValues(("operational", 1), ("noSecurityAssociation", 2), ("disconnected", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigEndPntStatusError.setDescription(" This object contains the error status for this interface.\nThe operational status indicates that all operations\nnecessary to put the line in service have occurred, and the\nCMS has acknowledged the Restart In Progress (RSIP)\nmessage successfully.  If pktcMtaDevCmsIpsecCtrl is enabled\nfor the associated call agent, the noSecurityAssociation\nstatus indicates that no Security Association (SA) yet\nexists for this endpoint.  If pktcMtaDevCmsIpsecCtrl is\ndisabled for the associated call agent, the\nnoSecurityAssociation status is not applicable and should\nnot be used by the MTA.  The disconnected status indicates\none of the following two:\nIf pktcMtaDevCmsIpsecCtrl is disabled, then no security\nassociation is involved with this endpoint.  The NCS\nsignaling software is in process of establishing the NCS\nsignaling link via an RSIP exchange.\nOtherwise, when pktcMtaDevCmsIpsecCtrl is enabled,\nsecurity Association has been established, and the NCS\nsignaling software is in process of establishing the NCS\nsignaling link via an RSIP exchange.")
pktcSigEndPntConfigMinHookFlash = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 32), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(20, 1550)).clone(300)).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigEndPntConfigMinHookFlash.setDescription(" This is the minimum time a line needs to be on-hook for a\nvalid hook flash.  The value of this object MUST be\ngreater than the value of\npktcSigEndPntConfigPulseDialMaxBreakTime.  The value of\npktcSigEndPntConfigMinHookFlash MUST be less than\npktcSigEndPntConfigMaxHookFlash.  This object MUST only be\nset via the MTA configuration during the provisioning\nprocess.\n   Furthermore, given the possibility for the 'pulse dial'\n   and 'hook flash' to overlap, the value of this object\n   MUST be greater than the value contained by the MIB\n   Object 'pktcSigEndPntConfigPulseDialMaxMakeTime'.")
pktcSigEndPntConfigMaxHookFlash = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 33), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(20, 1550)).clone(800)).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigEndPntConfigMaxHookFlash.setDescription(" This is the maximum time a line needs to be on-hook for a\nvalid hook flash.  The value of\npktcSigEndPntConfigMaxHookFlash MUST be greater than\npktcSigEndPntConfigMinHookFlash.  This object MUST only be\nset via the MTA configuration during the provisioning\nprocess.")
pktcSigEndPntConfigPulseDialInterdigitTime = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 34), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(100, 1500)).clone(100)).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigEndPntConfigPulseDialInterdigitTime.setDescription(" This is the pulse dial inter-digit time out.  This object\nMUST only be set via the MTA configuration during the\nprovisioning process.")
pktcSigEndPntConfigPulseDialMinMakeTime = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 35), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(20, 200)).clone(25)).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigEndPntConfigPulseDialMinMakeTime.setDescription(" This is the minimum make pulse width for the dial pulse.\nThe value of pktcSigEndPntConfigPulseDialMinMakeTime MUST\nbe less than pktcSigEndPntConfigPulseDialMaxMakeTime.  This\nobject MUST only be set via the MTA configuration during\nthe provisioning process.")
pktcSigEndPntConfigPulseDialMaxMakeTime = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 36), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(20, 200)).clone(55)).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigEndPntConfigPulseDialMaxMakeTime.setDescription(" This is the maximum make pulse width for the dial pulse.\n\n\n\nThe value of pktcSigEndPntConfigPulseDialMaxMakeTime MUST\nbe greater than pktcSigEndPntConfigPulseDialMinMakeTime.\nThis object MUST only be provided via the configuration\nfile during the provisioning process.\nFurthermore, given the possibility for the 'pulse dial'\nand 'hook flash' to overlap, the value of this object MUST\nbe less than the value contained by the MIB object\npktcSigEndPntConfigMinHookFlash.")
pktcSigEndPntConfigPulseDialMinBreakTime = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 37), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(20, 200)).clone(45)).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigEndPntConfigPulseDialMinBreakTime.setDescription(" This is the minimum break pulse width for the dial pulse.\nThe value of pktcSigEndPntConfigPulseDialMinBreakTime MUST\nbe less than pktcSigEndPntConfigPulseDialMaxBreakTime.\nThis object must only be provided via the configuration\nfile during the provisioning process.")
pktcSigEndPntConfigPulseDialMaxBreakTime = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 38), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(20, 200)).clone(75)).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigEndPntConfigPulseDialMaxBreakTime.setDescription(" This is the maximum break pulse width for the dial pulse.\nThe value of pktcSigEndPntConfigPulseDialMaxBreakTime MUST\nbe greater than pktcSigEndPntConfigPulseDialMinBreakTime.\nThis object MUST only be provided via the configuration\nfile during the provisioning process.")
pktcSigConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 169, 2))
pktcSigCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 169, 2, 1))
pktcSigGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 169, 2, 2))

# Augmentions

# Groups

pktcSigDeviceGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 169, 2, 2, 1)).setObjects(*(("PKTC-IETF-SIG-MIB", "pktcSigCapabilityVersion"), ("PKTC-IETF-SIG-MIB", "pktcSigCapabilityType"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR2Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR3Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevSilenceSuppression"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR5Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevEchoCancellation"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR7Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDefNcsReceiveUdpPort"), ("PKTC-IETF-SIG-MIB", "pktcSigDevRsCadence"), ("PKTC-IETF-SIG-MIB", "pktcSigCapabilityVendorExt"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR0Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR1Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR4Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevVmwiMode"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR6Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDefMediaStreamDscp"), ("PKTC-IETF-SIG-MIB", "pktcSigDevRgCadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevCodecMax"), ("PKTC-IETF-SIG-MIB", "pktcSigDefCallSigDscp"), ) )
if mibBuilder.loadTexts: pktcSigDeviceGroup.setDescription("Group of MIB objects containing signaling configuration\ninformation that is applicable per-device.")
pktcSigEndpointGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 169, 2, 2, 2)).setObjects(*(("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigRingBackTO"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigTdinit"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigLongDurationKeepAlive"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigOffHookWarnToneTO"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigMax1QEnable"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigBusyToneTO"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigMessageWaitingTO"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigRtoMax"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigMax2QEnable"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigMax2"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigMax1"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntStatusCallIpAddress"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigThist"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigCriticalDialTO"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigCallWaitingMaxRep"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigCallAgentUdpPort"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigCallAgentId"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigRtoInit"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigMWD"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigStatus"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigTSMax"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigCallWaitingDelay"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigReorderToneTO"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntStatusError"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigPartialDialTO"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigRingingTO"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigTdmax"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntStatusCallIpAddressType"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigDialToneTO"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigStutterDialToneTO"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigTdmin"), ) )
if mibBuilder.loadTexts: pktcSigEndpointGroup.setDescription("Group of MIB objects containing signaling configuration\ninformation that is applicable per-endpoint.")
pktcInternationalGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 169, 2, 2, 3)).setObjects(*(("PKTC-IETF-SIG-MIB", "pktcSigDevToneFreqRepeatCount"), ("PKTC-IETF-SIG-MIB", "pktcSigDevCidSigProtocol"), ("PKTC-IETF-SIG-MIB", "pktcSigDevToneFreqCounter"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigPulseDialMinBreakTime"), ("PKTC-IETF-SIG-MIB", "pktcSigPulseSignalFrequency"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigMaxHookFlash"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigPulseDialMinMakeTime"), ("PKTC-IETF-SIG-MIB", "pktcSigDevToneFreqOnDuration"), ("PKTC-IETF-SIG-MIB", "pktcSigDevVmwiDtmfEndCode"), ("PKTC-IETF-SIG-MIB", "pktcSigDevCidDtmfStartCode"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigMinHookFlash"), ("PKTC-IETF-SIG-MIB", "pktcSigDevToneWholeToneRepeatCount"), ("PKTC-IETF-SIG-MIB", "pktcSigDevVmwiMode"), ("PKTC-IETF-SIG-MIB", "pktcSigPowerRingFrequency"), ("PKTC-IETF-SIG-MIB", "pktcSigDevCidAfterRPAS"), ("PKTC-IETF-SIG-MIB", "pktcSigDevToneFourthFreqValue"), ("PKTC-IETF-SIG-MIB", "pktcSigDevVmwiDelayAfterLR"), ("PKTC-IETF-SIG-MIB", "pktcSigDevToneSecondFreqValue"), ("PKTC-IETF-SIG-MIB", "pktcSigDevrpAsDtsDuration"), ("PKTC-IETF-SIG-MIB", "pktcSigDevVmwiDTASAfterLR"), ("PKTC-IETF-SIG-MIB", "pktcSigDevCidAfterRing"), ("PKTC-IETF-SIG-MIB", "pktcSigDevToneFirstFreqValue"), ("PKTC-IETF-SIG-MIB", "pktcSigDevRingCadence"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigPulseDialInterdigitTime"), ("PKTC-IETF-SIG-MIB", "pktcSigDevToneDbLevel"), ("PKTC-IETF-SIG-MIB", "pktcSigDevCidMode"), ("PKTC-IETF-SIG-MIB", "pktcSigDevToneSteady"), ("PKTC-IETF-SIG-MIB", "pktcSigPulseSignalPulseInterval"), ("PKTC-IETF-SIG-MIB", "pktcSigPulseSignalRepeatCount"), ("PKTC-IETF-SIG-MIB", "pktcSigPulseSignalDuration"), ("PKTC-IETF-SIG-MIB", "pktcSigDevToneFreqAmpModePrtg"), ("PKTC-IETF-SIG-MIB", "pktcSigDevVmwiAfterRPAS"), ("PKTC-IETF-SIG-MIB", "pktcSigDevCidDelayAfterLR"), ("PKTC-IETF-SIG-MIB", "pktcSigPulseSignalDbLevel"), ("PKTC-IETF-SIG-MIB", "pktcSigDevVmwiAfterDTAS"), ("PKTC-IETF-SIG-MIB", "pktcSigDevToneFreqMode"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigPulseDialMaxMakeTime"), ("PKTC-IETF-SIG-MIB", "pktcSigDevToneThirdFreqValue"), ("PKTC-IETF-SIG-MIB", "pktcSigDevCidDTASAfterLR"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigPulseDialMaxBreakTime"), ("PKTC-IETF-SIG-MIB", "pktcSigDevCidAfterDTAS"), ("PKTC-IETF-SIG-MIB", "pktcSigDevToneFreqOffDuration"), ("PKTC-IETF-SIG-MIB", "pktcSigDevVmwiSigProtocol"), ("PKTC-IETF-SIG-MIB", "pktcSigDevRingAfterCID"), ("PKTC-IETF-SIG-MIB", "pktcSigDevCidDtmfEndCode"), ("PKTC-IETF-SIG-MIB", "pktcSigDevVmwiDtmfStartCode"), ) )
if mibBuilder.loadTexts: pktcInternationalGroup.setDescription(" Group of objects that extend the behavior of existing\nobjects to support operations in the widest possible set\nof international marketplaces.  Note that many of these\nobjects represent a superset of behaviors described in\nother objects within this MIB module.")
pktcLLinePackageGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 169, 2, 2, 4)).setObjects(*(("PKTC-IETF-SIG-MIB", "pktcSigDevRsCadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR0Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR2Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR1Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR4Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR3Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR6Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR5Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR7Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevRgCadence"), ) )
if mibBuilder.loadTexts: pktcLLinePackageGroup.setDescription("Group of Objects to support the L line package.")
pktcELinePackageGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 169, 2, 2, 5)).setObjects(*(("PKTC-IETF-SIG-MIB", "pktcSigPulseSignalFrequency"), ("PKTC-IETF-SIG-MIB", "pktcSigPulseSignalDuration"), ("PKTC-IETF-SIG-MIB", "pktcSigPulseSignalDbLevel"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR2Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR3Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevRingCadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR5Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR7Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevRsCadence"), ("PKTC-IETF-SIG-MIB", "pktcSigPulseSignalPulseInterval"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR0Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR1Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR4Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigPulseSignalRepeatCount"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR6Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevRgCadence"), ) )
if mibBuilder.loadTexts: pktcELinePackageGroup.setDescription("Group of Objects to support the E line package.")

# Compliances

pktcSigBasicCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 169, 2, 1, 1)).setObjects(*(("PKTC-IETF-SIG-MIB", "pktcSigDeviceGroup"), ("PKTC-IETF-SIG-MIB", "pktcLLinePackageGroup"), ("PKTC-IETF-SIG-MIB", "pktcELinePackageGroup"), ("PKTC-IETF-SIG-MIB", "pktcSigEndpointGroup"), ("PKTC-IETF-SIG-MIB", "pktcInternationalGroup"), ) )
if mibBuilder.loadTexts: pktcSigBasicCompliance.setDescription(" The compliance statement for MTAs that implement\nNCS signaling.")

# Exports

# Module identity
mibBuilder.exportSymbols("PKTC-IETF-SIG-MIB", PYSNMP_MODULE_ID=pktcIetfSigMib)

# Types
mibBuilder.exportSymbols("PKTC-IETF-SIG-MIB", DtmfCode=DtmfCode, PktcCodecType=PktcCodecType, PktcRingCadence=PktcRingCadence, PktcSigType=PktcSigType, PktcSubscriberSideSigProtocol=PktcSubscriberSideSigProtocol, TenthdBm=TenthdBm)

# Objects
mibBuilder.exportSymbols("PKTC-IETF-SIG-MIB", pktcIetfSigMib=pktcIetfSigMib, pktcSigNotification=pktcSigNotification, pktcSigMibObjects=pktcSigMibObjects, pktcSigDevObjects=pktcSigDevObjects, pktcSigDevCodecTable=pktcSigDevCodecTable, pktcSigDevCodecEntry=pktcSigDevCodecEntry, pktcSigDevCodecComboIndex=pktcSigDevCodecComboIndex, pktcSigDevCodecType=pktcSigDevCodecType, pktcSigDevCodecMax=pktcSigDevCodecMax, pktcSigDevEchoCancellation=pktcSigDevEchoCancellation, pktcSigDevSilenceSuppression=pktcSigDevSilenceSuppression, pktcSigDevCidSigProtocol=pktcSigDevCidSigProtocol, pktcSigDevR0Cadence=pktcSigDevR0Cadence, pktcSigDevR1Cadence=pktcSigDevR1Cadence, pktcSigDevR2Cadence=pktcSigDevR2Cadence, pktcSigDevR3Cadence=pktcSigDevR3Cadence, pktcSigDevR4Cadence=pktcSigDevR4Cadence, pktcSigDevR5Cadence=pktcSigDevR5Cadence, pktcSigDevR6Cadence=pktcSigDevR6Cadence, pktcSigDevR7Cadence=pktcSigDevR7Cadence, pktcSigDevRgCadence=pktcSigDevRgCadence, pktcSigDevRsCadence=pktcSigDevRsCadence, pktcSigDefCallSigDscp=pktcSigDefCallSigDscp, pktcSigDefMediaStreamDscp=pktcSigDefMediaStreamDscp, pktcSigCapabilityTable=pktcSigCapabilityTable, pktcSigCapabilityEntry=pktcSigCapabilityEntry, pktcSigCapabilityIndex=pktcSigCapabilityIndex, pktcSigCapabilityType=pktcSigCapabilityType, pktcSigCapabilityVersion=pktcSigCapabilityVersion, pktcSigCapabilityVendorExt=pktcSigCapabilityVendorExt, pktcSigDefNcsReceiveUdpPort=pktcSigDefNcsReceiveUdpPort, pktcSigPowerRingFrequency=pktcSigPowerRingFrequency, pktcSigPulseSignalTable=pktcSigPulseSignalTable, pktcSigPulseSignalEntry=pktcSigPulseSignalEntry, pktcSigPulseSignalType=pktcSigPulseSignalType, pktcSigPulseSignalFrequency=pktcSigPulseSignalFrequency, pktcSigPulseSignalDbLevel=pktcSigPulseSignalDbLevel, pktcSigPulseSignalDuration=pktcSigPulseSignalDuration, pktcSigPulseSignalPulseInterval=pktcSigPulseSignalPulseInterval, pktcSigPulseSignalRepeatCount=pktcSigPulseSignalRepeatCount, pktcSigDevCidMode=pktcSigDevCidMode, pktcSigDevCidAfterRing=pktcSigDevCidAfterRing, pktcSigDevCidAfterDTAS=pktcSigDevCidAfterDTAS, pktcSigDevCidAfterRPAS=pktcSigDevCidAfterRPAS, pktcSigDevRingAfterCID=pktcSigDevRingAfterCID, pktcSigDevCidDTASAfterLR=pktcSigDevCidDTASAfterLR, pktcSigDevVmwiMode=pktcSigDevVmwiMode, pktcSigDevVmwiAfterDTAS=pktcSigDevVmwiAfterDTAS, pktcSigDevVmwiAfterRPAS=pktcSigDevVmwiAfterRPAS, pktcSigDevVmwiDTASAfterLR=pktcSigDevVmwiDTASAfterLR, pktcSigDevRingCadenceTable=pktcSigDevRingCadenceTable, pktcSigDevRingCadenceEntry=pktcSigDevRingCadenceEntry, pktcSigDevRingCadenceIndex=pktcSigDevRingCadenceIndex, pktcSigDevRingCadence=pktcSigDevRingCadence, pktcSigDevToneTable=pktcSigDevToneTable, pktcSigDevToneEntry=pktcSigDevToneEntry, pktcSigDevToneType=pktcSigDevToneType, pktcSigDevToneFreqGroup=pktcSigDevToneFreqGroup, pktcSigDevToneFreqCounter=pktcSigDevToneFreqCounter, pktcSigDevToneWholeToneRepeatCount=pktcSigDevToneWholeToneRepeatCount, pktcSigDevToneSteady=pktcSigDevToneSteady, pktcSigDevMultiFreqToneTable=pktcSigDevMultiFreqToneTable, pktcSigDevMultiFreqToneEntry=pktcSigDevMultiFreqToneEntry, pktcSigDevToneNumber=pktcSigDevToneNumber, pktcSigDevToneFirstFreqValue=pktcSigDevToneFirstFreqValue, pktcSigDevToneSecondFreqValue=pktcSigDevToneSecondFreqValue, pktcSigDevToneThirdFreqValue=pktcSigDevToneThirdFreqValue, pktcSigDevToneFourthFreqValue=pktcSigDevToneFourthFreqValue, pktcSigDevToneFreqMode=pktcSigDevToneFreqMode, pktcSigDevToneFreqAmpModePrtg=pktcSigDevToneFreqAmpModePrtg, pktcSigDevToneDbLevel=pktcSigDevToneDbLevel, pktcSigDevToneFreqOnDuration=pktcSigDevToneFreqOnDuration, pktcSigDevToneFreqOffDuration=pktcSigDevToneFreqOffDuration, pktcSigDevToneFreqRepeatCount=pktcSigDevToneFreqRepeatCount, pktcSigDevCidDelayAfterLR=pktcSigDevCidDelayAfterLR, pktcSigDevCidDtmfStartCode=pktcSigDevCidDtmfStartCode, pktcSigDevCidDtmfEndCode=pktcSigDevCidDtmfEndCode, pktcSigDevVmwiSigProtocol=pktcSigDevVmwiSigProtocol, pktcSigDevVmwiDelayAfterLR=pktcSigDevVmwiDelayAfterLR, pktcSigDevVmwiDtmfStartCode=pktcSigDevVmwiDtmfStartCode, pktcSigDevVmwiDtmfEndCode=pktcSigDevVmwiDtmfEndCode, pktcSigDevrpAsDtsDuration=pktcSigDevrpAsDtsDuration, pktcSigEndPntConfigObjects=pktcSigEndPntConfigObjects, pktcSigEndPntConfigTable=pktcSigEndPntConfigTable, pktcSigEndPntConfigEntry=pktcSigEndPntConfigEntry, pktcSigEndPntConfigCallAgentId=pktcSigEndPntConfigCallAgentId, pktcSigEndPntConfigCallAgentUdpPort=pktcSigEndPntConfigCallAgentUdpPort, pktcSigEndPntConfigPartialDialTO=pktcSigEndPntConfigPartialDialTO, pktcSigEndPntConfigCriticalDialTO=pktcSigEndPntConfigCriticalDialTO, pktcSigEndPntConfigBusyToneTO=pktcSigEndPntConfigBusyToneTO, pktcSigEndPntConfigDialToneTO=pktcSigEndPntConfigDialToneTO, pktcSigEndPntConfigMessageWaitingTO=pktcSigEndPntConfigMessageWaitingTO, pktcSigEndPntConfigOffHookWarnToneTO=pktcSigEndPntConfigOffHookWarnToneTO, pktcSigEndPntConfigRingingTO=pktcSigEndPntConfigRingingTO, pktcSigEndPntConfigRingBackTO=pktcSigEndPntConfigRingBackTO, pktcSigEndPntConfigReorderToneTO=pktcSigEndPntConfigReorderToneTO, pktcSigEndPntConfigStutterDialToneTO=pktcSigEndPntConfigStutterDialToneTO, pktcSigEndPntConfigTSMax=pktcSigEndPntConfigTSMax, pktcSigEndPntConfigMax1=pktcSigEndPntConfigMax1, pktcSigEndPntConfigMax2=pktcSigEndPntConfigMax2, pktcSigEndPntConfigMax1QEnable=pktcSigEndPntConfigMax1QEnable, pktcSigEndPntConfigMax2QEnable=pktcSigEndPntConfigMax2QEnable, pktcSigEndPntConfigMWD=pktcSigEndPntConfigMWD, pktcSigEndPntConfigTdinit=pktcSigEndPntConfigTdinit, pktcSigEndPntConfigTdmin=pktcSigEndPntConfigTdmin, pktcSigEndPntConfigTdmax=pktcSigEndPntConfigTdmax, pktcSigEndPntConfigRtoMax=pktcSigEndPntConfigRtoMax, pktcSigEndPntConfigRtoInit=pktcSigEndPntConfigRtoInit, pktcSigEndPntConfigLongDurationKeepAlive=pktcSigEndPntConfigLongDurationKeepAlive, pktcSigEndPntConfigThist=pktcSigEndPntConfigThist, pktcSigEndPntConfigStatus=pktcSigEndPntConfigStatus, pktcSigEndPntConfigCallWaitingMaxRep=pktcSigEndPntConfigCallWaitingMaxRep, pktcSigEndPntConfigCallWaitingDelay=pktcSigEndPntConfigCallWaitingDelay, pktcSigEndPntStatusCallIpAddressType=pktcSigEndPntStatusCallIpAddressType, pktcSigEndPntStatusCallIpAddress=pktcSigEndPntStatusCallIpAddress, pktcSigEndPntStatusError=pktcSigEndPntStatusError, pktcSigEndPntConfigMinHookFlash=pktcSigEndPntConfigMinHookFlash, pktcSigEndPntConfigMaxHookFlash=pktcSigEndPntConfigMaxHookFlash, pktcSigEndPntConfigPulseDialInterdigitTime=pktcSigEndPntConfigPulseDialInterdigitTime, pktcSigEndPntConfigPulseDialMinMakeTime=pktcSigEndPntConfigPulseDialMinMakeTime, pktcSigEndPntConfigPulseDialMaxMakeTime=pktcSigEndPntConfigPulseDialMaxMakeTime, pktcSigEndPntConfigPulseDialMinBreakTime=pktcSigEndPntConfigPulseDialMinBreakTime, pktcSigEndPntConfigPulseDialMaxBreakTime=pktcSigEndPntConfigPulseDialMaxBreakTime, pktcSigConformance=pktcSigConformance, pktcSigCompliances=pktcSigCompliances, pktcSigGroups=pktcSigGroups)

# Groups
mibBuilder.exportSymbols("PKTC-IETF-SIG-MIB", pktcSigDeviceGroup=pktcSigDeviceGroup, pktcSigEndpointGroup=pktcSigEndpointGroup, pktcInternationalGroup=pktcInternationalGroup, pktcLLinePackageGroup=pktcLLinePackageGroup, pktcELinePackageGroup=pktcELinePackageGroup)

# Compliances
mibBuilder.exportSymbols("PKTC-IETF-SIG-MIB", pktcSigBasicCompliance=pktcSigBasicCompliance)
