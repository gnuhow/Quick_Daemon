# PySNMP SMI module. Autogenerated from smidump -f python DOT12-IF-MIB
# by libsmi2pysnmp-0.1.3 at Mon Apr  2 20:38:53 2012,
# Python version sys.version_info(major=2, minor=7, micro=2, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( ifIndex, ) = mibBuilder.importSymbols("IF-MIB", "ifIndex")
( ModuleCompliance, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup")
( Bits, Counter32, Counter64, Integer32, ModuleIdentity, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, transmission, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "Counter64", "Integer32", "ModuleIdentity", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "transmission")

# Objects

dot12MIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 10, 45)).setRevisions(("1996-02-22 04:52",))
if mibBuilder.loadTexts: dot12MIB.setOrganization("IETF 100VG-AnyLAN MIB Working Group")
if mibBuilder.loadTexts: dot12MIB.setContactInfo("       John Flick\n\nPostal: Hewlett Packard Company\n        8000 Foothills Blvd. M/S 5556\n        Roseville, CA 95747-5556\nTel:    +1 916 785 4018\nFax:    +1 916 785 3583\n\nE-mail: johnf@hprnd.rose.hp.com")
if mibBuilder.loadTexts: dot12MIB.setDescription("This MIB module describes objects for\nmanaging IEEE 802.12 interfaces.")
dot12MIBObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 45, 1))
dot12ConfigTable = MibTable((1, 3, 6, 1, 2, 1, 10, 45, 1, 1))
if mibBuilder.loadTexts: dot12ConfigTable.setDescription("Configuration information for a collection of\n802.12 interfaces attached to a particular\nsystem.")
dot12ConfigEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 45, 1, 1, 1)).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: dot12ConfigEntry.setDescription("Configuration for a particular interface to an\n802.12 medium.")
dot12CurrentFramingType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 45, 1, 1, 1, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(1,3,2,)).subtype(namedValues=NamedValues(("frameType88023", 1), ("frameType88025", 2), ("frameTypeUnknown", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12CurrentFramingType.setDescription("When dot12DesiredFramingType is one of\n'frameType88023' or 'frameType88025', this is the\ntype of framing asserted by the interface.\n\nWhen dot12DesiredFramingType is 'frameTypeEither',\ndot12CurrentFramingType shall be one of\n'frameType88023' or 'frameType88025' when the\ndot12Status is 'opened'.   When the dot12Status is\nanything other than 'opened',\ndot12CurrentFramingType shall take the value of\n'frameTypeUnknown'.")
dot12DesiredFramingType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 45, 1, 1, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(1,3,2,)).subtype(namedValues=NamedValues(("frameType88023", 1), ("frameType88025", 2), ("frameTypeEither", 3), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot12DesiredFramingType.setDescription("The type of framing which will be requested by\nthe interface during the next interface MAC\ninitialization or open action.\n\nIn master mode, this is the framing mode which\nwill be granted by the interface.  Note that\nfor a master mode interface, this object must be\nequal to 'frameType88023' or 'frameType88025',\nsince a master mode interface cannot grant\n'frameTypeEither'.")
dot12FramingCapability = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 45, 1, 1, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(1,3,2,)).subtype(namedValues=NamedValues(("frameType88023", 1), ("frameType88025", 2), ("frameTypeEither", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12FramingCapability.setDescription("The type of framing this interface is capable of\nsupporting.")
dot12DesiredPromiscStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 45, 1, 1, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("singleAddressMode", 1), ("promiscuousMode", 2), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot12DesiredPromiscStatus.setDescription("This object is used to select the promiscuous\nmode that this interface will request in the next\ntraining packet issued on this interface.\nWhether the repeater grants the requested mode\nmust be verified by examining the state of the PP\nbits in the corresponding instance of\ndot12LastTrainingConfig.\nIn master mode, this object controls whether or\nnot promiscuous mode will be granted by the\ninterface when requested by the lower level\ndevice.\n\nNote that this object indicates the desired mode\nfor the next time the interface trains.  The\ncurrently active mode will be reflected in\ndot12LastTrainingConfig and in ifPromiscuousMode.")
dot12TrainingVersion = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 45, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12TrainingVersion.setDescription("The value that will be used in the version bits\n(vvv bits) in training frames on this interface.\nThis is the highest version number supported by\nthis MAC.")
dot12LastTrainingConfig = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 45, 1, 1, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12LastTrainingConfig.setDescription("This 16 bit field contains the configuration\nbits from the most recent error-free training\nframe received during training on this interface.\nTraining request frames are received when in\nmaster mode, while training response frames are\nreceived in slave mode.  On master mode interfaces,\nthis object contains the contents of the\nrequested configuration field of the most recent\ntraining request frame.  On slave mode interfaces,\nthis object contains the contents of the allowed\nconfiguration field of the most recent training\nresponse frame.  The format of the current version\nof this field is described in section 3.8.  Please\nrefer to the most recent version of the IEEE\n802.12 standard for the most up-to-date definition\nof the format of this object.")
dot12Commands = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 45, 1, 1, 1, 7), Integer().subtype(subtypeSpec=SingleValueConstraint(3,2,1,4,)).subtype(namedValues=NamedValues(("noOp", 1), ("open", 2), ("reset", 3), ("close", 4), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot12Commands.setDescription("If the current value of dot12Status is 'closed',\nsetting the value of this object to 'open' will\nchange the corresponding instance of MIB-II's\nifAdminStatus to 'up', cause this interface to\nenter the 'opening' state, and will cause training\nto be initiated on this interface.  The progress\nand success of the open is given by the values of\nthe dot12Status object.  Setting this object to\n'open' when dot12Status has a value other than\n'closed' has no effect.\n\nSetting the corresponding instance of ifAdminStatus\nto 'up' when the current value of dot12Status is\n'closed' will have the same effect as setting this\nobject to 'open'.  Setting ifAdminStatus to 'up'\nwhen dot12Status has a value other than 'closed'\nhas no effect.\n\nSetting the value of this object to 'close' will\nmove this interface into the 'closed' state and\ncause all transmit and receive actions to stop.\nThis object will then have to be set to 'open' in\norder to reinitiate training.\n\nSetting the corresponding instance of ifAdminStatus\nto 'down' will have the same effect as setting this\nobject to 'close'.\n\nSetting the value of this object to 'reset' when\nthe current value of dot12Status has a value other\nthan 'closed' will reset the interface.  On a\nreset, all MIB counters should retain their values.\nThis will cause the MAC to initiate an\nacInitializeMAC action as specified in IEEE 802.12.\nThis will cause training to be reinitiated on this\ninterface.  Setting this object to 'reset' when\ndot12Status has a value of 'closed' has no effect.\nSetting this object to 'reset' has no effect on the\ncorresponding instance of ifAdminStatus.\n\nSetting the value of this object to 'noOp' has no\neffect.\n\nWhen read, this object will always have a value\nof 'noOp'.")
dot12Status = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 45, 1, 1, 1, 8), Integer().subtype(subtypeSpec=SingleValueConstraint(1,3,6,5,2,)).subtype(namedValues=NamedValues(("opened", 1), ("closed", 2), ("opening", 3), ("openFailure", 5), ("linkFailure", 6), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12Status.setDescription("The current interface status with respect to\ntraining.  One of the following values:\n\n    opened      - Training has completed\n                  successfully.\n    closed      - MAC has been disabled by\n                  setting dot12Commands to\n                  'close'.\n    opening     - MAC is in training.  Training\n                  signals have been received.\n    openFailure - Passed 24 error-free packets,\n                  but there is a problem, noted\n                  in the training configuration\n                  bits (dot12LastTrainingConfig).\n    linkFailure - Training signals not received,\n                  or could not pass 24 error-free\n                  packets.\nWhenever the dot12Commands object is set to\n'close' or ifAdminStatus is set to 'down', the MAC\nwill go silent, dot12Status will be 'closed', and\nifOperStatus will be 'down'.\n\nWhen the value of this object is equal to 'closed'\nand the dot12Commands object is set to 'open' or\nthe ifAdminStatus object is set to 'up', training\nwill be initiated on this interface.  When the\nvalue of this object is not equal to 'closed' and\nthe dot12Commands object is set to 'reset',\ntraining will be reinitiated on this interface.\nNote that sets of some other objects (e.g.\ndot12ControlMode) or external events (e.g. MAC\nprotocol violations) may also cause training to be\nreinitiated on this interface.\n\nWhen training is initiated or reinitiated on an\ninterface, the end node will send Training_Up to\nthe master and initially go to the 'linkFailure'\nstate and ifOperStatus will go to 'down'.\nWhen the master sends back Training_Down,\ndot12Status will change to the 'opening' state,\nand training packets will be transferred.\n\nAfter all of the training packets have been\npassed, dot12Status will change to 'linkFailure'\nif 24 consecutive error-free packets were not\npassed, 'opened' if 24 consecutive error-free\npackets were passed and the training\nconfiguration bits were OK, or 'openFailure' if\nthere were 24 consecutive error-free packets, but\nthere was a problem with the training\nconfiguration bits.\n\nWhen in the 'openFailure' state, the\ndot12LastTrainingConfig object will contain the\nconfiguration bits from the last training\npacket which can be examined to determine the\nexact reason for the training configuration\nfailure.\n\nIf training did not succeed (dot12Status is\n'linkFailure' or 'openFailure), the entire\nprocess will be restarted after\nMAC_Retraining_Delay_Timer seconds.\n\nIf training does succeed (dot12Status changes to\n'opened'), ifOperStatus will change to 'up'.  If\ntraining does not succeed (dot12Status changes to\n'linkFailure' or 'openFailure'), ifOperStatus will\nremain 'down'.")
dot12ControlMode = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 45, 1, 1, 1, 9), Integer().subtype(subtypeSpec=SingleValueConstraint(2,3,1,)).subtype(namedValues=NamedValues(("masterMode", 1), ("slaveMode", 2), ("learn", 3), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot12ControlMode.setDescription("This object is used to configure and report\nwhether or not this interface is operating in\nmaster mode.  In a Demand Priority network, end\nnode interfaces typically operate in slave mode,\nwhile switch interfaces may control the Demand\nPriority protocol and operate in master mode.\n\nThis object may be implemented as a read-only\nobject by those agents and interfaces that do not\nimplement software control of master mode.  In\nparticular, interfaces that cannot operate in\nmaster mode, and interfaces on which master mode\nis controlled by a pushbutton on the device,\nshould implement this object read-only.\n\nSome interfaces do not require network management\nconfiguration of this feature and can autosense\nwhether to use master mode or slave mode.  The\nvalue 'learn' is used for that purpose.  While\nautosense is taking place, the value 'learn' is\nreturned.\n\nA network management operation which modifies the\nvalue of dot12ControlMode causes the interface\nto retrain.")
dot12StatTable = MibTable((1, 3, 6, 1, 2, 1, 10, 45, 1, 2))
if mibBuilder.loadTexts: dot12StatTable.setDescription("Statistics for a collection of 802.12 interfaces\nattached to a particular system.")
dot12StatEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 45, 1, 2, 1)).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: dot12StatEntry.setDescription("Statistics for a particular interface to an\n802.12 medium.  The receive statistics in this\ntable apply only to packets received by this\nstation (i.e., packets whose destination address\nis either the local station address, the\nbroadcast address, or a multicast address that\nthis station is receiving, unless the station is\nin promiscuous mode).")
dot12InHighPriorityFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 45, 1, 2, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12InHighPriorityFrames.setDescription("This object is a count of high priority frames\nthat have been received on this interface.\nIncludes both good and bad high priority frames,\nas well as high priority training frames.  Does\nnot include normal priority frames which were\npriority promoted.")
dot12InHighPriorityOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 45, 1, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12InHighPriorityOctets.setDescription("This object is a count of the number of octets\ncontained in high priority frames that have been\nreceived on this interface. This counter is\nincremented by OctetCount for each frame received\non this interface which is counted by\ndot12InHighPriorityFrames.\n\nNote that this counter will roll over very\nquickly.  It is provided for backward\ncompatibility for Network Management protocols\nthat do not support 64 bit counters (e.g. SNMP\nversion 1).")
dot12InNormPriorityFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 45, 1, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12InNormPriorityFrames.setDescription("This object is a count of normal priority frames\nthat have been received on this interface.\nIncludes both good and bad normal priority\nframes, as well as normal priority training\nframes and normal priority frames which were\npriority promoted.")
dot12InNormPriorityOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 45, 1, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12InNormPriorityOctets.setDescription("This object is a count of the number of octets\ncontained in normal priority frames that have\nbeen received on this interface. This counter is\nincremented by OctetCount for each frame received\non this interface which is counted by\ndot12InNormPriorityFrames.\n\nNote that this counter will roll over very\nquickly.  It is provided for backward\ncompatibility for Network Management protocols\nthat do not support 64 bit counters (e.g. SNMP\nversion 1).")
dot12InIPMErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 45, 1, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12InIPMErrors.setDescription("This object is a count of the number of frames\nthat have been received on this interface with an\ninvalid packet marker and no PMI errors.  A\nrepeater will write an invalid packet marker to\nthe end of a frame containing errors as it is\nforwarded through the repeater to the other\nports.  This counter is incremented by one for\neach frame received on this interface which has\nhad an invalid packet marker added to the end of\nthe frame.")
dot12InOversizeFrameErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 45, 1, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12InOversizeFrameErrors.setDescription("This object is a count of oversize frames\nreceived on this interface.  This counter is\nincremented by one for each frame received on\nthis interface whose OctetCount is larger than\nthe maximum legal frame size.  The frame size\nwhich causes this counter to increment is\ndependent on the current framing type.")
dot12InDataErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 45, 1, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12InDataErrors.setDescription("This object is a count of errored frames\nreceived on this interface.  This counter is\nincremented by one for each frame received on\nthis interface with any of the following errors:\nbad FCS (with no IPM), PMI errors (excluding\nframes with an IPM as the only PMI error),\nundersize, bad start of frame delimiter, or bad\nend of packet marker.  Does not include frames\ncounted by dot12InIPMErrors,\ndot12InNullAddressedFrames, or\ndot12InOversizeFrameErrors.\n\nThis counter indicates problems with the cable\ndirectly attached to this interface, while\ndot12InIPMErrors indicates problems with remote\ncables.")
dot12InNullAddressedFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 45, 1, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12InNullAddressedFrames.setDescription("This object is a count of null addressed frames\nreceived on this interface.  This counter is\nincremented by one for each frame received on\nthis interface with a destination MAC address\nconsisting of all zero bits.  Both void and\ntraining frames are included in this counter.\n\nNote that since this station would normally not\nreceive null addressed frames, this counter is\nonly incremented when this station is operating\nin promiscuous mode or in training.")
dot12OutHighPriorityFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 45, 1, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12OutHighPriorityFrames.setDescription("This counter is incremented by one for each high\npriority frame successfully transmitted out this\ninterface.")
dot12OutHighPriorityOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 45, 1, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12OutHighPriorityOctets.setDescription("This counter is incremented by OctetCount for\neach frame counted by dot12OutHighPriorityFrames.\n\nNote that this counter will roll over very\nquickly.  It is provided for backward\ncompatibility for Network Management protocols\nthat do not support 64 bit counters (e.g. SNMP\nversion 1).")
dot12TransitionIntoTrainings = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 45, 1, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12TransitionIntoTrainings.setDescription("This object is a count of the number of times\nthis interface has entered the training state.\nThis counter is incremented by one each time\ndot12Status transitions to 'linkFailure' from any\nstate other than 'opening' or 'openFailure'.")
dot12HCInHighPriorityOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 45, 1, 2, 1, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12HCInHighPriorityOctets.setDescription("This object is a count of the number of octets\ncontained in high priority frames that have been\nreceived on this interface. This counter is\nincremented by OctetCount for each frame received\non this interface which is counted by\ndot12InHighPriorityFrames.\n\nThis counter is a 64 bit version of\ndot12InHighPriorityOctets.  It should be used by\nNetwork Management protocols which support 64 bit\ncounters (e.g. SNMPv2).")
dot12HCInNormPriorityOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 45, 1, 2, 1, 13), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12HCInNormPriorityOctets.setDescription("This object is a count of the number of octets\ncontained in normal priority frames that have\nbeen received on this interface. This counter is\nincremented by OctetCount for each frame received\non this interface which is counted by\ndot12InNormPriorityFrames.\n\nThis counter is a 64 bit version of\ndot12InNormPriorityOctets.  It should be used by\nNetwork Management protocols which support 64 bit\ncounters (e.g. SNMPv2).")
dot12HCOutHighPriorityOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 45, 1, 2, 1, 14), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12HCOutHighPriorityOctets.setDescription("This counter is incremented by OctetCount for\neach frame counted by dot12OutHighPriorityFrames.\n\nThis counter is a 64 bit version of\ndot12OutHighPriorityOctets.  It should be used by\nNetwork Management protocols which support 64 bit\ncounters (e.g. SNMPv2).")
dot12Conformance = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 45, 2))
dot12Compliances = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 45, 2, 1))
dot12Groups = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 45, 2, 2))

# Augmentions

# Groups

dot12ConfigGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 45, 2, 2, 1)).setObjects(*(("DOT12-IF-MIB", "dot12Status"), ("DOT12-IF-MIB", "dot12FramingCapability"), ("DOT12-IF-MIB", "dot12DesiredFramingType"), ("DOT12-IF-MIB", "dot12CurrentFramingType"), ("DOT12-IF-MIB", "dot12ControlMode"), ("DOT12-IF-MIB", "dot12Commands"), ("DOT12-IF-MIB", "dot12DesiredPromiscStatus"), ("DOT12-IF-MIB", "dot12TrainingVersion"), ("DOT12-IF-MIB", "dot12LastTrainingConfig"), ) )
if mibBuilder.loadTexts: dot12ConfigGroup.setDescription("A collection of objects for managing the status\nand configuration of IEEE 802.12 interfaces.")
dot12StatsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 45, 2, 2, 2)).setObjects(*(("DOT12-IF-MIB", "dot12HCInHighPriorityOctets"), ("DOT12-IF-MIB", "dot12InOversizeFrameErrors"), ("DOT12-IF-MIB", "dot12InHighPriorityOctets"), ("DOT12-IF-MIB", "dot12OutHighPriorityOctets"), ("DOT12-IF-MIB", "dot12InNullAddressedFrames"), ("DOT12-IF-MIB", "dot12HCInNormPriorityOctets"), ("DOT12-IF-MIB", "dot12OutHighPriorityFrames"), ("DOT12-IF-MIB", "dot12InDataErrors"), ("DOT12-IF-MIB", "dot12InIPMErrors"), ("DOT12-IF-MIB", "dot12HCOutHighPriorityOctets"), ("DOT12-IF-MIB", "dot12InNormPriorityFrames"), ("DOT12-IF-MIB", "dot12TransitionIntoTrainings"), ("DOT12-IF-MIB", "dot12InHighPriorityFrames"), ("DOT12-IF-MIB", "dot12InNormPriorityOctets"), ) )
if mibBuilder.loadTexts: dot12StatsGroup.setDescription("A collection of objects providing statistics for\nIEEE 802.12 interfaces.")

# Compliances

dot12Compliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 45, 2, 1, 1)).setObjects(*(("DOT12-IF-MIB", "dot12StatsGroup"), ("DOT12-IF-MIB", "dot12ConfigGroup"), ) )
if mibBuilder.loadTexts: dot12Compliance.setDescription("The compliance statement for managed network\nentities that have 802.12 interfaces.")

# Exports

# Module identity
mibBuilder.exportSymbols("DOT12-IF-MIB", PYSNMP_MODULE_ID=dot12MIB)

# Objects
mibBuilder.exportSymbols("DOT12-IF-MIB", dot12MIB=dot12MIB, dot12MIBObjects=dot12MIBObjects, dot12ConfigTable=dot12ConfigTable, dot12ConfigEntry=dot12ConfigEntry, dot12CurrentFramingType=dot12CurrentFramingType, dot12DesiredFramingType=dot12DesiredFramingType, dot12FramingCapability=dot12FramingCapability, dot12DesiredPromiscStatus=dot12DesiredPromiscStatus, dot12TrainingVersion=dot12TrainingVersion, dot12LastTrainingConfig=dot12LastTrainingConfig, dot12Commands=dot12Commands, dot12Status=dot12Status, dot12ControlMode=dot12ControlMode, dot12StatTable=dot12StatTable, dot12StatEntry=dot12StatEntry, dot12InHighPriorityFrames=dot12InHighPriorityFrames, dot12InHighPriorityOctets=dot12InHighPriorityOctets, dot12InNormPriorityFrames=dot12InNormPriorityFrames, dot12InNormPriorityOctets=dot12InNormPriorityOctets, dot12InIPMErrors=dot12InIPMErrors, dot12InOversizeFrameErrors=dot12InOversizeFrameErrors, dot12InDataErrors=dot12InDataErrors, dot12InNullAddressedFrames=dot12InNullAddressedFrames, dot12OutHighPriorityFrames=dot12OutHighPriorityFrames, dot12OutHighPriorityOctets=dot12OutHighPriorityOctets, dot12TransitionIntoTrainings=dot12TransitionIntoTrainings, dot12HCInHighPriorityOctets=dot12HCInHighPriorityOctets, dot12HCInNormPriorityOctets=dot12HCInNormPriorityOctets, dot12HCOutHighPriorityOctets=dot12HCOutHighPriorityOctets, dot12Conformance=dot12Conformance, dot12Compliances=dot12Compliances, dot12Groups=dot12Groups)

# Groups
mibBuilder.exportSymbols("DOT12-IF-MIB", dot12ConfigGroup=dot12ConfigGroup, dot12StatsGroup=dot12StatsGroup)

# Compliances
mibBuilder.exportSymbols("DOT12-IF-MIB", dot12Compliance=dot12Compliance)
