# PySNMP SMI module. Autogenerated from smidump -f python ATM-MIB
# by libsmi2pysnmp-0.1.3 at Mon Apr  2 20:38:43 2012,
# Python version sys.version_info(major=2, minor=7, micro=2, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( AtmAddr, AtmConnCastType, AtmConnKind, AtmServiceCategory, AtmTrafficDescrParamIndex, AtmVcIdentifier, AtmVorXAdminStatus, AtmVorXLastChange, AtmVorXOperStatus, AtmVpIdentifier, atmNoClpNoScr, ) = mibBuilder.importSymbols("ATM-TC-MIB", "AtmAddr", "AtmConnCastType", "AtmConnKind", "AtmServiceCategory", "AtmTrafficDescrParamIndex", "AtmVcIdentifier", "AtmVorXAdminStatus", "AtmVorXLastChange", "AtmVorXOperStatus", "AtmVpIdentifier", "atmNoClpNoScr")
( InterfaceIndex, ifIndex, ) = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex", "ifIndex")
( ModuleCompliance, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup")
( Bits, Counter32, Integer32, Integer32, IpAddress, ModuleIdentity, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, mib_2, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "Integer32", "Integer32", "IpAddress", "ModuleIdentity", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "mib-2")
( DisplayString, RowStatus, TruthValue, ) = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "RowStatus", "TruthValue")

# Objects

atmMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 37)).setRevisions(("1998-10-19 12:00","1994-06-07 22:45",))
if mibBuilder.loadTexts: atmMIB.setOrganization("IETF AToM MIB Working Group")
if mibBuilder.loadTexts: atmMIB.setContactInfo("          Kaj Tesink\nPostal:  Bellcore\n         331 Newman Springs Road\n         Red Bank, NJ 07701\nTel:     732-758-5254\nFax:     732-758-2269\nE-mail:  kaj@bellcore.com")
if mibBuilder.loadTexts: atmMIB.setDescription("This is the MIB Module for ATM and AAL5-related\nobjects for managing ATM interfaces, ATM virtual\nlinks, ATM cross-connects, AAL5 entities, and\nand AAL5 connections.")
atmMIBObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 37, 1))
atmInterfaceConfTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 2))
if mibBuilder.loadTexts: atmInterfaceConfTable.setDescription("This table contains ATM local interface\nconfiguration parameters, one entry per ATM\ninterface port.")
atmInterfaceConfEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 2, 1)).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: atmInterfaceConfEntry.setDescription("This list contains ATM interface configuration\nparameters and state variables and is indexed\nby ifIndex values of ATM interfaces.")
atmInterfaceMaxVpcs = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmInterfaceMaxVpcs.setDescription("The maximum number of VPCs (PVPCs and SVPCs)\nsupported at this ATM interface. At the ATM UNI,\nthe maximum number of VPCs (PVPCs and SVPCs)\nranges from 0 to 256 only.")
atmInterfaceMaxVccs = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmInterfaceMaxVccs.setDescription("The maximum number of VCCs (PVCCs and SVCCs)\nsupported at this ATM interface.")
atmInterfaceConfVpcs = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmInterfaceConfVpcs.setDescription("The number of VPCs (PVPC, Soft PVPC and SVPC)\ncurrently in use at this ATM interface.  It includes\nthe number of PVPCs and Soft PVPCs that are configured\nat the interface, plus the number of SVPCs\nthat are currently  established at the\ninterface.\n\nAt the ATM UNI, the configured number of\nVPCs (PVPCs and SVPCs) can range from\n0 to 256 only.")
atmInterfaceConfVccs = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmInterfaceConfVccs.setDescription("The number of VCCs (PVCC, Soft PVCC and SVCC)\ncurrently in use at this ATM interface.  It includes\nthe number of PVCCs and Soft PVCCs that are configured\nat the interface, plus the number of SVCCs\nthat are currently  established at the\ninterface.")
atmInterfaceMaxActiveVpiBits = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmInterfaceMaxActiveVpiBits.setDescription("The  maximum number of active VPI bits\nconfigured for use at the ATM interface.\nAt the ATM UNI, the maximum number of active\nVPI bits configured for use ranges from\n0 to 8 only.")
atmInterfaceMaxActiveVciBits = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmInterfaceMaxActiveVciBits.setDescription("The maximum number of active VCI bits\nconfigured for use at this ATM interface.")
atmInterfaceIlmiVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 2, 1, 7), AtmVpIdentifier().clone('0')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmInterfaceIlmiVpi.setDescription("The VPI value of the VCC supporting\nthe ILMI at this ATM interface.  If the values of\natmInterfaceIlmiVpi and atmInterfaceIlmiVci are\nboth equal to zero then the ILMI is not\nsupported at this ATM interface.")
atmInterfaceIlmiVci = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 2, 1, 8), AtmVcIdentifier().clone('16')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmInterfaceIlmiVci.setDescription("The VCI value of the VCC supporting\nthe ILMI at this ATM interface.  If the values of\natmInterfaceIlmiVpi and atmInterfaceIlmiVci are\nboth equal to zero then the ILMI is not\nsupported at this ATM interface.")
atmInterfaceAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 2, 1, 9), Integer().subtype(subtypeSpec=SingleValueConstraint(2,3,4,1,)).subtype(namedValues=NamedValues(("private", 1), ("nsapE164", 2), ("nativeE164", 3), ("other", 4), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmInterfaceAddressType.setDescription("The type of primary ATM address configured\nfor use at this ATM interface.")
atmInterfaceAdminAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 2, 1, 10), AtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmInterfaceAdminAddress.setDescription("The primary address assigned for administrative purposes,\nfor example, an address associated with the\nservice provider side of a public network UNI\n(thus, the value of this address corresponds\nwith the value of ifPhysAddress at the host side).\nIf this interface has no assigned administrative\naddress, or when the address used for\nadministrative purposes is the same as that used\nfor ifPhysAddress, then this is an octet string of\nzero length.")
atmInterfaceMyNeighborIpAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 2, 1, 11), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmInterfaceMyNeighborIpAddress.setDescription("The IP address of the neighbor system connected to\nthe  far end of this interface, to which a Network\nManagement Station can send SNMP messages, as IP\ndatagrams sent to UDP port 161, in order to access\nnetwork management information concerning the\noperation of that system.  Note that the value\nof this object may be obtained in different ways,\ne.g., by manual configuration, or through ILMI\ninteraction with the neighbor system.")
atmInterfaceMyNeighborIfName = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 2, 1, 12), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmInterfaceMyNeighborIfName.setDescription("The textual name of the interface on the neighbor\nsystem on the far end of this interface, and to\nwhich this interface connects.  If the neighbor\nsystem is manageable through SNMP and supports\nthe object ifName, the value of this object must\nbe identical with that of ifName for the ifEntry\nof the lowest level physical interface\nfor this port.  If this interface does not have a\ntextual name, the value of this object is a zero\nlength string.  Note that the value of this object\nmay be obtained in different ways, e.g., by manual\nconfiguration, or through ILMI interaction with\nthe neighbor system.")
atmInterfaceCurrentMaxVpiBits = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmInterfaceCurrentMaxVpiBits.setDescription("The maximum number of VPI Bits that may\ncurrently be used at this ATM interface.\nThe value is the minimum of\natmInterfaceMaxActiveVpiBits, and the\natmInterfaceMaxActiveVpiBits of the interface's\nUNI/NNI peer.\n\nIf the interface does not negotiate with\nits peer to determine the number of VPI Bits\nthat can be used on the interface, then the\nvalue of this object must equal\natmInterfaceMaxActiveVpiBits.")
atmInterfaceCurrentMaxVciBits = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 2, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmInterfaceCurrentMaxVciBits.setDescription("The maximum number of VCI Bits that may\ncurrently be used at this ATM interface.\nThe value is the minimum of\natmInterfaceMaxActiveVciBits, and the\natmInterfaceMaxActiveVciBits of the interface's\nUNI/NNI peer.\n\nIf the interface does not negotiate with\nits peer to determine the number of VCI Bits\nthat can be used on the interface, then the\nvalue of this object must equal\natmInterfaceMaxActiveVciBits.")
atmInterfaceSubscrAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 2, 1, 15), AtmAddr()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmInterfaceSubscrAddress.setDescription("The identifier assigned by a service provider\nto the network side of a public network UNI.\nIf this interface has no assigned service provider\naddress, or for other interfaces this is an octet string\nof zero length.")
atmInterfaceDs3PlcpTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 3))
if mibBuilder.loadTexts: atmInterfaceDs3PlcpTable.setDescription("This table contains ATM interface DS3 PLCP\nparameters and state variables, one entry per\nATM interface port.")
atmInterfaceDs3PlcpEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 3, 1)).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: atmInterfaceDs3PlcpEntry.setDescription("This list contains DS3 PLCP parameters and\nstate variables at the ATM interface and is\nindexed by the ifIndex value of the ATM interface.")
atmInterfaceDs3PlcpSEFSs = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 3, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmInterfaceDs3PlcpSEFSs.setDescription("The number of DS3 PLCP Severely Errored Framing\nSeconds (SEFS). Each SEFS represents a\none-second interval which contains\none or more SEF events.")
atmInterfaceDs3PlcpAlarmState = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 3, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(3,1,2,)).subtype(namedValues=NamedValues(("noAlarm", 1), ("receivedFarEndAlarm", 2), ("incomingLOF", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmInterfaceDs3PlcpAlarmState.setDescription("This variable indicates if there is an\nalarm present for the DS3 PLCP.  The value\nreceivedFarEndAlarm means that the DS3 PLCP\nhas received an incoming Yellow\nSignal, the value incomingLOF means that\nthe DS3 PLCP has declared a loss of frame (LOF)\nfailure condition, and the value noAlarm\nmeans that there are no alarms present.\nTransition from the failure to the no alarm state\noccurs when no defects (e.g., LOF) are received\nfor more than 10 seconds.")
atmInterfaceDs3PlcpUASs = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmInterfaceDs3PlcpUASs.setDescription("The counter associated with the number of\nUnavailable Seconds encountered by the PLCP.")
atmInterfaceTCTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 4))
if mibBuilder.loadTexts: atmInterfaceTCTable.setDescription("This table contains ATM interface TC\nSublayer parameters and state variables,\none entry per ATM interface port.")
atmInterfaceTCEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 4, 1)).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: atmInterfaceTCEntry.setDescription("This list contains TC Sublayer parameters\nand state variables at the ATM interface and is\nindexed by the ifIndex value of the ATM interface.")
atmInterfaceOCDEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 4, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmInterfaceOCDEvents.setDescription("The number of times the Out of Cell\nDelineation (OCD) events occur.  If seven\nconsecutive ATM cells have Header Error\nControl (HEC) violations, an OCD event occurs.\nA high number of OCD events may indicate a\nproblem with the TC Sublayer.")
atmInterfaceTCAlarmState = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 4, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("noAlarm", 1), ("lcdFailure", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmInterfaceTCAlarmState.setDescription("This variable indicates if there is an\nalarm present for the TC Sublayer.  The value\nlcdFailure(2) indicates that the TC Sublayer\nis currently in the Loss of Cell Delineation\n(LCD) defect maintenance state.  The value\nnoAlarm(1) indicates that the TC Sublayer\nis currently not in the LCD defect\nmaintenance state.")
atmTrafficDescrParamTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 5))
if mibBuilder.loadTexts: atmTrafficDescrParamTable.setDescription("This table contains information on ATM traffic\ndescriptor type and the associated parameters.")
atmTrafficDescrParamEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 5, 1)).setIndexNames((0, "ATM-MIB", "atmTrafficDescrParamIndex"))
if mibBuilder.loadTexts: atmTrafficDescrParamEntry.setDescription("This list contains ATM traffic descriptor\ntype and the associated parameters.")
atmTrafficDescrParamIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 5, 1, 1), AtmTrafficDescrParamIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: atmTrafficDescrParamIndex.setDescription("This object is used by the virtual link\ntable (i.e., VPL or VCL table)\nto identify the row of this table.\nWhen creating a new row in the table\nthe value of this index may be obtained\nby retrieving the value of\natmTrafficDescrParamIndexNext.")
atmTrafficDescrType = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 5, 1, 2), ObjectIdentifier().clone((1, 3, 6, 1, 2, 1, 37, 1, 1, 2))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTrafficDescrType.setDescription("The value of this object identifies the type\nof ATM traffic descriptor.\nThe type may indicate no traffic descriptor or\ntraffic descriptor with one or more parameters.\nThese parameters are specified as a parameter\nvector, in the corresponding instances of the\nobjects:\n    atmTrafficDescrParam1\n    atmTrafficDescrParam2\n    atmTrafficDescrParam3\n    atmTrafficDescrParam4\n    atmTrafficDescrParam5.")
atmTrafficDescrParam1 = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 5, 1, 3), Integer32().clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTrafficDescrParam1.setDescription("The first parameter of the ATM traffic descriptor\nused according to the value of\natmTrafficDescrType.")
atmTrafficDescrParam2 = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 5, 1, 4), Integer32().clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTrafficDescrParam2.setDescription("The second parameter of the ATM traffic descriptor\nused according to the value of\natmTrafficDescrType.")
atmTrafficDescrParam3 = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 5, 1, 5), Integer32().clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTrafficDescrParam3.setDescription("The third parameter of the ATM traffic descriptor\nused according to the value of\natmTrafficDescrType.")
atmTrafficDescrParam4 = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 5, 1, 6), Integer32().clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTrafficDescrParam4.setDescription("The fourth parameter of the ATM traffic descriptor\nused according to the value of\natmTrafficDescrType.")
atmTrafficDescrParam5 = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 5, 1, 7), Integer32().clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTrafficDescrParam5.setDescription("The fifth parameter of the ATM traffic descriptor\nused according to the value of\natmTrafficDescrType.")
atmTrafficQoSClass = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 5, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTrafficQoSClass.setDescription("The value of this object identifies the QoS Class.\nFour Service classes have been\nspecified in the ATM Forum UNI Specification:\nService Class A: Constant bit rate video and\n                 Circuit emulation\nService Class B: Variable bit rate video/audio\nService Class C: Connection-oriented data\nService Class D: Connectionless data\nFour QoS classes numbered 1, 2, 3, and 4 have\nbeen specified with the aim to support service\nclasses A, B, C, and D respectively.\nAn unspecified QoS Class numbered `0' is used\nfor best effort traffic.")
atmTrafficDescrRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 5, 1, 9), RowStatus('active')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTrafficDescrRowStatus.setDescription("This object is used to create\na new row or modify or delete an\nexisting row in this table.")
atmServiceCategory = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 5, 1, 10), AtmServiceCategory().clone('ubr')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmServiceCategory.setDescription("The ATM service category.")
atmTrafficFrameDiscard = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 5, 1, 11), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTrafficFrameDiscard.setDescription("If set to 'true', this object indicates that the network\nis requested to treat data for this connection, in the\ngiven direction, as frames (e.g. AAL5 CPCS_PDU's) rather\nthan as individual cells.  While the precise\nimplementation is network-specific, this treatment may\nfor example involve discarding entire frames during\ncongestion, rather than a few cells from many frames.")
atmVplTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 6))
if mibBuilder.loadTexts: atmVplTable.setDescription("The Virtual Path Link (VPL) table.  A\nbi-directional VPL is modeled as one entry\nin this table. This table can be used for\nPVCs, SVCs and Soft PVCs.\nEntries are not present in this table for\nthe VPIs used by entries in the atmVclTable.")
atmVplEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 6, 1)).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVplVpi"))
if mibBuilder.loadTexts: atmVplEntry.setDescription("An entry in the VPL table.  This entry is\nused to model a bi-directional VPL.\nTo create a VPL at an ATM interface,\neither of the following procedures are used:\n\nNegotiated VPL establishment\n\n(1) The management application creates\n  a VPL entry in the atmVplTable\n  by setting atmVplRowStatus to createAndWait(5).\n  This may fail for the following reasons:\n  - The selected VPI value is unavailable,\n  - The selected VPI value is in use.\n  Otherwise, the agent creates a row and\n  reserves the VPI value on that port.\n\n(2) The manager selects an existing row(s) in the\n  atmTrafficDescrParamTable,\n  thereby, selecting a set of self-consistent\n  ATM traffic parameters and the service category\n  for receive and transmit directions of the VPL.\n\n(2a) If no suitable row(s) in the\n  atmTrafficDescrParamTable exists,\n  the manager must create a new row(s)\n  in that table.\n\n(2b) The manager characterizes the VPL's traffic\n  parameters through setting the\n  atmVplReceiveTrafficDescrIndex and the\n  atmVplTransmitTrafficDescrIndex values\n  in the VPL table, which point to the rows\n  containing desired ATM traffic parameter values\n  in the atmTrafficDescrParamTable.  The agent\n  will check the availability of resources and\n  may refuse the request.\n  If the transmit and receive service categories\n  are inconsistent, the agent should refuse the\n  request.\n\n(3) The manager activates the VPL by setting the\n  the atmVplRowStatus to active(1).\n  If this set is successful, the agent has\n  reserved the resources to satisfy the requested\n  traffic parameter values and the service category\n  for that VPL.\n\n(4) If the VPL terminates a VPC in the ATM host\n  or switch, the manager turns on the\n  atmVplAdminStatus to up(1) to turn the VPL\n  traffic flow on.  Otherwise, the\n  atmVpCrossConnectTable  must be used\n  to cross-connect the VPL to another VPL(s)\n  in an ATM switch or network.\n\nOne-Shot VPL Establishment\n\nA VPL may also be established in one step by a\nset-request with all necessary VPL parameter\nvalues and atmVplRowStatus set to createAndGo(4).\n\nIn contrast to the negotiated VPL establishment\nwhich allows for detailed error checking\n(i.e., set errors are explicitly linked to\nparticular resource acquisition failures),\nthe one-shot VPL establishment\nperforms the setup on one operation but\ndoes not have the advantage of step-wise\nerror checking.\n\nVPL Retirement\n\nA VPL is released by setting atmVplRowStatus to\ndestroy(6), and the agent may release all\nassociated resources.")
atmVplVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 6, 1, 1), AtmVpIdentifier()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: atmVplVpi.setDescription("The VPI value of the VPL.")
atmVplAdminStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 6, 1, 2), AtmVorXAdminStatus().clone('down')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVplAdminStatus.setDescription("This object is instanciated only for a VPL\nwhich terminates a VPC (i.e., one which is\nNOT cross-connected to other VPLs).\nIts value specifies the desired\nadministrative state of the VPL.")
atmVplOperStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 6, 1, 3), AtmVorXOperStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVplOperStatus.setDescription("The current operational status of the VPL.")
atmVplLastChange = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 6, 1, 4), AtmVorXLastChange()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVplLastChange.setDescription("The value of sysUpTime at the time this\nVPL entered its current operational state.")
atmVplReceiveTrafficDescrIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 6, 1, 5), AtmTrafficDescrParamIndex().clone('0')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVplReceiveTrafficDescrIndex.setDescription("The value of this object identifies the row\nin the atmTrafficDescrParamTable which\napplies to the receive direction of the VPL.")
atmVplTransmitTrafficDescrIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 6, 1, 6), AtmTrafficDescrParamIndex().clone('0')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVplTransmitTrafficDescrIndex.setDescription("The value of this object identifies the row\nin the atmTrafficDescrParamTable which\napplies to the transmit direction of the VPL.")
atmVplCrossConnectIdentifier = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 6, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVplCrossConnectIdentifier.setDescription("This object is instantiated only for a VPL\nwhich is cross-connected to other VPLs\nthat belong to the same VPC.  All such\nassociated VPLs have the same value of this\nobject, and all their cross-connections are\nidentified either by entries that are indexed\nby the same value of atmVpCrossConnectIndex in\nthe atmVpCrossConnectTable of this MIB module or by\nthe same value of the cross-connect index in\nthe cross-connect table for SVCs and Soft PVCs\n(defined in a separate MIB module).\nAt no time should entries in these respective\ncross-connect tables exist simultaneously\nwith the same cross-connect index value.\nThe value of this object is initialized by the\nagent after the associated entries in the\natmVpCrossConnectTable have been created.")
atmVplRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 6, 1, 8), RowStatus('createAndWait')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVplRowStatus.setDescription("This object is used to create, delete\nor modify a row in this table.\nTo create a new VCL, this object is\ninitially set to 'createAndWait' or\n'createAndGo'.  This object should not be\nset to 'active' unless the following columnar\nobjects have been set to their desired value\nin this row:\natmVplReceiveTrafficDescrIndex and\natmVplTransmitTrafficDescrIndex.\nThe DESCRIPTION of atmVplEntry provides\nfurther guidance to row treatment in this table.")
atmVplCastType = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 6, 1, 9), AtmConnCastType().clone('p2p')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVplCastType.setDescription("The connection topology type.")
atmVplConnKind = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 6, 1, 10), AtmConnKind().clone('pvc')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVplConnKind.setDescription("The use of call control.")
atmVclTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 7))
if mibBuilder.loadTexts: atmVclTable.setDescription("The Virtual Channel Link (VCL) table.  A\nbi-directional VCL is modeled as one entry\nin this table. This table can be used for\nPVCs, SVCs and Soft PVCs.")
atmVclEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 7, 1)).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVclVpi"), (0, "ATM-MIB", "atmVclVci"))
if mibBuilder.loadTexts: atmVclEntry.setDescription("An entry in the VCL table. This entry is\nused to model a bi-directional VCL.\nTo create a VCL at an ATM interface,\neither of the following procedures are used:\n\nNegotiated VCL establishment\n\n(1) The management application creates\n  a VCL entry in the atmVclTable\n  by setting atmVclRowStatus to createAndWait(5).\n  This may fail for the following reasons:\n  - The selected VPI/VCI values are unavailable,\n  - The selected VPI/VCI values are in use.\n  Otherwise, the agent creates a row and\n  reserves the VPI/VCI values on that port.\n\n(2) The manager selects an existing row(s) in the\n  atmTrafficDescrParamTable,\n  thereby, selecting a set of self-consistent\n  ATM traffic parameters and the service category\n  for receive and transmit directions of the VCL.\n(2a) If no suitable row(s) in the\n  atmTrafficDescrParamTable exists,\n  the manager must create a new row(s)\n  in that table.\n\n(2b) The manager characterizes the VCL's traffic\n  parameters through setting the\n  atmVclReceiveTrafficDescrIndex and the\n  atmVclTransmitTrafficDescrIndex values\n  in the VCL table, which point to the rows\n  containing desired ATM traffic parameter values\n  in the atmTrafficDescrParamTable.  The agent\n  will check the availability of resources and\n  may refuse the request.\n  If the transmit and receive service categories\n  are inconsistent, the agent should refuse the\n  request.\n\n(3) The manager activates the VCL by setting the\n  the atmVclRowStatus to active(1) (for\n  requirements on this activation see the\n  description of atmVclRowStatus).\n  If this set is successful, the agent has\n  reserved the resources to satisfy the requested\n  traffic parameter values and the service category\n  for that VCL.\n(4) If the VCL terminates a VCC in the ATM host\n  or switch, the manager turns on the\n  atmVclAdminStatus to up(1) to turn the VCL\n  traffic flow on.  Otherwise, the\n  atmVcCrossConnectTable  must be used\n  to cross-connect the VCL to another VCL(s)\n  in an ATM switch or network.\n\nOne-Shot VCL Establishment\n\nA VCL may also be established in one step by a\nset-request with all necessary VCL parameter\nvalues and atmVclRowStatus set to createAndGo(4).\n\nIn contrast to the negotiated VCL establishment\nwhich allows for detailed error checking\n(i.e., set errors are explicitly linked to\nparticular resource acquisition failures),\nthe one-shot VCL establishment\nperforms the setup on one operation but\ndoes not have the advantage of step-wise\nerror checking.\nVCL Retirement\n\nA VCL is released by setting atmVclRowStatus to\ndestroy(6), and the agent may release all\nassociated resources.")
atmVclVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 7, 1, 1), AtmVpIdentifier()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: atmVclVpi.setDescription("The VPI value of the VCL.")
atmVclVci = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 7, 1, 2), AtmVcIdentifier()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: atmVclVci.setDescription("The VCI value of the VCL.")
atmVclAdminStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 7, 1, 3), AtmVorXAdminStatus().clone('down')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVclAdminStatus.setDescription("This object is instanciated only for a VCL which\nterminates a VCC (i.e., one which is NOT\ncross-connected to other VCLs). Its value\nspecifies the desired administrative state of\nthe VCL.")
atmVclOperStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 7, 1, 4), AtmVorXOperStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVclOperStatus.setDescription("The current operational status of the VCL.")
atmVclLastChange = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 7, 1, 5), AtmVorXLastChange()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVclLastChange.setDescription("The value of sysUpTime at the time this VCL\nentered its current operational state.")
atmVclReceiveTrafficDescrIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 7, 1, 6), AtmTrafficDescrParamIndex().clone('0')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVclReceiveTrafficDescrIndex.setDescription("The value of this object identifies the row\nin the ATM Traffic Descriptor Table which\napplies to the receive direction of this VCL.")
atmVclTransmitTrafficDescrIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 7, 1, 7), AtmTrafficDescrParamIndex().clone('0')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVclTransmitTrafficDescrIndex.setDescription("The value of this object identifies the row\nof the ATM Traffic Descriptor Table which applies\nto the transmit direction of this VCL.")
atmVccAalType = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 7, 1, 8), Integer().subtype(subtypeSpec=SingleValueConstraint(6,5,1,3,4,2,)).subtype(namedValues=NamedValues(("aal1", 1), ("aal34", 2), ("aal5", 3), ("other", 4), ("unknown", 5), ("aal2", 6), )).clone(3)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVccAalType.setDescription("An instance of this object only exists when the\nlocal VCL end-point is also the VCC end-point,\nand AAL is in use.\nThe type of AAL used on this VCC.\nThe AAL type includes AAL1, AAL2, AAL3/4,\nand AAL5. The other(4) may be user-defined\nAAL type.  The unknown type indicates that\nthe AAL type cannot be determined.")
atmVccAal5CpcsTransmitSduSize = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 7, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(9188)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVccAal5CpcsTransmitSduSize.setDescription("An instance of this object only exists when the\nlocal VCL end-point is also the VCC end-point,\nand AAL5 is in use.\nThe maximum AAL5 CPCS SDU size in octets that is\nsupported on the transmit direction of this VCC.")
atmVccAal5CpcsReceiveSduSize = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 7, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(9188)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVccAal5CpcsReceiveSduSize.setDescription("An instance of this object only exists when the\nlocal VCL end-point is also the VCC end-point,\nand AAL5 is in use.\nThe maximum AAL5 CPCS SDU size in octets that is\nsupported on the receive direction of this VCC.")
atmVccAal5EncapsType = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 7, 1, 11), Integer().subtype(subtypeSpec=SingleValueConstraint(7,8,1,5,6,10,9,2,3,4,)).subtype(namedValues=NamedValues(("vcMultiplexRoutedProtocol", 1), ("unknown", 10), ("vcMultiplexBridgedProtocol8023", 2), ("vcMultiplexBridgedProtocol8025", 3), ("vcMultiplexBridgedProtocol8026", 4), ("vcMultiplexLANemulation8023", 5), ("vcMultiplexLANemulation8025", 6), ("llcEncapsulation", 7), ("multiprotocolFrameRelaySscs", 8), ("other", 9), )).clone(7)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVccAal5EncapsType.setDescription("An instance of this object only exists when the\nlocal VCL end-point is also the VCC end-point,\nand AAL5 is in use.\nThe type of data encapsulation used over\nthe AAL5 SSCS layer. The definitions reference\nRFC 1483 Multiprotocol Encapsulation\nover ATM AAL5 and to the ATM Forum\nLAN Emulation specification.")
atmVclCrossConnectIdentifier = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 7, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVclCrossConnectIdentifier.setDescription("This object is instantiated only for a VCL\nwhich is cross-connected to other VCLs\nthat belong to the same VCC.  All such\nassociated VCLs have the same value of this\nobject, and all their cross-connections are\nidentified either by entries that are indexed\nby the same value of atmVcCrossConnectIndex in\nthe atmVcCrossConnectTable of this MIB module or by\nthe same value of the cross-connect index in\nthe cross-connect table for SVCs and Soft PVCs\n(defined in a separate MIB module).\n\nAt no time should entries in these respective\ncross-connect tables exist simultaneously\nwith the same cross-connect index value.\nThe value of this object is initialized by the\nagent after the associated entries in the\natmVcCrossConnectTable have been created.")
atmVclRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 7, 1, 13), RowStatus('createAndWait')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVclRowStatus.setDescription("This object is used to create, delete or\nmodify a row in this table.  To create\na new VCL, this object is initially set\nto 'createAndWait' or 'createAndGo'.\nThis object should not be\nset to 'active' unless the following columnar\nobjects have been set to their desired value\nin this row:\natmVclReceiveTrafficDescrIndex,\natmVclTransmitTrafficDescrIndex.\nIn addition, if the local VCL end-point\nis also the VCC end-point:\natmVccAalType.\nIn addition, for AAL5 connections only:\natmVccAal5CpcsTransmitSduSize,\natmVccAal5CpcsReceiveSduSize, and\natmVccAal5EncapsType. (The existence\nof these objects imply the AAL connection type.).\nThe DESCRIPTION of atmVclEntry provides\nfurther guidance to row treatment in this table.")
atmVclCastType = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 7, 1, 14), AtmConnCastType().clone('p2p')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVclCastType.setDescription("The connection topology type.")
atmVclConnKind = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 7, 1, 15), AtmConnKind().clone('pvc')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVclConnKind.setDescription("The use of call control.")
atmVpCrossConnectIndexNext = MibScalar((1, 3, 6, 1, 2, 1, 37, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpCrossConnectIndexNext.setDescription("This object contains an appropriate value to\nbe used for atmVpCrossConnectIndex when creating\nentries in the atmVpCrossConnectTable.  The value\n0 indicates that no unassigned entries are\navailable. To obtain the atmVpCrossConnectIndex\nvalue for a new entry, the manager issues a\nmanagement protocol retrieval operation to obtain\nthe current value of this object.  After each\nretrieval, the agent should modify the value to\nthe next unassigned index.\nAfter a manager retrieves a value the agent will\ndetermine through its local policy when this index\nvalue will be made available for reuse.")
atmVpCrossConnectTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 9))
if mibBuilder.loadTexts: atmVpCrossConnectTable.setDescription("The ATM VP Cross Connect table for PVCs.\nAn entry in this table models two\ncross-connected VPLs.\nEach VPL must have its atmConnKind set\nto pvc(1).")
atmVpCrossConnectEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 9, 1)).setIndexNames((0, "ATM-MIB", "atmVpCrossConnectIndex"), (0, "ATM-MIB", "atmVpCrossConnectLowIfIndex"), (0, "ATM-MIB", "atmVpCrossConnectLowVpi"), (0, "ATM-MIB", "atmVpCrossConnectHighIfIndex"), (0, "ATM-MIB", "atmVpCrossConnectHighVpi"))
if mibBuilder.loadTexts: atmVpCrossConnectEntry.setDescription("An entry in the ATM VP Cross Connect table.\nThis entry is used to model a bi-directional\nATM VP cross-connect which cross-connects\ntwo VPLs.\n\nStep-wise Procedures to set up a VP Cross-connect\n\nOnce the entries in the atmVplTable are created,\nthe following procedures are used\nto cross-connect the VPLs together.\n\n(1) The manager obtains a unique\n   atmVpCrossConnectIndex by reading the\n   atmVpCrossConnectIndexNext object.\n\n(2) Next, the manager creates a set of one\n   or more rows in the ATM VP Cross Connect\n   Table, one for each cross-connection between\n   two VPLs.  Each row is indexed by the ATM\n   interface port numbers and VPI values of the\n   two ends of that cross-connection.\n   This set of rows specifies the topology of the\n   VPC cross-connect and is identified by a single\n   value of atmVpCrossConnectIndex.\n\nNegotiated VP Cross-Connect Establishment\n\n(2a) The manager creates a row in this table by\n   setting atmVpCrossConnectRowStatus to\n   createAndWait(5).  The agent checks the\n   requested topology and the mutual sanity of\n   the ATM traffic parameters and\n   service categories, i.e., the row creation\n   fails if:\n   - the requested topology is incompatible with\n     associated values of atmVplCastType,\n   - the requested topology is not supported\n     by the agent,\n   - the traffic/service category parameter values\n     associated with the requested row are\n     incompatible with those of already existing\n     rows for this VP cross-connect.\n   [For example, for setting up\n   a point-to-point VP cross-connect, the\n   ATM traffic parameters in the receive direction\n   of a VPL at the low end of the cross-connect\n   must equal to the traffic parameters in the\n   transmit direction of the other VPL at the\n   high end of the cross-connect,\n   otherwise, the row creation fails.]\n   The agent also checks for internal errors\n   in building the cross-connect.\n\n   The atmVpCrossConnectIndex values in the\n   corresponding atmVplTable rows are filled\n   in by the agent at this point.\n\n(2b) The manager promotes the row in the\n   atmVpCrossConnectTable by setting\n   atmVpCrossConnectRowStatus to active(1).  If\n   this set is successful, the agent has reserved\n   the resources specified by the ATM traffic\n   parameter and Service category values\n   for each direction of the VP cross-connect\n   in an ATM switch or network.\n\n(3) The manager sets the\n   atmVpCrossConnectAdminStatus to up(1) in all\n   rows of this VP cross-connect to turn the\n   traffic flow on.\n\n\nOne-Shot VP Cross-Connect Establishment\n\nA VP cross-connect may also be established in\none step by a set-request with all necessary\nparameter values and atmVpCrossConnectRowStatus\nset to createAndGo(4).\n\nIn contrast to the negotiated VP cross-connect\nestablishment which allows for detailed error\nchecking (i.e., set errors are explicitly linked\nto particular resource acquisition failures),\nthe one-shot VP cross-connect establishment\nperforms the setup on one operation but does not\nhave the advantage of step-wise error checking.\n\nVP Cross-Connect Retirement\n\nA VP cross-connect identified by a particular\nvalue of atmVpCrossConnectIndex is released by:\n\n(1) Setting atmVpCrossConnectRowStatus of all\n   rows identified by this value of\n   atmVpCrossConnectIndex to destroy(6).\n   The agent may release all\n   associated resources, and the\n   atmVpCrossConnectIndex values in the\n   corresponding atmVplTable row are removed.\n   Note that a situation when only a subset of\n   the associated rows are deleted corresponds\n   to a VP topology change.\n\n(2) After deletion of the appropriate\n   atmVpCrossConnectEntries, the manager may\n   set atmVplRowStatus to destroy(6) the\n   associated VPLs.  The agent releases\n   the resources and removes the associated\n   rows in the atmVplTable.\n\nVP Cross-connect Reconfiguration\n\nAt the discretion of the agent, a VP\ncross-connect may be reconfigured by\nadding and/or deleting leafs to/from\nthe VP topology as per the VP cross-connect\nestablishment/retirement procedures.\nReconfiguration of traffic/service category parameter\nvalues requires release of the VP cross-connect\nbefore those parameter values may by changed\nfor individual VPLs.")
atmVpCrossConnectIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 9, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: atmVpCrossConnectIndex.setDescription("A unique value to identify this VP cross-connect.\nFor each VPL associated with this cross-connect,\nthe agent reports this cross-connect index value\nin the atmVplCrossConnectIdentifier attribute of\nthe corresponding atmVplTable entries.")
atmVpCrossConnectLowIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 9, 1, 2), InterfaceIndex()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: atmVpCrossConnectLowIfIndex.setDescription("The ifIndex value of the ATM interface for\nthis VP cross-connect. The term low implies\nthat this ATM interface has the numerically lower\nifIndex value than the other ATM interface\nidentified in the same atmVpCrossConnectEntry.")
atmVpCrossConnectLowVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 9, 1, 3), AtmVpIdentifier()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: atmVpCrossConnectLowVpi.setDescription("The VPI value at the ATM interface\nassociated with the VP cross-connect that is\nidentified by atmVpCrossConnectLowIfIndex.")
atmVpCrossConnectHighIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 9, 1, 4), InterfaceIndex()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: atmVpCrossConnectHighIfIndex.setDescription("The ifIndex value of the ATM interface for\nthis VP cross-connect. The term high implies that\nthis ATM interface has the numerically higher\nifIndex value than the  other ATM interface\nidentified in the same atmVpCrossConnectEntry.")
atmVpCrossConnectHighVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 9, 1, 5), AtmVpIdentifier()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: atmVpCrossConnectHighVpi.setDescription("The VPI value at the ATM interface\nassociated with the VP cross-connect that is\nidentified by atmVpCrossConnectHighIfIndex.")
atmVpCrossConnectAdminStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 9, 1, 6), AtmVorXAdminStatus().clone('down')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVpCrossConnectAdminStatus.setDescription("The desired administrative status of this\nbi-directional VP cross-connect.")
atmVpCrossConnectL2HOperStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 9, 1, 7), AtmVorXOperStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpCrossConnectL2HOperStatus.setDescription("The operational status of the VP cross-connect\nin one direction; (i.e., from the low to\nhigh direction).")
atmVpCrossConnectH2LOperStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 9, 1, 8), AtmVorXOperStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpCrossConnectH2LOperStatus.setDescription("The operational status of the VP cross-connect\nin one direction; (i.e., from the high to\nlow direction).")
atmVpCrossConnectL2HLastChange = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 9, 1, 9), AtmVorXLastChange()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpCrossConnectL2HLastChange.setDescription("The value of sysUpTime at the time this\nVP cross-connect entered its current operational\nstate in the low to high direction.")
atmVpCrossConnectH2LLastChange = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 9, 1, 10), AtmVorXLastChange()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpCrossConnectH2LLastChange.setDescription("The value of sysUpTime at the time this\nVP cross-connect entered its current operational\nin the high to low direction.")
atmVpCrossConnectRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 9, 1, 11), RowStatus('createAndWait')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVpCrossConnectRowStatus.setDescription("The status of this entry in the\natmVpCrossConnectTable.  This object is used to\ncreate a cross-connect for cross-connecting\nVPLs which are created using the atmVplTable\nor to change or delete an existing cross-connect.\nThis object must be initially set\nto `createAndWait' or 'createAndGo'.\nTo turn on a VP cross-connect,\nthe atmVpCrossConnectAdminStatus\nis set to `up'.")
atmVcCrossConnectIndexNext = MibScalar((1, 3, 6, 1, 2, 1, 37, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcCrossConnectIndexNext.setDescription("This object contains an appropriate value to\nbe used for atmVcCrossConnectIndex when creating\nentries in the atmVcCrossConnectTable.  The value\n0 indicates that no unassigned entries are\navailable. To obtain the atmVcCrossConnectIndex\nvalue for a new entry, the manager issues a\nmanagement protocol retrieval operation to obtain\nthe current value of this object.  After each\nretrieval, the agent should modify the value to\nthe next unassigned index.\nAfter a manager retrieves a value the agent will\ndetermine through its local policy when this index\nvalue will be made available for reuse.")
atmVcCrossConnectTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 11))
if mibBuilder.loadTexts: atmVcCrossConnectTable.setDescription("The ATM VC Cross Connect table for PVCs.\nAn entry in this table models two\ncross-connected VCLs.\nEach VCL must have its atmConnKind set\nto pvc(1).")
atmVcCrossConnectEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 11, 1)).setIndexNames((0, "ATM-MIB", "atmVcCrossConnectIndex"), (0, "ATM-MIB", "atmVcCrossConnectLowIfIndex"), (0, "ATM-MIB", "atmVcCrossConnectLowVpi"), (0, "ATM-MIB", "atmVcCrossConnectLowVci"), (0, "ATM-MIB", "atmVcCrossConnectHighIfIndex"), (0, "ATM-MIB", "atmVcCrossConnectHighVpi"), (0, "ATM-MIB", "atmVcCrossConnectHighVci"))
if mibBuilder.loadTexts: atmVcCrossConnectEntry.setDescription("An entry in the ATM VC Cross Connect table.\nThis entry is used to model a bi-directional ATM\nVC cross-connect cross-connecting two end points.\n\nStep-wise Procedures to set up a VC Cross-connect\nOnce the entries in the atmVclTable are created,\nthe following procedures are used\nto cross-connect the VCLs together to\nform a VCC segment.\n\n(1) The manager obtains a unique\n   atmVcCrossConnectIndex by reading the\n   atmVcCrossConnectIndexNext object.\n\n(2) Next, the manager creates a set of one\n   or more rows in the ATM VC Cross Connect\n   Table, one for each cross-connection between\n   two VCLs.  Each row is indexed by the ATM\n   interface port numbers and VPI/VCI values of\n   the two ends of that cross-connection.\n   This set of rows specifies the topology of the\n   VCC cross-connect and is identified by a single\n   value of atmVcCrossConnectIndex.\n\nNegotiated VC Cross-Connect Establishment\n\n(2a) The manager creates a row in this table by\n   setting atmVcCrossConnectRowStatus to\n   createAndWait(5).  The agent checks the\n   requested topology and the mutual sanity of\n   the ATM traffic parameters and\n   service categories, i.e., the row creation\n   fails if:\n   - the requested topology is incompatible with\n     associated values of atmVclCastType,\n   - the requested topology is not supported\n     by the agent,\n   - the traffic/service category parameter values\n     associated with the requested row are\n     incompatible with those of already existing\n     rows for this VC cross-connect.\n   [For example, for setting up\n   a point-to-point VC cross-connect, the\n   ATM traffic parameters in the receive direction\n   of a VCL at the low end of the cross-connect\n   must equal to the traffic parameters in the\n   transmit direction of the other VCL at the\n   high end of the cross-connect,\n   otherwise, the row creation fails.]\n   The agent also checks for internal errors\n   in building the cross-connect.\n\n   The atmVcCrossConnectIndex values in the\n   corresponding atmVclTable rows are filled\n   in by the agent at this point.\n\n(2b) The manager promotes the row in the\n   atmVcCrossConnectTable by setting\n   atmVcCrossConnectRowStatus to active(1).  If\n   this set is successful, the agent has reserved\n   the resources specified by the ATM traffic\n   parameter and Service category values\n   for each direction of the VC cross-connect\n   in an ATM switch or network.\n\n(3) The manager sets the\n   atmVcCrossConnectAdminStatus to up(1)\n   in all rows of this VC cross-connect to\n   turn the traffic flow on.\n\n\nOne-Shot VC Cross-Connect Establishment\n\nA VC cross-connect may also be established in\none step by a set-request with all necessary\nparameter values and atmVcCrossConnectRowStatus\nset to createAndGo(4).\n\nIn contrast to the negotiated VC cross-connect\nestablishment which allows for detailed error\nchecking i.e., set errors are explicitly linked to\nparticular resource acquisition failures), the\none-shot VC cross-connect establishment\nperforms the setup on one operation but does\nnot have the advantage of step-wise error\nchecking.\n\nVC Cross-Connect Retirement\n\nA VC cross-connect identified by a particular\nvalue of atmVcCrossConnectIndex is released by:\n\n(1) Setting atmVcCrossConnectRowStatus of all rows\n   identified by this value of\n   atmVcCrossConnectIndex to destroy(6).\n   The agent may release all\n   associated resources, and the\n   atmVcCrossConnectIndex values in the\n   corresponding atmVclTable row are removed.\n   Note that a situation when only a subset of\n   the associated rows are deleted corresponds\n   to a VC topology change.\n\n(2) After deletion of the appropriate\n   atmVcCrossConnectEntries, the manager may\n   set atmVclRowStatus to destroy(6) the\n   associated VCLs.  The agent releases\n   the resources and removes the associated\n   rows in the atmVclTable.\n\nVC Cross-Connect Reconfiguration\n\nAt the discretion of the agent, a VC\ncross-connect may be reconfigured by\nadding and/or deleting leafs to/from\nthe VC topology as per the VC cross-connect\nestablishment/retirement procedures.\nReconfiguration of traffic/service category parameter\nvalues requires release of the VC cross-connect\nbefore those parameter values may by changed\nfor individual VCLs.")
atmVcCrossConnectIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: atmVcCrossConnectIndex.setDescription("A unique value to identify this VC cross-connect.\nFor each VCL associated with this cross-connect,\nthe agent reports this cross-connect index value\nin the atmVclCrossConnectIdentifier attribute of\nthe corresponding atmVclTable entries.")
atmVcCrossConnectLowIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 11, 1, 2), InterfaceIndex()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: atmVcCrossConnectLowIfIndex.setDescription("The ifIndex value of the ATM interface for this\nVC cross-connect. The term low implies\nthat this ATM interface has the numerically lower\nifIndex value than the other ATM interface\nidentified in the same atmVcCrossConnectEntry.")
atmVcCrossConnectLowVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 11, 1, 3), AtmVpIdentifier()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: atmVcCrossConnectLowVpi.setDescription("The VPI value at the ATM interface\nassociated with the VC cross-connect that is\nidentified by atmVcCrossConnectLowIfIndex.")
atmVcCrossConnectLowVci = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 11, 1, 4), AtmVcIdentifier()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: atmVcCrossConnectLowVci.setDescription("The VCI value at the ATM interface\nassociated with this VC cross-connect that is\nidentified by atmVcCrossConnectLowIfIndex.")
atmVcCrossConnectHighIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 11, 1, 5), InterfaceIndex()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: atmVcCrossConnectHighIfIndex.setDescription("The ifIndex value for the ATM interface for\nthis VC cross-connect. The term high implies\nthat this ATM interface has the numerically higher\nifIndex value than the other ATM interface\nidentified in the same atmVcCrossConnectEntry.")
atmVcCrossConnectHighVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 11, 1, 6), AtmVpIdentifier()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: atmVcCrossConnectHighVpi.setDescription("The VPI value at the ATM interface\nassociated with the VC cross-connect that is\nidentified by atmVcCrossConnectHighIfIndex.")
atmVcCrossConnectHighVci = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 11, 1, 7), AtmVcIdentifier()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: atmVcCrossConnectHighVci.setDescription("The VCI value at the ATM interface\nassociated with the VC cross-connect that is\nidentified by atmVcCrossConnectHighIfIndex.")
atmVcCrossConnectAdminStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 11, 1, 8), AtmVorXAdminStatus().clone('down')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVcCrossConnectAdminStatus.setDescription("The desired administrative status of this\nbi-directional VC cross-connect.")
atmVcCrossConnectL2HOperStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 11, 1, 9), AtmVorXOperStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcCrossConnectL2HOperStatus.setDescription("The current operational status of the\nVC cross-connect in one direction; (i.e.,\nfrom the low to high direction).")
atmVcCrossConnectH2LOperStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 11, 1, 10), AtmVorXOperStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcCrossConnectH2LOperStatus.setDescription("The current operational status of the\nVC cross-connect in one direction; (i.e.,\nfrom the high to low direction).")
atmVcCrossConnectL2HLastChange = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 11, 1, 11), AtmVorXLastChange()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcCrossConnectL2HLastChange.setDescription("The value of sysUpTime at the time this\nVC cross-connect entered its current\noperational state in low to high direction.")
atmVcCrossConnectH2LLastChange = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 11, 1, 12), AtmVorXLastChange()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcCrossConnectH2LLastChange.setDescription("The value of sysUpTime at the time this\nVC cross-connect entered its current\noperational state in high to low direction.")
atmVcCrossConnectRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 11, 1, 13), RowStatus('createAndWait')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVcCrossConnectRowStatus.setDescription("The status of this entry in the\natmVcCrossConnectTable.  This object is used to\ncreate a new cross-connect for cross-connecting\nVCLs which are created using the atmVclTable\nor to change or delete existing cross-connect.\nThis object must be initially set to\n`createAndWait' or 'createAndGo'.\nTo turn on a VC cross-connect,\nthe atmVcCrossConnectAdminStatus\nis set to `up'.")
aal5VccTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 12))
if mibBuilder.loadTexts: aal5VccTable.setDescription("This table contains AAL5 VCC performance\nparameters.")
aal5VccEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 12, 1)).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "aal5VccVpi"), (0, "ATM-MIB", "aal5VccVci"))
if mibBuilder.loadTexts: aal5VccEntry.setDescription("This list contains the AAL5 VCC\nperformance parameters and is indexed\nby ifIndex values of AAL5 interfaces\nand the associated VPI/VCI values.")
aal5VccVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 12, 1, 1), AtmVpIdentifier()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: aal5VccVpi.setDescription("The VPI value of the AAL5 VCC at the\ninterface identified by the ifIndex.")
aal5VccVci = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 12, 1, 2), AtmVcIdentifier()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: aal5VccVci.setDescription("The VCI value of the AAL5 VCC at the\ninterface identified by the ifIndex.")
aal5VccCrcErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 12, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal5VccCrcErrors.setDescription("The number of AAL5 CPCS PDUs received with\nCRC-32 errors on this AAL5 VCC at the\ninterface associated with an AAL5 entity.")
aal5VccSarTimeOuts = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 12, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal5VccSarTimeOuts.setDescription("The number of partially re-assembled AAL5\nCPCS PDUs which were discarded\non this AAL5 VCC at the interface associated\nwith an AAL5 entity because they\nwere not fully re-assembled within the\nrequired time period.  If the re-assembly\ntimer is not supported, then this object\ncontains a zero value.")
aal5VccOverSizedSDUs = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 12, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal5VccOverSizedSDUs.setDescription("The number of AAL5 CPCS PDUs discarded\non this AAL5 VCC at the interface\nassociated with an AAL5 entity because the\nAAL5 SDUs were too large.")
atmTrafficDescrParamIndexNext = MibScalar((1, 3, 6, 1, 2, 1, 37, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTrafficDescrParamIndexNext.setDescription("This object contains an appropriate value to\nbe used for atmTrafficDescrParamIndex when\ncreating entries in the\natmTrafficDescrParamTable.\nThe value 0 indicates that no unassigned\nentries are available. To obtain the\natmTrafficDescrParamIndex value for a new\nentry, the manager issues a management\nprotocol retrieval operation to obtain the\ncurrent value of this object.  After each\nretrieval, the agent should modify the value\nto the next unassigned index.\nAfter a manager retrieves a value the agent will\ndetermine through its local policy when this index\nvalue will be made available for reuse.")
atmMIBConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 37, 2))
atmMIBGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 37, 2, 1))
atmMIBCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 37, 2, 2))

# Augmentions

# Groups

atmInterfaceConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 2, 1, 1)).setObjects(*(("ATM-MIB", "atmInterfaceConfVccs"), ("ATM-MIB", "atmInterfaceMaxActiveVpiBits"), ("ATM-MIB", "atmInterfaceAddressType"), ("ATM-MIB", "atmInterfaceAdminAddress"), ("ATM-MIB", "atmInterfaceMyNeighborIfName"), ("ATM-MIB", "atmInterfaceMaxActiveVciBits"), ("ATM-MIB", "atmInterfaceIlmiVci"), ("ATM-MIB", "atmInterfaceMaxVpcs"), ("ATM-MIB", "atmInterfaceIlmiVpi"), ("ATM-MIB", "atmInterfaceConfVpcs"), ("ATM-MIB", "atmInterfaceMaxVccs"), ("ATM-MIB", "atmInterfaceMyNeighborIpAddress"), ) )
if mibBuilder.loadTexts: atmInterfaceConfGroup.setDescription("A collection of objects providing configuration\ninformation about an ATM interface.")
atmTrafficDescrGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 2, 1, 2)).setObjects(*(("ATM-MIB", "atmTrafficDescrRowStatus"), ("ATM-MIB", "atmTrafficDescrParam3"), ("ATM-MIB", "atmTrafficQoSClass"), ("ATM-MIB", "atmTrafficDescrParam4"), ("ATM-MIB", "atmTrafficDescrParam5"), ("ATM-MIB", "atmTrafficDescrParam2"), ("ATM-MIB", "atmTrafficDescrType"), ("ATM-MIB", "atmTrafficDescrParam1"), ) )
if mibBuilder.loadTexts: atmTrafficDescrGroup.setDescription("A collection of objects providing information\nabout ATM traffic descriptor type and\nthe associated parameters.")
atmInterfaceDs3PlcpGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 2, 1, 3)).setObjects(*(("ATM-MIB", "atmInterfaceDs3PlcpSEFSs"), ("ATM-MIB", "atmInterfaceDs3PlcpAlarmState"), ("ATM-MIB", "atmInterfaceDs3PlcpUASs"), ) )
if mibBuilder.loadTexts: atmInterfaceDs3PlcpGroup.setDescription("A collection of objects providing information\nabout DS3 PLCP layer at an ATM interface.")
atmInterfaceTCGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 2, 1, 4)).setObjects(*(("ATM-MIB", "atmInterfaceTCAlarmState"), ("ATM-MIB", "atmInterfaceOCDEvents"), ) )
if mibBuilder.loadTexts: atmInterfaceTCGroup.setDescription("A collection of objects providing information\nabout TC sublayer at an ATM interface.")
atmVpcTerminationGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 2, 1, 5)).setObjects(*(("ATM-MIB", "atmVplRowStatus"), ("ATM-MIB", "atmVplAdminStatus"), ("ATM-MIB", "atmVplReceiveTrafficDescrIndex"), ("ATM-MIB", "atmVplOperStatus"), ("ATM-MIB", "atmVplTransmitTrafficDescrIndex"), ("ATM-MIB", "atmVplLastChange"), ) )
if mibBuilder.loadTexts: atmVpcTerminationGroup.setDescription("A collection of objects providing\ninformation about a VPL at an ATM interface\nwhich terminates a VPC\n(i.e., one which is NOT cross-connected\nto other VPLs).")
atmVccTerminationGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 2, 1, 6)).setObjects(*(("ATM-MIB", "atmVclLastChange"), ("ATM-MIB", "atmVclTransmitTrafficDescrIndex"), ("ATM-MIB", "atmVclOperStatus"), ("ATM-MIB", "atmVclRowStatus"), ("ATM-MIB", "atmVclReceiveTrafficDescrIndex"), ("ATM-MIB", "atmVclAdminStatus"), ("ATM-MIB", "atmVccAalType"), ) )
if mibBuilder.loadTexts: atmVccTerminationGroup.setDescription("A collection of objects providing information\nabout a VCL at an ATM interface\nwhich terminates a VCC (i.e., one which is\nNOT cross-connected to other VCLs).")
atmVpCrossConnectGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 2, 1, 7)).setObjects(*(("ATM-MIB", "atmVplOperStatus"), ("ATM-MIB", "atmVplCrossConnectIdentifier"), ("ATM-MIB", "atmVplTransmitTrafficDescrIndex"), ("ATM-MIB", "atmVpCrossConnectH2LOperStatus"), ("ATM-MIB", "atmVpCrossConnectH2LLastChange"), ("ATM-MIB", "atmVpCrossConnectIndexNext"), ("ATM-MIB", "atmVpCrossConnectL2HOperStatus"), ("ATM-MIB", "atmVpCrossConnectL2HLastChange"), ("ATM-MIB", "atmVplRowStatus"), ("ATM-MIB", "atmVpCrossConnectRowStatus"), ("ATM-MIB", "atmVplReceiveTrafficDescrIndex"), ("ATM-MIB", "atmVpCrossConnectAdminStatus"), ) )
if mibBuilder.loadTexts: atmVpCrossConnectGroup.setDescription("A collection of objects providing\ninformation about a VP cross-connect\nand the associated VPLs that are\ncross-connected together.")
atmVcCrossConnectGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 2, 1, 8)).setObjects(*(("ATM-MIB", "atmVcCrossConnectH2LLastChange"), ("ATM-MIB", "atmVclTransmitTrafficDescrIndex"), ("ATM-MIB", "atmVcCrossConnectRowStatus"), ("ATM-MIB", "atmVclRowStatus"), ("ATM-MIB", "atmVcCrossConnectL2HOperStatus"), ("ATM-MIB", "atmVcCrossConnectL2HLastChange"), ("ATM-MIB", "atmVcCrossConnectIndexNext"), ("ATM-MIB", "atmVclOperStatus"), ("ATM-MIB", "atmVclReceiveTrafficDescrIndex"), ("ATM-MIB", "atmVcCrossConnectH2LOperStatus"), ("ATM-MIB", "atmVclCrossConnectIdentifier"), ("ATM-MIB", "atmVcCrossConnectAdminStatus"), ) )
if mibBuilder.loadTexts: atmVcCrossConnectGroup.setDescription("A collection of objects providing\ninformation about a VC cross-connect\nand the associated VCLs that are\ncross-connected together.")
aal5VccGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 2, 1, 9)).setObjects(*(("ATM-MIB", "atmVccAal5CpcsTransmitSduSize"), ("ATM-MIB", "aal5VccSarTimeOuts"), ("ATM-MIB", "atmVccAal5CpcsReceiveSduSize"), ("ATM-MIB", "atmVccAal5EncapsType"), ("ATM-MIB", "aal5VccCrcErrors"), ("ATM-MIB", "aal5VccOverSizedSDUs"), ) )
if mibBuilder.loadTexts: aal5VccGroup.setDescription("A collection of objects providing\nAAL5 configuration and performance statistics\nof a VCC.")
atmInterfaceConfGroup2 = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 2, 1, 10)).setObjects(*(("ATM-MIB", "atmInterfaceConfVccs"), ("ATM-MIB", "atmInterfaceMaxActiveVpiBits"), ("ATM-MIB", "atmInterfaceSubscrAddress"), ("ATM-MIB", "atmInterfaceIlmiVpi"), ("ATM-MIB", "atmInterfaceMyNeighborIfName"), ("ATM-MIB", "atmInterfaceCurrentMaxVciBits"), ("ATM-MIB", "atmInterfaceMaxActiveVciBits"), ("ATM-MIB", "atmInterfaceIlmiVci"), ("ATM-MIB", "atmInterfaceMaxVpcs"), ("ATM-MIB", "atmInterfaceCurrentMaxVpiBits"), ("ATM-MIB", "atmInterfaceConfVpcs"), ("ATM-MIB", "atmInterfaceMaxVccs"), ("ATM-MIB", "atmInterfaceMyNeighborIpAddress"), ) )
if mibBuilder.loadTexts: atmInterfaceConfGroup2.setDescription("A collection of objects providing configuration\ninformation about an ATM interface.")
atmTrafficDescrGroup2 = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 2, 1, 11)).setObjects(*(("ATM-MIB", "atmTrafficDescrRowStatus"), ("ATM-MIB", "atmTrafficFrameDiscard"), ("ATM-MIB", "atmServiceCategory"), ("ATM-MIB", "atmTrafficDescrParam3"), ("ATM-MIB", "atmTrafficDescrParamIndexNext"), ("ATM-MIB", "atmTrafficDescrParam4"), ("ATM-MIB", "atmTrafficDescrParam5"), ("ATM-MIB", "atmTrafficDescrParam2"), ("ATM-MIB", "atmTrafficDescrType"), ("ATM-MIB", "atmTrafficDescrParam1"), ) )
if mibBuilder.loadTexts: atmTrafficDescrGroup2.setDescription("A collection of objects providing information\nabout ATM traffic descriptor type and\nthe associated parameters.")
atmVpcTerminationGroup2 = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 2, 1, 12)).setObjects(*(("ATM-MIB", "atmVplTransmitTrafficDescrIndex"), ("ATM-MIB", "atmVplAdminStatus"), ("ATM-MIB", "atmVplConnKind"), ("ATM-MIB", "atmVplCastType"), ("ATM-MIB", "atmVplLastChange"), ("ATM-MIB", "atmVplReceiveTrafficDescrIndex"), ("ATM-MIB", "atmVplOperStatus"), ("ATM-MIB", "atmVplRowStatus"), ) )
if mibBuilder.loadTexts: atmVpcTerminationGroup2.setDescription("A collection of objects providing information\nabout a VPL at an ATM interface which\nterminates a VPC (i.e., one which is NOT\ncross-connected to other VPLs).")
atmVccTerminationGroup2 = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 2, 1, 13)).setObjects(*(("ATM-MIB", "atmVclRowStatus"), ("ATM-MIB", "atmVclReceiveTrafficDescrIndex"), ("ATM-MIB", "atmVclLastChange"), ("ATM-MIB", "atmVclTransmitTrafficDescrIndex"), ("ATM-MIB", "atmVclConnKind"), ("ATM-MIB", "atmVclCastType"), ("ATM-MIB", "atmVclAdminStatus"), ("ATM-MIB", "atmVclOperStatus"), ("ATM-MIB", "atmVccAalType"), ) )
if mibBuilder.loadTexts: atmVccTerminationGroup2.setDescription("A collection of objects providing information\nabout a VCL at an ATM interface\nwhich terminates a VCC (i.e., one which is\nNOT cross-connected to other VCLs).")
atmVplCrossConnectGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 2, 1, 14)).setObjects(*(("ATM-MIB", "atmVplRowStatus"), ("ATM-MIB", "atmVplConnKind"), ("ATM-MIB", "atmVplCastType"), ("ATM-MIB", "atmVplReceiveTrafficDescrIndex"), ("ATM-MIB", "atmVplOperStatus"), ("ATM-MIB", "atmVplTransmitTrafficDescrIndex"), ("ATM-MIB", "atmVplLastChange"), ) )
if mibBuilder.loadTexts: atmVplCrossConnectGroup.setDescription("A collection of objects providing\ninformation about the VPLs that\nare cross-connected together.")
atmVpPvcCrossConnectGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 2, 1, 15)).setObjects(*(("ATM-MIB", "atmVpCrossConnectL2HLastChange"), ("ATM-MIB", "atmVplCrossConnectIdentifier"), ("ATM-MIB", "atmVpCrossConnectRowStatus"), ("ATM-MIB", "atmVpCrossConnectH2LOperStatus"), ("ATM-MIB", "atmVpCrossConnectH2LLastChange"), ("ATM-MIB", "atmVpCrossConnectIndexNext"), ("ATM-MIB", "atmVpCrossConnectAdminStatus"), ("ATM-MIB", "atmVpCrossConnectL2HOperStatus"), ) )
if mibBuilder.loadTexts: atmVpPvcCrossConnectGroup.setDescription("A collection of objects providing\ninformation about a VP cross-connect\nfor PVCs. These objects are not used\nfor Soft PVCs or SVCs.")
atmVclCrossConnectGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 2, 1, 16)).setObjects(*(("ATM-MIB", "atmVclLastChange"), ("ATM-MIB", "atmVclCastType"), ("ATM-MIB", "atmVclConnKind"), ("ATM-MIB", "atmVclOperStatus"), ("ATM-MIB", "atmVclRowStatus"), ("ATM-MIB", "atmVclReceiveTrafficDescrIndex"), ("ATM-MIB", "atmVclTransmitTrafficDescrIndex"), ) )
if mibBuilder.loadTexts: atmVclCrossConnectGroup.setDescription("A collection of objects providing\ninformation about the VCLs that\nare cross-connected together.")
atmVcPvcCrossConnectGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 2, 1, 17)).setObjects(*(("ATM-MIB", "atmVclCrossConnectIdentifier"), ("ATM-MIB", "atmVcCrossConnectL2HLastChange"), ("ATM-MIB", "atmVcCrossConnectH2LLastChange"), ("ATM-MIB", "atmVcCrossConnectL2HOperStatus"), ("ATM-MIB", "atmVcCrossConnectIndexNext"), ("ATM-MIB", "atmVcCrossConnectH2LOperStatus"), ("ATM-MIB", "atmVcCrossConnectRowStatus"), ("ATM-MIB", "atmVcCrossConnectAdminStatus"), ) )
if mibBuilder.loadTexts: atmVcPvcCrossConnectGroup.setDescription("A collection of objects providing\ninformation about a VC cross-connect\nfor PVCs. These objects are not used\nfor Soft PVCs or SVCs.")

# Compliances

atmMIBCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 37, 2, 2, 1)).setObjects(*(("ATM-MIB", "atmInterfaceConfGroup"), ("ATM-MIB", "aal5VccGroup"), ("ATM-MIB", "atmVpCrossConnectGroup"), ("ATM-MIB", "atmInterfaceDs3PlcpGroup"), ("ATM-MIB", "atmVpcTerminationGroup"), ("ATM-MIB", "atmVcCrossConnectGroup"), ("ATM-MIB", "atmTrafficDescrGroup"), ("ATM-MIB", "atmInterfaceTCGroup"), ("ATM-MIB", "atmVccTerminationGroup"), ) )
if mibBuilder.loadTexts: atmMIBCompliance.setDescription("The compliance statement for SNMP entities\nincluding networks which have ATM and\nAAL5 interfaces.")
atmMIBCompliance2 = ModuleCompliance((1, 3, 6, 1, 2, 1, 37, 2, 2, 2)).setObjects(*(("ATM-MIB", "aal5VccGroup"), ("ATM-MIB", "atmInterfaceConfGroup2"), ("ATM-MIB", "atmVplCrossConnectGroup"), ("ATM-MIB", "atmVpcTerminationGroup2"), ("ATM-MIB", "atmVclCrossConnectGroup"), ("ATM-MIB", "atmVccTerminationGroup2"), ("ATM-MIB", "atmInterfaceDs3PlcpGroup"), ("ATM-MIB", "atmInterfaceTCGroup"), ("ATM-MIB", "atmVcPvcCrossConnectGroup"), ("ATM-MIB", "atmTrafficDescrGroup2"), ("ATM-MIB", "atmVpPvcCrossConnectGroup"), ) )
if mibBuilder.loadTexts: atmMIBCompliance2.setDescription("The compliance statement for SNMP entities\nincluding networks which have ATM and\nAAL5 interfaces.")

# Exports

# Module identity
mibBuilder.exportSymbols("ATM-MIB", PYSNMP_MODULE_ID=atmMIB)

# Objects
mibBuilder.exportSymbols("ATM-MIB", atmMIB=atmMIB, atmMIBObjects=atmMIBObjects, atmInterfaceConfTable=atmInterfaceConfTable, atmInterfaceConfEntry=atmInterfaceConfEntry, atmInterfaceMaxVpcs=atmInterfaceMaxVpcs, atmInterfaceMaxVccs=atmInterfaceMaxVccs, atmInterfaceConfVpcs=atmInterfaceConfVpcs, atmInterfaceConfVccs=atmInterfaceConfVccs, atmInterfaceMaxActiveVpiBits=atmInterfaceMaxActiveVpiBits, atmInterfaceMaxActiveVciBits=atmInterfaceMaxActiveVciBits, atmInterfaceIlmiVpi=atmInterfaceIlmiVpi, atmInterfaceIlmiVci=atmInterfaceIlmiVci, atmInterfaceAddressType=atmInterfaceAddressType, atmInterfaceAdminAddress=atmInterfaceAdminAddress, atmInterfaceMyNeighborIpAddress=atmInterfaceMyNeighborIpAddress, atmInterfaceMyNeighborIfName=atmInterfaceMyNeighborIfName, atmInterfaceCurrentMaxVpiBits=atmInterfaceCurrentMaxVpiBits, atmInterfaceCurrentMaxVciBits=atmInterfaceCurrentMaxVciBits, atmInterfaceSubscrAddress=atmInterfaceSubscrAddress, atmInterfaceDs3PlcpTable=atmInterfaceDs3PlcpTable, atmInterfaceDs3PlcpEntry=atmInterfaceDs3PlcpEntry, atmInterfaceDs3PlcpSEFSs=atmInterfaceDs3PlcpSEFSs, atmInterfaceDs3PlcpAlarmState=atmInterfaceDs3PlcpAlarmState, atmInterfaceDs3PlcpUASs=atmInterfaceDs3PlcpUASs, atmInterfaceTCTable=atmInterfaceTCTable, atmInterfaceTCEntry=atmInterfaceTCEntry, atmInterfaceOCDEvents=atmInterfaceOCDEvents, atmInterfaceTCAlarmState=atmInterfaceTCAlarmState, atmTrafficDescrParamTable=atmTrafficDescrParamTable, atmTrafficDescrParamEntry=atmTrafficDescrParamEntry, atmTrafficDescrParamIndex=atmTrafficDescrParamIndex, atmTrafficDescrType=atmTrafficDescrType, atmTrafficDescrParam1=atmTrafficDescrParam1, atmTrafficDescrParam2=atmTrafficDescrParam2, atmTrafficDescrParam3=atmTrafficDescrParam3, atmTrafficDescrParam4=atmTrafficDescrParam4, atmTrafficDescrParam5=atmTrafficDescrParam5, atmTrafficQoSClass=atmTrafficQoSClass, atmTrafficDescrRowStatus=atmTrafficDescrRowStatus, atmServiceCategory=atmServiceCategory, atmTrafficFrameDiscard=atmTrafficFrameDiscard, atmVplTable=atmVplTable, atmVplEntry=atmVplEntry, atmVplVpi=atmVplVpi, atmVplAdminStatus=atmVplAdminStatus, atmVplOperStatus=atmVplOperStatus, atmVplLastChange=atmVplLastChange, atmVplReceiveTrafficDescrIndex=atmVplReceiveTrafficDescrIndex, atmVplTransmitTrafficDescrIndex=atmVplTransmitTrafficDescrIndex, atmVplCrossConnectIdentifier=atmVplCrossConnectIdentifier, atmVplRowStatus=atmVplRowStatus, atmVplCastType=atmVplCastType, atmVplConnKind=atmVplConnKind, atmVclTable=atmVclTable, atmVclEntry=atmVclEntry, atmVclVpi=atmVclVpi, atmVclVci=atmVclVci, atmVclAdminStatus=atmVclAdminStatus, atmVclOperStatus=atmVclOperStatus, atmVclLastChange=atmVclLastChange, atmVclReceiveTrafficDescrIndex=atmVclReceiveTrafficDescrIndex, atmVclTransmitTrafficDescrIndex=atmVclTransmitTrafficDescrIndex, atmVccAalType=atmVccAalType, atmVccAal5CpcsTransmitSduSize=atmVccAal5CpcsTransmitSduSize, atmVccAal5CpcsReceiveSduSize=atmVccAal5CpcsReceiveSduSize, atmVccAal5EncapsType=atmVccAal5EncapsType, atmVclCrossConnectIdentifier=atmVclCrossConnectIdentifier, atmVclRowStatus=atmVclRowStatus, atmVclCastType=atmVclCastType, atmVclConnKind=atmVclConnKind, atmVpCrossConnectIndexNext=atmVpCrossConnectIndexNext, atmVpCrossConnectTable=atmVpCrossConnectTable, atmVpCrossConnectEntry=atmVpCrossConnectEntry, atmVpCrossConnectIndex=atmVpCrossConnectIndex, atmVpCrossConnectLowIfIndex=atmVpCrossConnectLowIfIndex, atmVpCrossConnectLowVpi=atmVpCrossConnectLowVpi, atmVpCrossConnectHighIfIndex=atmVpCrossConnectHighIfIndex, atmVpCrossConnectHighVpi=atmVpCrossConnectHighVpi, atmVpCrossConnectAdminStatus=atmVpCrossConnectAdminStatus, atmVpCrossConnectL2HOperStatus=atmVpCrossConnectL2HOperStatus, atmVpCrossConnectH2LOperStatus=atmVpCrossConnectH2LOperStatus, atmVpCrossConnectL2HLastChange=atmVpCrossConnectL2HLastChange, atmVpCrossConnectH2LLastChange=atmVpCrossConnectH2LLastChange, atmVpCrossConnectRowStatus=atmVpCrossConnectRowStatus, atmVcCrossConnectIndexNext=atmVcCrossConnectIndexNext, atmVcCrossConnectTable=atmVcCrossConnectTable, atmVcCrossConnectEntry=atmVcCrossConnectEntry, atmVcCrossConnectIndex=atmVcCrossConnectIndex, atmVcCrossConnectLowIfIndex=atmVcCrossConnectLowIfIndex, atmVcCrossConnectLowVpi=atmVcCrossConnectLowVpi, atmVcCrossConnectLowVci=atmVcCrossConnectLowVci, atmVcCrossConnectHighIfIndex=atmVcCrossConnectHighIfIndex, atmVcCrossConnectHighVpi=atmVcCrossConnectHighVpi, atmVcCrossConnectHighVci=atmVcCrossConnectHighVci, atmVcCrossConnectAdminStatus=atmVcCrossConnectAdminStatus, atmVcCrossConnectL2HOperStatus=atmVcCrossConnectL2HOperStatus, atmVcCrossConnectH2LOperStatus=atmVcCrossConnectH2LOperStatus, atmVcCrossConnectL2HLastChange=atmVcCrossConnectL2HLastChange, atmVcCrossConnectH2LLastChange=atmVcCrossConnectH2LLastChange, atmVcCrossConnectRowStatus=atmVcCrossConnectRowStatus, aal5VccTable=aal5VccTable, aal5VccEntry=aal5VccEntry, aal5VccVpi=aal5VccVpi, aal5VccVci=aal5VccVci, aal5VccCrcErrors=aal5VccCrcErrors, aal5VccSarTimeOuts=aal5VccSarTimeOuts, aal5VccOverSizedSDUs=aal5VccOverSizedSDUs, atmTrafficDescrParamIndexNext=atmTrafficDescrParamIndexNext, atmMIBConformance=atmMIBConformance, atmMIBGroups=atmMIBGroups, atmMIBCompliances=atmMIBCompliances)

# Groups
mibBuilder.exportSymbols("ATM-MIB", atmInterfaceConfGroup=atmInterfaceConfGroup, atmTrafficDescrGroup=atmTrafficDescrGroup, atmInterfaceDs3PlcpGroup=atmInterfaceDs3PlcpGroup, atmInterfaceTCGroup=atmInterfaceTCGroup, atmVpcTerminationGroup=atmVpcTerminationGroup, atmVccTerminationGroup=atmVccTerminationGroup, atmVpCrossConnectGroup=atmVpCrossConnectGroup, atmVcCrossConnectGroup=atmVcCrossConnectGroup, aal5VccGroup=aal5VccGroup, atmInterfaceConfGroup2=atmInterfaceConfGroup2, atmTrafficDescrGroup2=atmTrafficDescrGroup2, atmVpcTerminationGroup2=atmVpcTerminationGroup2, atmVccTerminationGroup2=atmVccTerminationGroup2, atmVplCrossConnectGroup=atmVplCrossConnectGroup, atmVpPvcCrossConnectGroup=atmVpPvcCrossConnectGroup, atmVclCrossConnectGroup=atmVclCrossConnectGroup, atmVcPvcCrossConnectGroup=atmVcPvcCrossConnectGroup)

# Compliances
mibBuilder.exportSymbols("ATM-MIB", atmMIBCompliance=atmMIBCompliance, atmMIBCompliance2=atmMIBCompliance2)
