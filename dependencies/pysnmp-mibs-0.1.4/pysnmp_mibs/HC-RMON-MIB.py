# PySNMP SMI module. Autogenerated from smidump -f python HC-RMON-MIB
# by libsmi2pysnmp-0.1.3 at Mon Apr  2 20:39:03 2012,
# Python version sys.version_info(major=2, minor=7, micro=2, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( CounterBasedGauge64, ZeroBasedCounter64, ) = mibBuilder.importSymbols("HCNUM-TC", "CounterBasedGauge64", "ZeroBasedCounter64")
( OwnerString, capture, captureBufferControlIndex, captureBufferIndex, etherHistoryIndex, etherHistorySampleIndex, etherStatsIndex, history, hostAddress, hostIndex, hostTimeCreationOrder, hostTimeIndex, hostTopN, hostTopNIndex, hostTopNReport, hosts, matrix, matrixDSDestAddress, matrixDSIndex, matrixDSSourceAddress, matrixSDDestAddress, matrixSDIndex, matrixSDSourceAddress, rmon, rmonEtherStatsGroup, rmonEthernetHistoryGroup, rmonFilterGroup, rmonHistoryControlGroup, rmonHostGroup, rmonHostTopNGroup, rmonMatrixGroup, rmonPacketCaptureGroup, statistics, ) = mibBuilder.importSymbols("RMON-MIB", "OwnerString", "capture", "captureBufferControlIndex", "captureBufferIndex", "etherHistoryIndex", "etherHistorySampleIndex", "etherStatsIndex", "history", "hostAddress", "hostIndex", "hostTimeCreationOrder", "hostTimeIndex", "hostTopN", "hostTopNIndex", "hostTopNReport", "hosts", "matrix", "matrixDSDestAddress", "matrixDSIndex", "matrixDSSourceAddress", "matrixSDDestAddress", "matrixSDIndex", "matrixSDSourceAddress", "rmon", "rmonEtherStatsGroup", "rmonEthernetHistoryGroup", "rmonFilterGroup", "rmonHistoryControlGroup", "rmonHostGroup", "rmonHostTopNGroup", "rmonMatrixGroup", "rmonPacketCaptureGroup", "statistics")
( ZeroBasedCounter32, addressMapGroup, addressMapGroup, alHost, alHostGroup, alHostTimeMark, alMatrix, alMatrixDSTimeMark, alMatrixGroup, alMatrixSDTimeMark, alMatrixTopNControlIndex, alMatrixTopNIndex, hlHostControlIndex, hlMatrixControlIndex, nlHost, nlHostAddress, nlHostGroup, nlHostGroup, nlHostTimeMark, nlMatrix, nlMatrixDSDestAddress, nlMatrixDSSourceAddress, nlMatrixDSTimeMark, nlMatrixGroup, nlMatrixGroup, nlMatrixSDDestAddress, nlMatrixSDSourceAddress, nlMatrixSDTimeMark, nlMatrixTopNControlIndex, nlMatrixTopNIndex, probeConfig, probeInformationGroup, probeInformationGroup, protocolDirLocalIndex, protocolDirectoryGroup, protocolDirectoryGroup, protocolDist, protocolDistControlIndex, protocolDistributionGroup, protocolDistributionGroup, rmon1EnhancementGroup, rmon1EnhancementGroup, rmonConformance, usrHistory, usrHistoryControlIndex, usrHistoryGroup, usrHistoryGroup, usrHistoryObjectIndex, usrHistorySampleIndex, ) = mibBuilder.importSymbols("RMON2-MIB", "ZeroBasedCounter32", "addressMapGroup", "addressMapGroup", "alHost", "alHostGroup", "alHostTimeMark", "alMatrix", "alMatrixDSTimeMark", "alMatrixGroup", "alMatrixSDTimeMark", "alMatrixTopNControlIndex", "alMatrixTopNIndex", "hlHostControlIndex", "hlMatrixControlIndex", "nlHost", "nlHostAddress", "nlHostGroup", "nlHostGroup", "nlHostTimeMark", "nlMatrix", "nlMatrixDSDestAddress", "nlMatrixDSSourceAddress", "nlMatrixDSTimeMark", "nlMatrixGroup", "nlMatrixGroup", "nlMatrixSDDestAddress", "nlMatrixSDSourceAddress", "nlMatrixSDTimeMark", "nlMatrixTopNControlIndex", "nlMatrixTopNIndex", "probeConfig", "probeInformationGroup", "probeInformationGroup", "protocolDirLocalIndex", "protocolDirectoryGroup", "protocolDirectoryGroup", "protocolDist", "protocolDistControlIndex", "protocolDistributionGroup", "protocolDistributionGroup", "rmon1EnhancementGroup", "rmon1EnhancementGroup", "rmonConformance", "usrHistory", "usrHistoryControlIndex", "usrHistoryGroup", "usrHistoryGroup", "usrHistoryObjectIndex", "usrHistorySampleIndex")
( ModuleCompliance, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup")
( Bits, Counter32, Counter64, Gauge32, Integer32, Integer32, ModuleIdentity, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "Counter64", "Gauge32", "Integer32", "Integer32", "ModuleIdentity", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks")
( RowStatus, TimeStamp, ) = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "TimeStamp")

# Objects

etherStatsHighCapacityTable = MibTable((1, 3, 6, 1, 2, 1, 16, 1, 7))
if mibBuilder.loadTexts: etherStatsHighCapacityTable.setDescription("Contains the High Capacity RMON extensions to the RMON-1\netherStatsTable.")
etherStatsHighCapacityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 1, 7, 1)).setIndexNames((0, "RMON-MIB", "etherStatsIndex"))
if mibBuilder.loadTexts: etherStatsHighCapacityEntry.setDescription("Contains the High Capacity RMON extensions to the RMON-1\netherStatsEntry. These objects will be created by the agent\nfor all etherStatsEntries it deems appropriate.")
etherStatsHighCapacityOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 1, 7, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherStatsHighCapacityOverflowPkts.setDescription("The number of times the associated etherStatsPkts\ncounter has overflowed.")
etherStatsHighCapacityPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 1, 7, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherStatsHighCapacityPkts.setDescription("The total number of packets (including bad packets,\nbroadcast packets, and multicast packets) received.")
etherStatsHighCapacityOverflowOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 1, 7, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherStatsHighCapacityOverflowOctets.setDescription("The number of times the associated etherStatsOctets\ncounter has overflowed.")
etherStatsHighCapacityOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 1, 7, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherStatsHighCapacityOctets.setDescription("The total number of octets of data (including\nthose in bad packets) received on the\nnetwork (excluding framing bits but including\nFCS octets).\n\nIf the network is half-duplex Fast Ethernet, this\nobject can be used as a reasonable estimate of\nutilization. If greater precision is desired, the\netherStatsHighCapacityPkts and\netherStatsHighCapacityOctets objects should be sampled\nbefore and after a common interval.  The differences\nin the sampled values are Pkts and Octets,\nrespectively, and the number of seconds in the\ninterval is Interval.  These values\nare used to calculate the Utilization as follows:\n\n\n\n\n\n\n                Pkts * (.96 + .64) + (Octets * .08)\nUtilization = -------------------------------------\n                        Interval * 10,000\n\nThe result of this equation is the value Utilization\nwhich is the percent utilization of the ethernet\nsegment on a scale of 0 to 100 percent.\n\nThis table is not appropriate for monitoring full-duplex\nethernets. If the network is a full-duplex ethernet and the\nmediaIndependentTable is monitoring that network, the\nutilization can be calculated as follows:\n\n1) Determine the utilization of the inbound path by using\n   the appropriate equation (for ethernet or fast ethernet)\n   to determine the utilization, substituting\n   mediaIndependentInPkts for etherStatsHighCapacityPkts, and\n   mediaIndependentInOctets for etherStatsHighCapacityOctets.\n   Call the resulting utilization inUtilization.\n\n2) Determine the utilization of the outbound path by using\n   the same equation to determine the utilization, substituting\n   mediaIndependentOutPkts for etherStatsHighCapacityPkts, and\n   mediaIndependentOutOctets for etherStatsHighCapacityOctets.\n   Call the resulting utilization outUtilization.\n\n3) The utilization is the maximum of inUtilization and\n   outUtilization. This metric shows the amount of percentage\n   of bandwidth that is left before congestion will be\n   experienced on the link.")
etherStatsHighCapacityOverflowPkts64Octets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 1, 7, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherStatsHighCapacityOverflowPkts64Octets.setDescription("The number of times the associated etherStatsPkts64Octets\ncounter has overflowed.")
etherStatsHighCapacityPkts64Octets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 1, 7, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherStatsHighCapacityPkts64Octets.setDescription("The total number of packets (including bad\npackets) received that were 64 octets in length\n(excluding framing bits but including FCS octets).")
etherStatsHighCapacityOverflowPkts65to127Octets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 1, 7, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherStatsHighCapacityOverflowPkts65to127Octets.setDescription("The number of times the associated etherStatsPkts65to127Octets\ncounter has overflowed.")
etherStatsHighCapacityPkts65to127Octets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 1, 7, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherStatsHighCapacityPkts65to127Octets.setDescription("The total number of packets (including bad\npackets) received that were between\n65 and 127 octets in length inclusive\n(excluding framing bits but including FCS octets).")
etherStatsHighCapacityOverflowPkts128to255Octets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 1, 7, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherStatsHighCapacityOverflowPkts128to255Octets.setDescription("The number of times the associated etherStatsPkts128to255Octets\ncounter has overflowed.")
etherStatsHighCapacityPkts128to255Octets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 1, 7, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherStatsHighCapacityPkts128to255Octets.setDescription("The total number of packets (including bad\npackets) received that were between\n128 and 255 octets in length inclusive\n(excluding framing bits but including FCS octets).")
etherStatsHighCapacityOverflowPkts256to511Octets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 1, 7, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherStatsHighCapacityOverflowPkts256to511Octets.setDescription("The number of times the associated etherStatsPkts256to511Octets\ncounter has overflowed.")
etherStatsHighCapacityPkts256to511Octets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 1, 7, 1, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherStatsHighCapacityPkts256to511Octets.setDescription("The total number of packets (including bad\npackets) received that were between\n256 and 511 octets in length inclusive\n(excluding framing bits but including FCS octets).")
etherStatsHighCapacityOverflowPkts512to1023Octets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 1, 7, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherStatsHighCapacityOverflowPkts512to1023Octets.setDescription("The number of times the associated\netherStatsPkts512to1023Octets counter has overflowed.")
etherStatsHighCapacityPkts512to1023Octets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 1, 7, 1, 14), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherStatsHighCapacityPkts512to1023Octets.setDescription("The total number of packets (including bad\npackets) received that were between\n512 and 1023 octets in length inclusive\n(excluding framing bits but including FCS octets).")
etherStatsHighCapacityOverflowPkts1024to1518Octets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 1, 7, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherStatsHighCapacityOverflowPkts1024to1518Octets.setDescription("The number of times the associated\netherStatsPkts1024to1518Octets counter has overflowed.")
etherStatsHighCapacityPkts1024to1518Octets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 1, 7, 1, 16), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherStatsHighCapacityPkts1024to1518Octets.setDescription("The total number of packets (including bad\npackets) received that were between\n1024 and 1518 octets in length inclusive\n(excluding framing bits but including FCS octets).")
etherHistoryHighCapacityTable = MibTable((1, 3, 6, 1, 2, 1, 16, 2, 6))
if mibBuilder.loadTexts: etherHistoryHighCapacityTable.setDescription("Contains the High Capacity RMON extensions to the RMON-1\netherHistoryTable.")
etherHistoryHighCapacityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 2, 6, 1)).setIndexNames((0, "RMON-MIB", "etherHistoryIndex"), (0, "RMON-MIB", "etherHistorySampleIndex"))
if mibBuilder.loadTexts: etherHistoryHighCapacityEntry.setDescription("Contains the High Capacity RMON extensions to the RMON-1\netherHistoryEntry. These objects will be created by the agent\nfor all etherHistoryEntries associated with whichever\nhistoryControlEntries it deems appropriate. (i.e., either all\netherHistoryHighCapacityEntries associated with a particular\nhistoryControlEntry will be created, or none of them will\nbe.)")
etherHistoryHighCapacityOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 2, 6, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherHistoryHighCapacityOverflowPkts.setDescription("The number of times the associated etherHistoryPkts\nGauge overflowed during this sampling interval.")
etherHistoryHighCapacityPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 2, 6, 1, 2), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherHistoryHighCapacityPkts.setDescription("The total number of packets (including bad packets,\nbroadcast packets, and multicast packets) received during\nthis sampling interval.")
etherHistoryHighCapacityOverflowOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 2, 6, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherHistoryHighCapacityOverflowOctets.setDescription("The number of times the associated etherHistoryOctets\ncounter has overflowed during this sampling interval.")
etherHistoryHighCapacityOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 2, 6, 1, 4), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherHistoryHighCapacityOctets.setDescription("The total number of octets of data (including\nthose in bad packets) received on the\nnetwork (excluding framing bits but including\nFCS octets) during this sampling interval.")
hostHighCapacityTable = MibTable((1, 3, 6, 1, 2, 1, 16, 4, 5))
if mibBuilder.loadTexts: hostHighCapacityTable.setDescription("Contains the High Capacity RMON extensions to the RMON-1\nhostTable.")
hostHighCapacityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 4, 5, 1)).setIndexNames((0, "RMON-MIB", "hostIndex"), (0, "RMON-MIB", "hostAddress"))
if mibBuilder.loadTexts: hostHighCapacityEntry.setDescription("Contains the High Capacity RMON extensions to the RMON-1\nhostEntry. These objects will be created by the agent\nfor all hostEntries associated with whichever\nhostControlEntries it deems appropriate. (i.e., either all\nhostHighCapacityEntries associated with a particular\nhostControlEntry will be created, or none of them will\nbe.)")
hostHighCapacityInOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 4, 5, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostHighCapacityInOverflowPkts.setDescription("The number of times the associated hostInPkts\ncounter has overflowed.")
hostHighCapacityInPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 4, 5, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostHighCapacityInPkts.setDescription("The number of good packets transmitted to\nthis address since it was added to the\nhostHighCapacityTable.")
hostHighCapacityOutOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 4, 5, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostHighCapacityOutOverflowPkts.setDescription("The number of times the associated hostOutPkts\ncounter has overflowed.")
hostHighCapacityOutPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 4, 5, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostHighCapacityOutPkts.setDescription("The number of packets, including bad packets, transmitted\nby this address since it was added to the\nhostHighCapacityTable.")
hostHighCapacityInOverflowOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 4, 5, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostHighCapacityInOverflowOctets.setDescription("The number of times the associated hostInOctets\ncounter has overflowed.")
hostHighCapacityInOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 4, 5, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostHighCapacityInOctets.setDescription("The number of octets transmitted to this address\nsince it was added to the hostHighCapacityTable (excluding\nframing bits but including FCS octets), except for\n\n\n\nthose octets in bad packets.")
hostHighCapacityOutOverflowOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 4, 5, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostHighCapacityOutOverflowOctets.setDescription("The number of times the associated hostOutOctets\ncounter has overflowed.")
hostHighCapacityOutOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 4, 5, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostHighCapacityOutOctets.setDescription("The number of octets transmitted by this address\nsince it was added to the hostHighCapacityTable (excluding\nframing bits but including FCS octets), including\nthose octets in bad packets.")
hostTimeHighCapacityTable = MibTable((1, 3, 6, 1, 2, 1, 16, 4, 6))
if mibBuilder.loadTexts: hostTimeHighCapacityTable.setDescription("Contains the High Capacity RMON extensions to the RMON-1\nhostTimeTable.")
hostTimeHighCapacityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 4, 6, 1)).setIndexNames((0, "RMON-MIB", "hostTimeIndex"), (0, "RMON-MIB", "hostTimeCreationOrder"))
if mibBuilder.loadTexts: hostTimeHighCapacityEntry.setDescription("Contains the High Capacity RMON extensions to the RMON-1\nhostTimeEntry. These objects will be created by the agent\nfor all hostTimeEntries associated with whichever\nhostControlEntries it deems appropriate. (i.e., either all\nhostTimeHighCapacityEntries associated with a particular\nhostControlEntry will be created, or none of them will\nbe.)")
hostTimeHighCapacityInOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 4, 6, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostTimeHighCapacityInOverflowPkts.setDescription("The number of times the associated hostTimeInPkts\ncounter has overflowed.")
hostTimeHighCapacityInPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 4, 6, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostTimeHighCapacityInPkts.setDescription("The number of good packets transmitted to this address\nsince it was added to the hostTimeHighCapacityTable.")
hostTimeHighCapacityOutOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 4, 6, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostTimeHighCapacityOutOverflowPkts.setDescription("The number of times the associated hostTimeOutPkts\ncounter has overflowed.")
hostTimeHighCapacityOutPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 4, 6, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostTimeHighCapacityOutPkts.setDescription("The number of packets, including bad packets, transmitted\nby this address since it was added to the\nhostTimeHighCapacityTable.")
hostTimeHighCapacityInOverflowOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 4, 6, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostTimeHighCapacityInOverflowOctets.setDescription("The number of times the associated hostTimeInOctets\ncounter has overflowed.")
hostTimeHighCapacityInOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 4, 6, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostTimeHighCapacityInOctets.setDescription("The number of octets transmitted to this address\nsince it was added to the hostTimeHighCapacityTable\n(excluding framing bits but including FCS octets),\nexcept for those octets in bad packets.")
hostTimeHighCapacityOutOverflowOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 4, 6, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostTimeHighCapacityOutOverflowOctets.setDescription("The number of times the associated hostTimeOutOctets\ncounter has overflowed.")
hostTimeHighCapacityOutOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 4, 6, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostTimeHighCapacityOutOctets.setDescription("The number of octets transmitted by this address since\nit was added to the hostTimeTable (excluding framing\nbits but including FCS octets), including those\n\n\n\noctets in bad packets.")
hostTopNHighCapacityTable = MibTable((1, 3, 6, 1, 2, 1, 16, 5, 3))
if mibBuilder.loadTexts: hostTopNHighCapacityTable.setDescription("Contains the High Capacity RMON extensions to the RMON-1\nhostTopNTable when hostTopNRateBase specifies a High Capacity\nTopN Report.")
hostTopNHighCapacityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 5, 3, 1)).setIndexNames((0, "RMON-MIB", "hostTopNReport"), (0, "RMON-MIB", "hostTopNIndex"))
if mibBuilder.loadTexts: hostTopNHighCapacityEntry.setDescription("Contains the High Capacity RMON extensions to the RMON-1\nhostTopNEntry when hostTopNRateBase specifies a High Capacity\nTopN Report. These objects will be created by the agent\nfor all hostTopNEntries associated with whichever\nhostTopNControlEntries have a hostTopNRateBase that specify\na high capacity report.")
hostTopNHighCapacityAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 5, 3, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostTopNHighCapacityAddress.setDescription("The physical address of this host.")
hostTopNHighCapacityBaseRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 5, 3, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostTopNHighCapacityBaseRate.setDescription("The amount of change in the selected variable\nduring this sampling interval, modulo 2^32.  The\nselected variable is this host's instance of the\nobject selected by hostTopNRateBase.")
hostTopNHighCapacityOverflowRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 5, 3, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostTopNHighCapacityOverflowRate.setDescription("The amount of change in the selected variable\nduring this sampling interval, divided by 2^32, truncating\nfractions (i.e., X DIV 2^32).  The selected variable is\nthis host's instance of the object selected by\nhostTopNRateBase.")
hostTopNHighCapacityRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 5, 3, 1, 4), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostTopNHighCapacityRate.setDescription("The amount of change in the selected variable\nduring this sampling interval.  The selected\nvariable is this host's instance of the object\nselected by hostTopNRateBase.")
matrixSDHighCapacityTable = MibTable((1, 3, 6, 1, 2, 1, 16, 6, 5))
if mibBuilder.loadTexts: matrixSDHighCapacityTable.setDescription("Contains the High Capacity RMON extensions to the RMON-1\nmatrixSDTable.")
matrixSDHighCapacityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 6, 5, 1)).setIndexNames((0, "RMON-MIB", "matrixSDIndex"), (0, "RMON-MIB", "matrixSDSourceAddress"), (0, "RMON-MIB", "matrixSDDestAddress"))
if mibBuilder.loadTexts: matrixSDHighCapacityEntry.setDescription("Contains the High Capacity RMON extensions to the RMON-1\nmatrixSDEntry. These objects will be created by the agent\n\n\n\nfor all matrixSDEntries associated with whichever\nmatrixControlEntries it deems appropriate. (i.e., either all\nmatrixSDHighCapacityEntries associated with a particular\nmatrixControlEntry will be created, or none of them will\nbe.)")
matrixSDHighCapacityOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 6, 5, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: matrixSDHighCapacityOverflowPkts.setDescription("The number of times the associated matrixSDPkts\ncounter has overflowed.")
matrixSDHighCapacityPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 6, 5, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: matrixSDHighCapacityPkts.setDescription("The number of packets transmitted from the source\naddress to the destination address (this number\nincludes bad packets).")
matrixSDHighCapacityOverflowOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 6, 5, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: matrixSDHighCapacityOverflowOctets.setDescription("The number of times the associated matrixSDOctets\ncounter has overflowed.")
matrixSDHighCapacityOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 6, 5, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: matrixSDHighCapacityOctets.setDescription("The number of octets (excluding framing bits but\nincluding FCS octets) contained in all packets\ntransmitted from the source address to the\ndestination address.")
matrixDSHighCapacityTable = MibTable((1, 3, 6, 1, 2, 1, 16, 6, 6))
if mibBuilder.loadTexts: matrixDSHighCapacityTable.setDescription("Contains the High Capacity RMON extensions to the RMON-1\nmatrixDSTable.")
matrixDSHighCapacityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 6, 6, 1)).setIndexNames((0, "RMON-MIB", "matrixDSIndex"), (0, "RMON-MIB", "matrixDSDestAddress"), (0, "RMON-MIB", "matrixDSSourceAddress"))
if mibBuilder.loadTexts: matrixDSHighCapacityEntry.setDescription("Contains the High Capacity RMON extensions to the RMON-1\nmatrixDSEntry. These objects will be created by the agent\nfor all matrixDSEntries associated with whichever\nmatrixControlEntries it deems appropriate. (i.e., either all\nmatrixDSHighCapacityEntries associated with a particular\nmatrixControlEntry will be created, or none of them will\nbe.)")
matrixDSHighCapacityOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 6, 6, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: matrixDSHighCapacityOverflowPkts.setDescription("The number of times the associated matrixDSPkts\ncounter has overflowed.")
matrixDSHighCapacityPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 6, 6, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: matrixDSHighCapacityPkts.setDescription("The number of packets transmitted from the source\naddress to the destination address (this number\nincludes bad packets).")
matrixDSHighCapacityOverflowOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 6, 6, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: matrixDSHighCapacityOverflowOctets.setDescription("The number of times the associated matrixDSOctets\ncounter has overflowed.")
matrixDSHighCapacityOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 6, 6, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: matrixDSHighCapacityOctets.setDescription("The number of octets (excluding framing bits\nbut including FCS octets) contained in all packets\ntransmitted from the source address to the\ndestination address.")
captureBufferHighCapacityTable = MibTable((1, 3, 6, 1, 2, 1, 16, 8, 3))
if mibBuilder.loadTexts: captureBufferHighCapacityTable.setDescription("Contains the High Capacity RMON extensions to the RMON-1\n\n\n\ncaptureBufferTable.")
captureBufferHighCapacityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 8, 3, 1)).setIndexNames((0, "RMON-MIB", "captureBufferControlIndex"), (0, "RMON-MIB", "captureBufferIndex"))
if mibBuilder.loadTexts: captureBufferHighCapacityEntry.setDescription("Contains the High Capacity RMON extensions to the RMON-1\ncaptureBufferEntry. These objects will be created by the agent\nfor all captureBufferEntries associated with whichever\nbufferControlEntries it deems appropriate. (i.e., either all\ncaptureBufferHighCapacityEntries associated with a particular\nbufferControlEntry will be created, or none of them will\nbe.)")
captureBufferPacketHighCapacityTime = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 8, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 999999))).setMaxAccess("readonly")
if mibBuilder.loadTexts: captureBufferPacketHighCapacityTime.setDescription("The number of nanoseconds that had passed since this capture\nbuffer was first turned on when this packet was captured,\nmodulo 10^6.\n\nThis object is used in conjunction with the\ncaptureBufferPacketTime object. This object returns the\nnumber of nano-seconds to be added to to number of\nmilli-seconds obtained from the captureBufferPacketTime\nobject, to obtain more accurate inter packet arrival time.")
protocolDistStatsHighCapacityTable = MibTable((1, 3, 6, 1, 2, 1, 16, 12, 3))
if mibBuilder.loadTexts: protocolDistStatsHighCapacityTable.setDescription("Contains the High Capacity RMON extensions to the RMON-2\nprotocolDistStatsTable.")
protocolDistStatsHighCapacityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 12, 3, 1)).setIndexNames((0, "RMON2-MIB", "protocolDistControlIndex"), (0, "RMON2-MIB", "protocolDirLocalIndex"))
if mibBuilder.loadTexts: protocolDistStatsHighCapacityEntry.setDescription("Contains the High Capacity RMON extensions to the RMON-2\nprotocolDistStatsTable. These objects will be created by the\nagent for all protocolDistStatsEntries associated with\nwhichever protocolDistControlEntries it deems appropriate.\n(i.e., either all protocolDistStatsHighCapacityEntries\nassociated with a particular protocolDistControlEntry will be\ncreated, or none of them will be.)")
protocolDistStatsHighCapacityOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 12, 3, 1, 1), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: protocolDistStatsHighCapacityOverflowPkts.setDescription("The number of times the associated protocolDistStatsPkts\ncounter has overflowed.")
protocolDistStatsHighCapacityPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 12, 3, 1, 2), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: protocolDistStatsHighCapacityPkts.setDescription("The number of packets without errors received of this\nprotocol type.  Note that this is the number of link-layer\npackets, so if a single network-layer packet is fragmented\ninto several link-layer frames, this counter is incremented\nseveral times.")
protocolDistStatsHighCapacityOverflowOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 12, 3, 1, 3), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: protocolDistStatsHighCapacityOverflowOctets.setDescription("The number of times the associated protocolDistStatsOctets\ncounter has overflowed.")
protocolDistStatsHighCapacityOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 12, 3, 1, 4), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: protocolDistStatsHighCapacityOctets.setDescription("The number of octets in packets received of this protocol\ntype since it was added to the protocolDistStatsTable\n(excluding framing bits but including FCS octets), except for\nthose octets in packets that contained errors.\n\nNote this doesn't count just those octets in the particular\nprotocol frames, but includes the entire packet that contained\nthe protocol.")
nlHostHighCapacityTable = MibTable((1, 3, 6, 1, 2, 1, 16, 14, 3))
if mibBuilder.loadTexts: nlHostHighCapacityTable.setDescription("Contains the High Capacity RMON extensions to the RMON-2\nnlHostTable.")
nlHostHighCapacityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 14, 3, 1)).setIndexNames((0, "RMON2-MIB", "hlHostControlIndex"), (0, "RMON2-MIB", "nlHostTimeMark"), (0, "RMON2-MIB", "protocolDirLocalIndex"), (0, "RMON2-MIB", "nlHostAddress"))
if mibBuilder.loadTexts: nlHostHighCapacityEntry.setDescription("Contains the High Capacity RMON extensions to the RMON-2\nnlHostEntry. These objects will be created by the agent\nfor all nlHostEntries associated with whichever\nhlHostControlEntries it deems appropriate. (i.e., either all\nnlHostHighCapacityEntries associated with a particular\nhlHostControlEntry will be created, or none of them will\nbe.)")
nlHostHighCapacityInOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 14, 3, 1, 1), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlHostHighCapacityInOverflowPkts.setDescription("The number of times the associated nlHostInPkts\ncounter has overflowed.")
nlHostHighCapacityInPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 14, 3, 1, 2), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlHostHighCapacityInPkts.setDescription("The number of packets without errors transmitted to\nthis address since it was added to the nlHostHighCapacityTable.\nNote that this is the number of link-layer packets, so if a\nsingle network-layer packet is fragmented into several\nlink-layer frames, this counter is incremented several times.")
nlHostHighCapacityOutOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 14, 3, 1, 3), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlHostHighCapacityOutOverflowPkts.setDescription("The number of times the associated nlHostOutPkts\ncounter has overflowed.")
nlHostHighCapacityOutPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 14, 3, 1, 4), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlHostHighCapacityOutPkts.setDescription("The number of packets without errors transmitted by\nthis address since it was added to the nlHostHighCapacityTable.\nNote that this is the number of link-layer packets, so if a\nsingle network-layer packet is fragmented into several\nlink-layer frames, this counter is incremented several times.")
nlHostHighCapacityInOverflowOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 14, 3, 1, 5), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlHostHighCapacityInOverflowOctets.setDescription("The number of times the associated nlHostInOctets\ncounter has overflowed.")
nlHostHighCapacityInOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 14, 3, 1, 6), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlHostHighCapacityInOctets.setDescription("The number of octets transmitted to this address\nsince it was added to the nlHostHighCapacityTable\n(excluding framing bits but including FCS octets),\nexcluding those octets in packets that contained\nerrors.\n\nNote this doesn't count just those octets in the\nparticular protocol frames, but includes the entire\npacket that contained the protocol.")
nlHostHighCapacityOutOverflowOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 14, 3, 1, 7), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlHostHighCapacityOutOverflowOctets.setDescription("The number of times the associated nlHostOutOctets\ncounter has overflowed.")
nlHostHighCapacityOutOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 14, 3, 1, 8), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlHostHighCapacityOutOctets.setDescription("The number of octets transmitted by this address\nsince it was added to the nlHostHighCapacityTable\n(excluding framing bits but including FCS octets),\nexcluding those octets in packets that contained\nerrors.\n\nNote this doesn't count just those octets in the\nparticular protocol frames, but includes the entire\npacket that contained the protocol.")
nlMatrixSDHighCapacityTable = MibTable((1, 3, 6, 1, 2, 1, 16, 15, 6))
if mibBuilder.loadTexts: nlMatrixSDHighCapacityTable.setDescription("Contains the High Capacity RMON extensions to the RMON-2\nnlMatrixTable.")
nlMatrixSDHighCapacityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 15, 6, 1)).setIndexNames((0, "RMON2-MIB", "hlMatrixControlIndex"), (0, "RMON2-MIB", "nlMatrixSDTimeMark"), (0, "RMON2-MIB", "protocolDirLocalIndex"), (0, "RMON2-MIB", "nlMatrixSDSourceAddress"), (0, "RMON2-MIB", "nlMatrixSDDestAddress"))
if mibBuilder.loadTexts: nlMatrixSDHighCapacityEntry.setDescription("Contains the High Capacity RMON extensions to the RMON-2\nnlMatrixEntry. These objects will be created by the agent\nfor all nlMatrixSDEntries associated with whichever\nhlMatrixControlEntries it deems appropriate. (i.e., either all\nnlMatrixSDHighCapacityEntries associated with a particular\nhlMatrixControlEntry will be created, or none of them will\nbe.)")
nlMatrixSDHighCapacityOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 6, 1, 1), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixSDHighCapacityOverflowPkts.setDescription("The number of times the associated nlMatrixSDPkts\ncounter has overflowed.")
nlMatrixSDHighCapacityPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 6, 1, 2), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixSDHighCapacityPkts.setDescription("The number of packets without errors transmitted from the\nsource address to the destination address since this entry was\nadded to the nlMatrixSDHighCapacityTable.  Note that this is\nthe number of link-layer packets, so if a single network-layer\npacket is fragmented into several link-layer frames, this\ncounter is incremented several times.")
nlMatrixSDHighCapacityOverflowOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 6, 1, 3), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixSDHighCapacityOverflowOctets.setDescription("The number of times the associated nlMatrixSDOctets\ncounter has overflowed.")
nlMatrixSDHighCapacityOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 6, 1, 4), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixSDHighCapacityOctets.setDescription("The number of octets transmitted from the source address to\nthe destination address since this entry was added to the\n\n\n\nnlMatrixSDHighCapacityTable (excluding framing bits but\nincluding FCS octets), excluding those octets in packets that\ncontained errors.\n\nNote this doesn't count just those octets in the particular\nprotocol frames, but includes the entire packet that contained\nthe protocol.")
nlMatrixDSHighCapacityTable = MibTable((1, 3, 6, 1, 2, 1, 16, 15, 7))
if mibBuilder.loadTexts: nlMatrixDSHighCapacityTable.setDescription("Contains the High Capacity RMON extensions to the RMON-2\nnlMatrixDSTable.")
nlMatrixDSHighCapacityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 15, 7, 1)).setIndexNames((0, "RMON2-MIB", "hlMatrixControlIndex"), (0, "RMON2-MIB", "nlMatrixDSTimeMark"), (0, "RMON2-MIB", "protocolDirLocalIndex"), (0, "RMON2-MIB", "nlMatrixDSDestAddress"), (0, "RMON2-MIB", "nlMatrixDSSourceAddress"))
if mibBuilder.loadTexts: nlMatrixDSHighCapacityEntry.setDescription("Contains the High Capacity RMON extensions to the RMON-2\nnlMatrixDSEntry. These objects will be created by the agent\nfor all nlMatrixDSEntries associated with whichever\nhlmatrixControlEntries it deems appropriate. (i.e., either all\nnlMatrixDSHighCapacityEntries associated with a particular\nhlMatrixControlEntry will be created, or none of them will\nbe.)")
nlMatrixDSHighCapacityOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 7, 1, 1), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixDSHighCapacityOverflowPkts.setDescription("The number of times the associated nlMatrixDSPkts\ncounter has overflowed.")
nlMatrixDSHighCapacityPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 7, 1, 2), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixDSHighCapacityPkts.setDescription("The number of packets without errors transmitted from the\nsource address to the destination address since this entry was\nadded to the nlMatrixDSHighCapacityTable.  Note that this is\nthe number of link-layer packets, so if a single network-layer\npacket is fragmented into several link-layer frames, this\ncounter is incremented several times.")
nlMatrixDSHighCapacityOverflowOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 7, 1, 3), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixDSHighCapacityOverflowOctets.setDescription("The number of times the associated nlMatrixDSOctets\ncounter has overflowed.")
nlMatrixDSHighCapacityOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 7, 1, 4), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixDSHighCapacityOctets.setDescription("The number of octets transmitted from the source address\nto the destination address since this entry was added to the\nnlMatrixDSHighCapacityTable (excluding framing bits but\nincluding FCS octets), excluding those octets in packets that\ncontained errors.\n\nNote this doesn't count just those octets in the particular\nprotocol frames, but includes the entire packet that contained\nthe protocol.")
nlMatrixTopNHighCapacityTable = MibTable((1, 3, 6, 1, 2, 1, 16, 15, 8))
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityTable.setDescription("Contains the High Capacity RMON extensions to the RMON-2\nnlMatrixTopNTable when nlMatrixTopNControlRateBase specifies\na High Capacity TopN Report.")
nlMatrixTopNHighCapacityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 15, 8, 1)).setIndexNames((0, "RMON2-MIB", "nlMatrixTopNControlIndex"), (0, "RMON2-MIB", "nlMatrixTopNIndex"))
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityEntry.setDescription("Contains the High Capacity RMON extensions to the RMON-2\nnlMatrixTopNEntry when nlMatrixTopNControlRateBase specifies\na High Capacity TopN Report. These objects will be created by\nthe agent for all nlMatrixTopNEntries associated with whichever\nnlMatrixTopNControlEntries have a nlMatrixTopNControlRateBase\nthat specify a high capacity report.")
nlMatrixTopNHighCapacityProtocolDirLocalIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityProtocolDirLocalIndex.setDescription("The protocolDirLocalIndex of the network layer protocol of\n\n\n\nthis entry's network address.")
nlMatrixTopNHighCapacitySourceAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 8, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixTopNHighCapacitySourceAddress.setDescription("The network layer address of the source host in this\nconversation.\n\nThis is represented as an octet string with\nspecific semantics and length as identified\nby the associated nlMatrixTopNProtocolDirLocalIndex.\n\nFor example, if the protocolDirLocalIndex indicates an\nencapsulation of ip, this object is encoded as a length\noctet of 4, followed by the 4 octets of the ip address,\nin network byte order.")
nlMatrixTopNHighCapacityDestAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 8, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityDestAddress.setDescription("The network layer address of the destination host in this\nconversation.\n\nThis is represented as an octet string with\nspecific semantics and length as identified\nby the associated nlMatrixTopNProtocolDirLocalIndex.\n\nFor example, if the nlMatrixTopNProtocolDirLocalIndex\nindicates an encapsulation of ip, this object is encoded as a\nlength octet of 4, followed by the 4 octets of the ip address,\nin network byte order.")
nlMatrixTopNHighCapacityBasePktRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 8, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityBasePktRate.setDescription("The number of packets seen from the source host\nto the destination host during this sampling interval,\nmodulo 2^32, counted using the rules for counting the\n\n\n\nnlMatrixSDPkts object.")
nlMatrixTopNHighCapacityOverflowPktRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 8, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityOverflowPktRate.setDescription("The number of packets seen from the source host\nto the destination host during this sampling interval,\ndivided by 2^32, truncating fractions (i.e., X DIV 2^32),\nand counted using the rules for counting the\nnlMatrixSDPkts object.")
nlMatrixTopNHighCapacityPktRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 8, 1, 6), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityPktRate.setDescription("The number of packets seen from the source host to the\ndestination host during this sampling interval, counted\nusing the rules for counting the nlMatrixSDPkts object.\nIf the value of nlMatrixTopNControlRateBase is\nnlMatrixTopNHighCapacityPkts, this variable will be\nused to sort this report.")
nlMatrixTopNHighCapacityReverseBasePktRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 8, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityReverseBasePktRate.setDescription("The number of packets seen from the destination host to the\nsource host during this sampling interval, modulo 2^32, counted\nusing the rules for counting the nlMatrixSDPkts object (note\nthat the corresponding nlMatrixSDPkts object selected is the\none whose source address is equal to nlMatrixTopNDestAddress\nand whose destination address is equal to\nnlMatrixTopNSourceAddress.)\n\nNote that if the value of nlMatrixTopNControlRateBase is equal\nto nlMatrixTopNHighCapacityPkts, the sort of topN entries is\nbased entirely on nlMatrixTopNHighCapacityPktRate, and not on\nthe value of this object.")
nlMatrixTopNHighCapacityReverseOverflowPktRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 8, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityReverseOverflowPktRate.setDescription("The number of packets seen from the destination host to the\nsource host during this sampling interval, divided by 2^32,\ntruncating fractions (i.e., X DIV 2^32), and counted\nusing the rules for counting the nlMatrixSDPkts object (note\nthat the corresponding nlMatrixSDPkts object selected is the\none whose source address is equal to nlMatrixTopNDestAddress\nand whose destination address is equal to\nnlMatrixTopNSourceAddress.)\n\nNote that if the value of nlMatrixTopNControlRateBase is equal\nto nlMatrixTopNHighCapacityPkts, the sort of topN entries is\nbased entirely on nlMatrixTopNHighCapacityPktRate, and not on\nthe value of this object.")
nlMatrixTopNHighCapacityReversePktRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 8, 1, 9), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityReversePktRate.setDescription("The number of packets seen from the destination host to the\nsource host during this sampling interval, counted\nusing the rules for counting the nlMatrixSDPkts object (note\nthat the corresponding nlMatrixSDPkts object selected is the\none whose source address is equal to nlMatrixTopNDestAddress\nand whose destination address is equal to\nnlMatrixTopNSourceAddress.)\n\nNote that if the value of nlMatrixTopNControlRateBase is equal\nto nlMatrixTopNHighCapacityPkts, the sort of topN entries is\nbased entirely on nlMatrixTopNHighCapacityPktRate, and not on\nthe value of this object.")
nlMatrixTopNHighCapacityBaseOctetRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 8, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityBaseOctetRate.setDescription("The number of octets seen from the source host to the\ndestination host during this sampling interval, modulo 2^32,\ncounted using the rules for counting the nlMatrixSDOctets\nobject.")
nlMatrixTopNHighCapacityOverflowOctetRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 8, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityOverflowOctetRate.setDescription("The number of octets seen from the source host\nto the destination host during this sampling interval,\ndivided by 2^32, truncating fractions (i.e., X DIV 2^32),\nand counted using the rules for counting the\nnlMatrixSDOctets object.")
nlMatrixTopNHighCapacityOctetRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 8, 1, 12), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityOctetRate.setDescription("The number of octets seen from the source host\nto the destination host during this sampling interval,\ncounted using the rules for counting the\nnlMatrixSDOctets object.\nIf the value of nlMatrixTopNControlRateBase is\nnlMatrixTopNHighCapacityOctets, this variable will be used\nto sort this report.")
nlMatrixTopNHighCapacityReverseBaseOctetRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 8, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityReverseBaseOctetRate.setDescription("The number of octets seen from the destination host to the\nsource host during this sampling interval, modulo 2^32, counted\nusing the rules for counting the nlMatrixSDOctets object (note\nthat the corresponding nlMatrixSDOctets object selected is the\none whose source address is equal to nlMatrixTopNDestAddress\nand whose destination address is equal to\nnlMatrixTopNSourceAddress.)\n\n\n\nNote that if the value of nlMatrixTopNControlRateBase is equal\nto nlMatrixTopNHighCapacityOctets, the sort of topN entries is\nbased entirely on nlMatrixTopNHighCapacityOctetRate, and not on\nthe value of this object.")
nlMatrixTopNHighCapacityReverseOverflowOctetRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 8, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityReverseOverflowOctetRate.setDescription("The number of octets seen from the destination host to the\nsource host during this sampling interval, divided by 2^32,\ntruncating fractions (i.e., X DIV 2^32), and counted\nusing the rules for counting the nlMatrixSDOctets object (note\nthat the corresponding nlMatrixSDOctets object selected is the\none whose source address is equal to nlMatrixTopNDestAddress\nand whose destination address is equal to\nnlMatrixTopNSourceAddress.)\n\nNote that if the value of nlMatrixTopNControlRateBase is equal\nto nlMatrixTopNHighCapacityOctets, the sort of topN entries is\nbased entirely on nlMatrixTopNHighCapacityOctetRate, and not on\nthe value of this object.")
nlMatrixTopNHighCapacityReverseOctetRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 8, 1, 15), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityReverseOctetRate.setDescription("The number of octets seen from the destination host to the\nsource host during this sampling interval, counted\nusing the rules for counting the nlMatrixSDOctets object (note\nthat the corresponding nlMatrixSDOctets object selected is the\none whose source address is equal to nlMatrixTopNDestAddress\nand whose destination address is equal to\nnlMatrixTopNSourceAddress.)\n\nNote that if the value of nlMatrixTopNControlRateBase is equal\nto nlMatrixTopNHighCapacityOctets, the sort of topN entries is\nbased entirely on nlMatrixTopNHighCapacityOctetRate, and not on\nthe value of this object.")
alHostHighCapacityTable = MibTable((1, 3, 6, 1, 2, 1, 16, 16, 2))
if mibBuilder.loadTexts: alHostHighCapacityTable.setDescription("Contains the High Capacity RMON extensions to the RMON-2\nalHostTable.")
alHostHighCapacityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 16, 2, 1)).setIndexNames((0, "RMON2-MIB", "hlHostControlIndex"), (0, "RMON2-MIB", "alHostTimeMark"), (0, "RMON2-MIB", "protocolDirLocalIndex"), (0, "RMON2-MIB", "nlHostAddress"), (0, "RMON2-MIB", "protocolDirLocalIndex"))
if mibBuilder.loadTexts: alHostHighCapacityEntry.setDescription("Contains the High Capacity RMON extensions to the RMON-2\nalHostEntry. These objects will be created by the agent\nfor all alHostEntries associated with whichever\nhlHostControlEntries it deems appropriate. (i.e., either all\nalHostHighCapacityEntries associated with a particular\nhlHostControlEntry will be created, or none of them will\nbe.)")
alHostHighCapacityInOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 16, 2, 1, 1), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alHostHighCapacityInOverflowPkts.setDescription("The number of times the associated alHostInPkts\ncounter has overflowed.")
alHostHighCapacityInPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 16, 2, 1, 2), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alHostHighCapacityInPkts.setDescription("The number of packets of this protocol type without errors\ntransmitted to this address since it was added to the\nalHostHighCapacityTable.  Note that this is the number of\nlink-layer packets, so if a single network-layer packet\nis fragmented into several link-layer frames, this counter\nis incremented several times.")
alHostHighCapacityOutOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 16, 2, 1, 3), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alHostHighCapacityOutOverflowPkts.setDescription("The number of times the associated alHostOutPkts\ncounter has overflowed.")
alHostHighCapacityOutPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 16, 2, 1, 4), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alHostHighCapacityOutPkts.setDescription("The number of packets of this protocol type without errors\ntransmitted by this address since it was added to the\nalHostHighCapacityTable.  Note that this is the number of\nlink-layer packets, so if a single network-layer packet\nis fragmented into several link-layer frames, this counter\nis incremented several times.")
alHostHighCapacityInOverflowOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 16, 2, 1, 5), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alHostHighCapacityInOverflowOctets.setDescription("The number of times the associated alHostInOctets\ncounter has overflowed.")
alHostHighCapacityInOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 16, 2, 1, 6), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alHostHighCapacityInOctets.setDescription("The number of octets transmitted to this address\nof this protocol type since it was added to the\nalHostHighCapacityTable (excluding framing bits but\nincluding FCS octets), excluding those octets in\npackets that contained errors.\n\nNote this doesn't count just those octets in the particular\nprotocol frames, but includes the entire packet that contained\nthe protocol.")
alHostHighCapacityOutOverflowOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 16, 2, 1, 7), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alHostHighCapacityOutOverflowOctets.setDescription("The number of times the associated alHostOutOctets\ncounter has overflowed.")
alHostHighCapacityOutOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 16, 2, 1, 8), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alHostHighCapacityOutOctets.setDescription("The number of octets transmitted by this address\nof this protocol type since it was added to the\nalHostHighCapacityTable (excluding framing bits but\nincluding FCS octets), excluding those octets in\npackets that contained errors.\n\nNote this doesn't count just those octets in the particular\nprotocol frames, but includes the entire packet that contained\nthe protocol.")
alMatrixSDHighCapacityTable = MibTable((1, 3, 6, 1, 2, 1, 16, 17, 5))
if mibBuilder.loadTexts: alMatrixSDHighCapacityTable.setDescription("Contains the High Capacity RMON extensions to the RMON-2\nalMatrixSDTable.")
alMatrixSDHighCapacityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 17, 5, 1)).setIndexNames((0, "RMON2-MIB", "hlMatrixControlIndex"), (0, "RMON2-MIB", "alMatrixSDTimeMark"), (0, "RMON2-MIB", "protocolDirLocalIndex"), (0, "RMON2-MIB", "nlMatrixSDSourceAddress"), (0, "RMON2-MIB", "nlMatrixSDDestAddress"), (0, "RMON2-MIB", "protocolDirLocalIndex"))
if mibBuilder.loadTexts: alMatrixSDHighCapacityEntry.setDescription("Contains the High Capacity RMON extensions to the RMON-2\nalMatrixSDEntry. These objects will be created by the agent\nfor all alMatrixSDEntries associated with whichever\nhlMatrixControlEntries it deems appropriate. (i.e., either all\nalMatrixSDHighCapacityEntries associated with a particular\nhlMatrixControlEntry will be created, or none of them will\nbe.)")
alMatrixSDHighCapacityOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 5, 1, 1), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixSDHighCapacityOverflowPkts.setDescription("The number of times the associated alMatrixSDPkts\ncounter has overflowed.")
alMatrixSDHighCapacityPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 5, 1, 2), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixSDHighCapacityPkts.setDescription("The number of good packets of this protocol type\ntransmitted from the source address to the destination address\nsince this entry was added to the alMatrixSDHighCapacityTable.\nNote that this is the number of link-layer packets, so if a\nsingle network-layer packet is fragmented into several\nlink-layer frames, this counter is incremented several times.")
alMatrixSDHighCapacityOverflowOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 5, 1, 3), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixSDHighCapacityOverflowOctets.setDescription("The number of times the associated alMatrixSDOctets\ncounter has overflowed.")
alMatrixSDHighCapacityOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 5, 1, 4), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixSDHighCapacityOctets.setDescription("The number of octets in good packets of this protocol type\ntransmitted from the source address to the destination address\nsince this entry was added to the alMatrixSDHighCapacityTable\n(excluding framing bits but including FCS octets).\n\nNote this doesn't count just those octets in the particular\nprotocol frames, but includes the entire packet that contained\nthe protocol.")
alMatrixDSHighCapacityTable = MibTable((1, 3, 6, 1, 2, 1, 16, 17, 6))
if mibBuilder.loadTexts: alMatrixDSHighCapacityTable.setDescription("Contains the High Capacity RMON extensions to the RMON-2\nalMatrixDSTable.")
alMatrixDSHighCapacityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 17, 6, 1)).setIndexNames((0, "RMON2-MIB", "hlMatrixControlIndex"), (0, "RMON2-MIB", "alMatrixDSTimeMark"), (0, "RMON2-MIB", "protocolDirLocalIndex"), (0, "RMON2-MIB", "nlMatrixDSDestAddress"), (0, "RMON2-MIB", "nlMatrixDSSourceAddress"), (0, "RMON2-MIB", "protocolDirLocalIndex"))
if mibBuilder.loadTexts: alMatrixDSHighCapacityEntry.setDescription("Contains the High Capacity RMON extensions to the RMON-2\nalMatrixSDTable. These objects will be created by the agent\nfor all alMatrixDSEntries associated with whichever\nhlMatrixControlEntries it deems appropriate. (i.e., either all\nalMatrixDSHighCapacityEntries associated with a particular\nhlMatrixControlEntry will be created, or none of them will\nbe.)")
alMatrixDSHighCapacityOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 6, 1, 1), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixDSHighCapacityOverflowPkts.setDescription("The number of times the associated alMatrixDSPkts\ncounter has overflowed.")
alMatrixDSHighCapacityPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 6, 1, 2), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixDSHighCapacityPkts.setDescription("The number of good packets of this protocol type\ntransmitted from the source address to the destination address\nsince this entry was added to the alMatrixDSHighCapacityTable.\nNote that this is the number of link-layer packets, so if a\nsingle network-layer packet is fragmented into several\nlink-layer frames, this counter is incremented several times.")
alMatrixDSHighCapacityOverflowOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 6, 1, 3), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixDSHighCapacityOverflowOctets.setDescription("The number of times the associated alMatrixDSOctets\ncounter has overflowed.")
alMatrixDSHighCapacityOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 6, 1, 4), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixDSHighCapacityOctets.setDescription("The number of octets in good packets of this protocol type\ntransmitted from the source address to the destination address\nsince this entry was added to the alMatrixDSHighCapacityTable\n(excluding framing bits but including FCS octets).\n\nNote this doesn't count just those octets in the particular\nprotocol frames, but includes the entire packet that contained\nthe protocol.")
alMatrixTopNHighCapacityTable = MibTable((1, 3, 6, 1, 2, 1, 16, 17, 7))
if mibBuilder.loadTexts: alMatrixTopNHighCapacityTable.setDescription("Contains the High Capacity RMON extensions to the RMON-2\nalMatrixTopNTable when alMatrixTopNControlRateBase specifies\na High Capacity TopN Report.")
alMatrixTopNHighCapacityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 17, 7, 1)).setIndexNames((0, "RMON2-MIB", "alMatrixTopNControlIndex"), (0, "RMON2-MIB", "alMatrixTopNIndex"))
if mibBuilder.loadTexts: alMatrixTopNHighCapacityEntry.setDescription("Contains the High Capacity RMON extensions to the RMON-2\nalMatrixTopNEntry when alMatrixTopNControlRateBase specifies\na High Capacity TopN Report. These objects will be created by\nthe agent for all alMatrixTopNEntries associated with whichever\nalMatrixTopNControlEntries have a alMatrixTopNControlRateBase\nthat specify a high capacity report.")
alMatrixTopNHighCapacityProtocolDirLocalIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixTopNHighCapacityProtocolDirLocalIndex.setDescription("The protocolDirLocalIndex of the network layer protocol of\nthis entry's network address.")
alMatrixTopNHighCapacitySourceAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 7, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixTopNHighCapacitySourceAddress.setDescription("The network layer address of the source host in this\nconversation.\n\nThis is represented as an octet string with\nspecific semantics and length as identified\nby the associated alMatrixTopNProtocolDirLocalIndex.\n\nFor example, if the alMatrixTopNProtocolDirLocalIndex\nindicates an encapsulation of ip, this object is encoded as a\nlength octet of 4, followed by the 4 octets of the ip address,\nin network byte order.")
alMatrixTopNHighCapacityDestAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 7, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixTopNHighCapacityDestAddress.setDescription("The network layer address of the destination host in this\nconversation.\n\nThis is represented as an octet string with\nspecific semantics and length as identified\nby the associated alMatrixTopNProtocolDirLocalIndex.\n\nFor example, if the alMatrixTopNProtocolDirLocalIndex\nindicates an encapsulation of ip, this object is encoded as a\nlength octet of 4, followed by the 4 octets of the ip address,\nin network byte order.")
alMatrixTopNHighCapacityAppProtocolDirLocalIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 7, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixTopNHighCapacityAppProtocolDirLocalIndex.setDescription("The type of the protocol counted by this entry.")
alMatrixTopNHighCapacityBasePktRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 7, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixTopNHighCapacityBasePktRate.setDescription("The number of packets seen of this protocol from the\nsource host to the destination host during this sampling\ninterval, modulo 2^32, counted using the rules for counting\nthe alMatrixSDPkts object.")
alMatrixTopNHighCapacityOverflowPktRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 7, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixTopNHighCapacityOverflowPktRate.setDescription("The number of packets seen of this protocol from the source\nhost to the destination host during this sampling interval,\ndivided by 2^32, truncating fractions (i.e., X DIV 2^32),\nand counted using the rules for counting the\nalMatrixSDPkts object.")
alMatrixTopNHighCapacityPktRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 7, 1, 7), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixTopNHighCapacityPktRate.setDescription("The number of packets seen of this protocol from the source\nhost to the destination host during this sampling interval,\ncounted using the rules for counting the\nalMatrixSDPkts object.\nIf the value of alMatrixTopNControlRateBase is\nalMatrixTopNTerminalsPkts, alMatrixTopNAllPkts,\nalMatrixTopNTerminalsHighCapacityPkts, or\nalMatrixTopNAllHighCapacityPkts, this variable will be used\nto sort this report.")
alMatrixTopNHighCapacityReverseBasePktRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 7, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixTopNHighCapacityReverseBasePktRate.setDescription("The number of packets seen of this protocol from the\ndestination host to the source host during this sampling\ninterval, modulo 2^32, counted using the rules for counting\nthe alMatrixSDPkts object (note that the corresponding\nalMatrixSDPkts object selected is the one whose source address\nis equal to alMatrixTopNDestAddress and whose destination\naddress is equal to alMatrixTopNSourceAddress.)")
alMatrixTopNHighCapacityReverseOverflowPktRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 7, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixTopNHighCapacityReverseOverflowPktRate.setDescription("The number of packets seen of this protocol from the\ndestination host to the source host during this sampling\ninterval, divided by 2^32, truncating fractions\n(i.e., X DIV 2^32), and counted using the rules for\ncounting the alMatrixSDPkts object (note that the\ncorresponding alMatrixSDPkts object selected is the\none whose source address is equal to alMatrixTopNDestAddress\nand whose destination address is equal to\nalMatrixTopNSourceAddress.)")
alMatrixTopNHighCapacityReversePktRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 7, 1, 10), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixTopNHighCapacityReversePktRate.setDescription("The number of packets seen of this protocol from the\ndestination host to the source host during this sampling\ninterval, counted using the rules for counting the\nalMatrixSDPkts object (note that the corresponding\nalMatrixSDPkts object selected is the one whose source address\nis equal to alMatrixTopNDestAddress and whose destination\naddress is equal to alMatrixTopNSourceAddress.)")
alMatrixTopNHighCapacityBaseOctetRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 7, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixTopNHighCapacityBaseOctetRate.setDescription("The number of octets seen of this protocol from the source host\nto the destination host during this sampling interval,\nmodulo 2^32, counted using the rules for counting the\nalMatrixSDOctets object.")
alMatrixTopNHighCapacityOverflowOctetRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 7, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixTopNHighCapacityOverflowOctetRate.setDescription("The number of octets seen of this protocol from the source host\nto the destination host during this sampling interval,\ndivided by 2^32, truncating fractions (i.e., X DIV 2^32),\nand counted using the rules for counting the\nalMatrixSDOctets object.")
alMatrixTopNHighCapacityOctetRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 7, 1, 13), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixTopNHighCapacityOctetRate.setDescription("The number of octets seen of this protocol from the source host\nto the destination host during this sampling interval,\n\n\n\ncounted using the rules for counting the\nalMatrixSDOctets object.\nIf the value of alMatrixTopNControlRateBase is\nalMatrixTopNTerminalsOctets, alMatrixTopNAllOctets,\nalMatrixTopNTerminalsHighCapacityOctets, or\nalMatrixTopNAllHighCapacityOctets, this variable will be used\nto sort this report.")
alMatrixTopNHighCapacityReverseBaseOctetRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 7, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixTopNHighCapacityReverseBaseOctetRate.setDescription("The number of octets seen of this protocol from the\ndestination host to the source host during this sampling\ninterval, modulo 2^32, counted using the rules for counting\nthe alMatrixSDOctets object (note that the corresponding\nalMatrixSDOctets object selected is the one whose source\naddress is equal to alMatrixTopNDestAddress and whose\ndestination address is equal to alMatrixTopNSourceAddress.)")
alMatrixTopNHighCapacityReverseOverflowOctetRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 7, 1, 15), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixTopNHighCapacityReverseOverflowOctetRate.setDescription("The number of octets seen of this protocol from the\ndestination host to the source host during this sampling\ninterval, divided by 2^32, truncating fractions (i.e., X DIV\n2^32), and counted using the rules for counting the\nalMatrixSDOctets object (note that the corresponding\nalMatrixSDOctets object selected is the one whose source\naddress is equal to alMatrixTopNDestAddress and whose\ndestination address is equal to alMatrixTopNSourceAddress.)")
alMatrixTopNHighCapacityReverseOctetRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 7, 1, 16), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixTopNHighCapacityReverseOctetRate.setDescription("The number of octets seen of this protocol from the\ndestination host to the source host during this sampling\n\n\n\ninterval, counted using the rules for counting the\nalMatrixSDOctets object (note that the corresponding\nalMatrixSDOctets object selected is the one whose source\naddress is equal to alMatrixTopNDestAddress and whose\ndestination address is equal to alMatrixTopNSourceAddress.)")
usrHistoryHighCapacityTable = MibTable((1, 3, 6, 1, 2, 1, 16, 18, 4))
if mibBuilder.loadTexts: usrHistoryHighCapacityTable.setDescription("Contains the High Capacity RMON extensions to the RMON-2\nusrHistoryTable.")
usrHistoryHighCapacityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 18, 4, 1)).setIndexNames((0, "RMON2-MIB", "usrHistoryControlIndex"), (0, "RMON2-MIB", "usrHistorySampleIndex"), (0, "RMON2-MIB", "usrHistoryObjectIndex"))
if mibBuilder.loadTexts: usrHistoryHighCapacityEntry.setDescription("Contains the High Capacity RMON extensions to the RMON-2\nusrHistoryEntry. These objects will be created by the agent\nfor all usrHistoryEntries associated with whichever\nusrHistoryControlEntries it deems appropriate. (i.e., either all\nusrHistoryHighCapacityEntries associated with a particular\nusrHistoryControlEntry will be created, or none of them will\nbe.)")
usrHistoryHighCapacityOverflowAbsValue = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 18, 4, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: usrHistoryHighCapacityOverflowAbsValue.setDescription("The absolute value (i.e. unsigned value) of the\nuser-specified statistic during the last sampling period,\ndivided by 2^32, truncating fractions (i.e., X DIV 2^32).\nThe value during the current sampling period is not made\navailable until the period is completed.\n\n\n\n\nTo obtain the true value for this sampling interval, the\nassociated instance of usrHistoryValStatus should be checked,\nand usrHistoryAbsValue adjusted as necessary.\n\nIf the MIB instance could not be accessed during the sampling\ninterval, then this object will have a value of zero and the\nassociated instance of usrHistoryValStatus will be set to\n'valueNotAvailable(1)'.")
usrHistoryHighCapacityAbsValue = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 18, 4, 1, 2), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: usrHistoryHighCapacityAbsValue.setDescription("The absolute value (i.e. unsigned value) of the\nuser-specified statistic during the last sampling period. The\nvalue during the current sampling period is not made available\nuntil the period is completed.\n\nTo obtain the true value for this sampling interval, the\nassociated instance of usrHistoryValStatus should be checked,\nand usrHistoryHighCapacityAbsValue adjusted as necessary.\n\nIf the MIB instance could not be accessed during the sampling\ninterval, then this object will have a value of zero and the\nassociated instance of usrHistoryValStatus will be set to\n'valueNotAvailable(1)'.")
hcRMONCapabilities = MibScalar((1, 3, 6, 1, 2, 1, 16, 19, 16), Bits().subtype(namedValues=NamedValues(("mediaIndependentGroup", 0), ("etherStatsHighCapacityGroup", 1), ("nlMatrixTopNHighCapacityGroup", 10), ("alHostHighCapacityGroup", 11), ("alMatrixHighCapacityGroup", 12), ("alMatrixTopNHighCapacityGroup", 13), ("usrHistoryHighCapacityGroup", 14), ("etherHistoryHighCapacityGroup", 2), ("hostHighCapacityGroup", 3), ("hostTopNHighCapacityGroup", 4), ("matrixHighCapacityGroup", 5), ("captureBufferHighCapacityGroup", 6), ("protocolDistributionHighCapacityGroup", 7), ("nlHostHighCapacityGroup", 8), ("nlMatrixHighCapacityGroup", 9), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcRMONCapabilities.setDescription("An indication of the High Capacity RMON MIB groups supported\non at least one interface by this probe.")
hcRMON = ModuleIdentity((1, 3, 6, 1, 2, 1, 16, 20, 5)).setRevisions(("2002-05-08 00:00",))
if mibBuilder.loadTexts: hcRMON.setOrganization("IETF RMON MIB Working Group")
if mibBuilder.loadTexts: hcRMON.setContactInfo("Steve Waldbusser\n\nPhone: +1-650-948-6500\nFax:   +1-650-745-0671\nEmail: waldbusser@nextbeacon.com\n\nAndy Bierman\nWG Chair\nabierman@cisco.com\n\nRMONMIB WG Mailing List\nrmonmib@ietf.org\nhttp://www.ietf.org/mailman/listinfo/rmonmib")
if mibBuilder.loadTexts: hcRMON.setDescription("The MIB module for managing remote monitoring\ndevice implementations. This MIB module\naugments the original RMON MIB as specified in\nRFC 2819 and RFC 1513 and RMON-2 MIB as specified in\nRFC 2021.")
hcRmonMIBCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 20, 6))
hcRmonMIBGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 20, 7))
mediaIndependentStats = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 21))
mediaIndependentTable = MibTable((1, 3, 6, 1, 2, 1, 16, 21, 1))
if mibBuilder.loadTexts: mediaIndependentTable.setDescription("Media independent statistics for promiscuous monitoring of\nany media.\n\nThe following table defines media independent statistics that\nprovide information for full and/or half-duplex links as well\nas high capacity links.\n\nFor half-duplex links, or full-duplex-capable links operating\nin half-duplex mode, the mediaIndependentIn* objects shall be\nused and the mediaIndependentOut* objects shall not increment.\n\nFor full-duplex links, the mediaIndependentOut* objects shall\nbe present and shall increment. Whenever possible, the probe\nshould count packets moving away from the closest terminating\nequipment as output packets. Failing that, the probe should\ncount packets moving away from the DTE as output packets.")
mediaIndependentEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 21, 1, 1)).setIndexNames((0, "HC-RMON-MIB", "mediaIndependentIndex"))
if mibBuilder.loadTexts: mediaIndependentEntry.setDescription("Media independent statistics for promiscuous monitoring of\nany media.")
mediaIndependentIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: mediaIndependentIndex.setDescription("The value of this object uniquely identifies this\nmediaIndependent entry.")
mediaIndependentDataSource = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 2), ObjectIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mediaIndependentDataSource.setDescription("This object identifies the source of the data that\nthis mediaIndependent entry is configured to analyze.  This\nsource can be any interface on this device.\nIn order to identify a particular interface, this\nobject shall identify the instance of the ifIndex\nobject, defined in RFC 1213 and RFC 2233 [16,17], for\nthe desired interface.  For example, if an entry\nwere to receive data from interface #1, this object\nwould be set to ifIndex.1.\n\nThe statistics in this group reflect all packets\non the local network segment attached to the\nidentified interface.\n\nAn agent may or may not be able to tell if\nfundamental changes to the media of the interface\nhave occurred and necessitate a deletion of\nthis entry.  For example, a hot-pluggable ethernet\ncard could be pulled out and replaced by a\n\n\n\ntoken-ring card.  In such a case, if the agent has\nsuch knowledge of the change, it is recommended that\nit delete this entry.\n\nThis object may not be modified if the associated\nmediaIndependentStatus object is equal to active(1).")
mediaIndependentDropEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentDropEvents.setDescription("The total number of events in which packets\nwere dropped by the probe due to lack of resources.\nNote that this number is not necessarily the number of\npackets dropped; it is just the number of times this\ncondition has been detected.")
mediaIndependentDroppedFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentDroppedFrames.setDescription("The total number of frames which were received by the probe\nand therefore not accounted for in the\nmediaIndependentDropEvents, but for which the probe chose not\nto count for this entry for whatever reason.  Most often, this\nevent occurs when the probe is out of some resources and\ndecides to shed load from this collection.\n\nThis count does not include packets that were not counted\nbecause they had MAC-layer errors.\n\nNote that, unlike the dropEvents counter, this number is the\nexact number of frames dropped.")
mediaIndependentInPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentInPkts.setDescription("The total number of packets (including bad packets,\n\n\n\nbroadcast packets, and multicast packets) received\non a half-duplex link or on the inbound connection of a\nfull-duplex link.")
mediaIndependentInOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentInOverflowPkts.setDescription("The number of times the associated\nmediaIndependentInPkts counter has overflowed.")
mediaIndependentInHighCapacityPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentInHighCapacityPkts.setDescription("The total number of packets (including bad packets,\nbroadcast packets, and multicast packets) received\non a half-duplex link or on the inbound connection of a\nfull-duplex link.")
mediaIndependentOutPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentOutPkts.setDescription("The total number of packets (including bad packets,\nbroadcast packets, and multicast packets) received on a\nfull-duplex link in the direction of the network.")
mediaIndependentOutOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentOutOverflowPkts.setDescription("The number of times the associated\nmediaIndependentOutPkts counter has overflowed.")
mediaIndependentOutHighCapacityPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentOutHighCapacityPkts.setDescription("The total number of packets (including bad packets,\nbroadcast packets, and multicast packets) received on a\nfull-duplex link in the direction of the network.")
mediaIndependentInOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentInOctets.setDescription("The total number of octets of data (including those in bad\npackets) received (excluding framing bits but including FCS\noctets) on a half-duplex link or on the inbound connection of\na full-duplex link.")
mediaIndependentInOverflowOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentInOverflowOctets.setDescription("The number of times the associated\nmediaIndependentInOctets counter has overflowed.")
mediaIndependentInHighCapacityOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 13), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentInHighCapacityOctets.setDescription("The total number of octets of data (including those in bad\npackets) received (excluding framing bits but\nincluding FCS octets) on a half-duplex link or on the inbound\nconnection of a full-duplex link.")
mediaIndependentOutOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentOutOctets.setDescription("The total number of octets of data (including those in bad\npackets) received on a full-duplex link in the direction of\nthe network (excluding framing bits but including FCS\noctets).")
mediaIndependentOutOverflowOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentOutOverflowOctets.setDescription("The number of times the associated\nmediaIndependentOutOctets counter has overflowed.")
mediaIndependentOutHighCapacityOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 16), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentOutHighCapacityOctets.setDescription("The total number of octets of data (including those in bad\npackets) received on a full-duplex link in the direction of\nthe network (excluding framing bits but including FCS\noctets).")
mediaIndependentInNUCastPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentInNUCastPkts.setDescription("The total number of non-unicast packets (including bad\npackets) received on a half-duplex link or on the inbound\nconnection of a full-duplex link.")
mediaIndependentInNUCastOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentInNUCastOverflowPkts.setDescription("The number of times the associated\nmediaIndependentInNUCastPkts counter has overflowed.")
mediaIndependentInNUCastHighCapacityPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 19), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentInNUCastHighCapacityPkts.setDescription("The total number of non-unicast packets (including bad\npackets) received on a half-duplex link or on the inbound\nconnection of a full-duplex link.")
mediaIndependentOutNUCastPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentOutNUCastPkts.setDescription("The total number of non-unicast packets (including bad\npackets) received on a full-duplex link in the direction of\nthe network.")
mediaIndependentOutNUCastOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentOutNUCastOverflowPkts.setDescription("The number of times the associated\nmediaIndependentOutNUCastPkts counter has overflowed.")
mediaIndependentOutNUCastHighCapacityPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 22), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentOutNUCastHighCapacityPkts.setDescription("The total number of packets (including bad packets)\nreceived on a full-duplex link in the direction of the\nnetwork.")
mediaIndependentInErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentInErrors.setDescription("The total number of bad packets received on a\nhalf-duplex link or on the inbound connection of a\nfull-duplex link.")
mediaIndependentOutErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentOutErrors.setDescription("The total number of bad packets received on a full-duplex\nlink in the direction of the network.")
mediaIndependentInputSpeed = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 25), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentInputSpeed.setDescription("The nominal maximum speed in kilobits per second of this\nhalf-duplex link or on the inbound connection of this\nfull-duplex link. If the speed is unknown or there is no fixed\nmaximum (e.g. a compressed link), this value shall be zero.")
mediaIndependentOutputSpeed = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 26), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentOutputSpeed.setDescription("The nominal maximum speed in kilobits per second of this\nfull-duplex link in the direction of the network. If the speed\nis unknown, the link is half-duplex, or there is no fixed\nmaximum (e.g. a compressed link), this value shall be zero.")
mediaIndependentDuplexMode = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 27), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("halfduplex", 1), ("fullduplex", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentDuplexMode.setDescription("The current mode of this link.\n\nNote that if the link has full-duplex capabilities but\nis operating in half-duplex mode, this value will be\nhalfduplex(1).")
mediaIndependentDuplexChanges = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentDuplexChanges.setDescription("The number of times this link has changed from full-duplex\nmode to half-duplex mode or from half-duplex mode to\nfull-duplex mode.")
mediaIndependentDuplexLastChange = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 29), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaIndependentDuplexLastChange.setDescription("The value of sysUpTime at the time the duplex status\nof this link last changed.")
mediaIndependentOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 30), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mediaIndependentOwner.setDescription("The entity that configured this entry and is\ntherefore using the resources assigned to it.")
mediaIndependentStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 21, 1, 1, 31), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mediaIndependentStatus.setDescription("The status of this media independent statistics entry.")

# Augmentions

# Groups

mediaIndependentGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 7, 1)).setObjects(*(("HC-RMON-MIB", "mediaIndependentInErrors"), ("HC-RMON-MIB", "mediaIndependentInNUCastOverflowPkts"), ("HC-RMON-MIB", "mediaIndependentDuplexMode"), ("HC-RMON-MIB", "mediaIndependentOutHighCapacityPkts"), ("HC-RMON-MIB", "mediaIndependentOwner"), ("HC-RMON-MIB", "mediaIndependentOutPkts"), ("HC-RMON-MIB", "mediaIndependentOutNUCastPkts"), ("HC-RMON-MIB", "mediaIndependentOutOctets"), ("HC-RMON-MIB", "mediaIndependentInNUCastPkts"), ("HC-RMON-MIB", "mediaIndependentOutNUCastOverflowPkts"), ("HC-RMON-MIB", "mediaIndependentInHighCapacityOctets"), ("HC-RMON-MIB", "mediaIndependentDataSource"), ("HC-RMON-MIB", "mediaIndependentStatus"), ("HC-RMON-MIB", "mediaIndependentInPkts"), ("HC-RMON-MIB", "mediaIndependentInHighCapacityPkts"), ("HC-RMON-MIB", "mediaIndependentDuplexLastChange"), ("HC-RMON-MIB", "mediaIndependentInNUCastHighCapacityPkts"), ("HC-RMON-MIB", "mediaIndependentInOverflowOctets"), ("HC-RMON-MIB", "mediaIndependentDroppedFrames"), ("HC-RMON-MIB", "mediaIndependentInputSpeed"), ("HC-RMON-MIB", "mediaIndependentDuplexChanges"), ("HC-RMON-MIB", "mediaIndependentInOverflowPkts"), ("HC-RMON-MIB", "mediaIndependentOutErrors"), ("HC-RMON-MIB", "mediaIndependentOutNUCastHighCapacityPkts"), ("HC-RMON-MIB", "mediaIndependentOutputSpeed"), ("HC-RMON-MIB", "mediaIndependentInOctets"), ("HC-RMON-MIB", "mediaIndependentOutOverflowOctets"), ("HC-RMON-MIB", "mediaIndependentOutHighCapacityOctets"), ("HC-RMON-MIB", "mediaIndependentOutOverflowPkts"), ("HC-RMON-MIB", "mediaIndependentDropEvents"), ) )
if mibBuilder.loadTexts: mediaIndependentGroup.setDescription("Collects utilization statistics for any type of network.")
etherStatsHighCapacityGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 7, 2)).setObjects(*(("HC-RMON-MIB", "etherStatsHighCapacityOverflowPkts"), ("HC-RMON-MIB", "etherStatsHighCapacityOverflowPkts256to511Octets"), ("HC-RMON-MIB", "etherStatsHighCapacityPkts256to511Octets"), ("HC-RMON-MIB", "etherStatsHighCapacityPkts65to127Octets"), ("HC-RMON-MIB", "etherStatsHighCapacityOctets"), ("HC-RMON-MIB", "etherStatsHighCapacityPkts128to255Octets"), ("HC-RMON-MIB", "etherStatsHighCapacityOverflowOctets"), ("HC-RMON-MIB", "etherStatsHighCapacityPkts1024to1518Octets"), ("HC-RMON-MIB", "etherStatsHighCapacityOverflowPkts512to1023Octets"), ("HC-RMON-MIB", "etherStatsHighCapacityOverflowPkts64Octets"), ("HC-RMON-MIB", "etherStatsHighCapacityPkts512to1023Octets"), ("HC-RMON-MIB", "etherStatsHighCapacityPkts64Octets"), ("HC-RMON-MIB", "etherStatsHighCapacityOverflowPkts65to127Octets"), ("HC-RMON-MIB", "etherStatsHighCapacityOverflowPkts128to255Octets"), ("HC-RMON-MIB", "etherStatsHighCapacityOverflowPkts1024to1518Octets"), ("HC-RMON-MIB", "etherStatsHighCapacityPkts"), ) )
if mibBuilder.loadTexts: etherStatsHighCapacityGroup.setDescription("Collects utilization statistics for ethernet networks.")
etherHistoryHighCapacityGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 7, 3)).setObjects(*(("HC-RMON-MIB", "etherHistoryHighCapacityPkts"), ("HC-RMON-MIB", "etherHistoryHighCapacityOverflowOctets"), ("HC-RMON-MIB", "etherHistoryHighCapacityOverflowPkts"), ("HC-RMON-MIB", "etherHistoryHighCapacityOctets"), ) )
if mibBuilder.loadTexts: etherHistoryHighCapacityGroup.setDescription("Collects utilization statistics for ethernet networks.")
hostHighCapacityGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 7, 4)).setObjects(*(("HC-RMON-MIB", "hostHighCapacityOutOctets"), ("HC-RMON-MIB", "hostTimeHighCapacityOutOverflowOctets"), ("HC-RMON-MIB", "hostHighCapacityOutPkts"), ("HC-RMON-MIB", "hostTimeHighCapacityOutOctets"), ("HC-RMON-MIB", "hostHighCapacityInOctets"), ("HC-RMON-MIB", "hostHighCapacityInOverflowOctets"), ("HC-RMON-MIB", "hostTimeHighCapacityInPkts"), ("HC-RMON-MIB", "hostHighCapacityOutOverflowPkts"), ("HC-RMON-MIB", "hostTimeHighCapacityInOverflowPkts"), ("HC-RMON-MIB", "hostTimeHighCapacityOutOverflowPkts"), ("HC-RMON-MIB", "hostHighCapacityInOverflowPkts"), ("HC-RMON-MIB", "hostTimeHighCapacityOutPkts"), ("HC-RMON-MIB", "hostHighCapacityInPkts"), ("HC-RMON-MIB", "hostTimeHighCapacityInOverflowOctets"), ("HC-RMON-MIB", "hostHighCapacityOutOverflowOctets"), ("HC-RMON-MIB", "hostTimeHighCapacityInOctets"), ) )
if mibBuilder.loadTexts: hostHighCapacityGroup.setDescription("Collects utilization and error statistics per host.")
hostTopNHighCapacityGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 7, 5)).setObjects(*(("HC-RMON-MIB", "hostTopNHighCapacityAddress"), ("HC-RMON-MIB", "hostTopNHighCapacityOverflowRate"), ("HC-RMON-MIB", "hostTopNHighCapacityBaseRate"), ("HC-RMON-MIB", "hostTopNHighCapacityRate"), ) )
if mibBuilder.loadTexts: hostTopNHighCapacityGroup.setDescription("Prepares sorted reports of utilization and error statistics\nper host.")
matrixHighCapacityGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 7, 6)).setObjects(*(("HC-RMON-MIB", "matrixSDHighCapacityOctets"), ("HC-RMON-MIB", "matrixDSHighCapacityOverflowOctets"), ("HC-RMON-MIB", "matrixSDHighCapacityPkts"), ("HC-RMON-MIB", "matrixSDHighCapacityOverflowPkts"), ("HC-RMON-MIB", "matrixDSHighCapacityPkts"), ("HC-RMON-MIB", "matrixDSHighCapacityOverflowPkts"), ("HC-RMON-MIB", "matrixSDHighCapacityOverflowOctets"), ("HC-RMON-MIB", "matrixDSHighCapacityOctets"), ) )
if mibBuilder.loadTexts: matrixHighCapacityGroup.setDescription("Collects utilization statistics per conversation.")
captureBufferHighCapacityGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 7, 7)).setObjects(*(("HC-RMON-MIB", "captureBufferPacketHighCapacityTime"), ) )
if mibBuilder.loadTexts: captureBufferHighCapacityGroup.setDescription("Provides finer granularity time stamps.")
protocolDistributionHighCapacityGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 7, 8)).setObjects(*(("HC-RMON-MIB", "protocolDistStatsHighCapacityPkts"), ("HC-RMON-MIB", "protocolDistStatsHighCapacityOverflowOctets"), ("HC-RMON-MIB", "protocolDistStatsHighCapacityOverflowPkts"), ("HC-RMON-MIB", "protocolDistStatsHighCapacityOctets"), ) )
if mibBuilder.loadTexts: protocolDistributionHighCapacityGroup.setDescription("Collects the relative amounts of octets and packets for the\ndifferent protocols detected on a network segment.")
nlHostHighCapacityGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 7, 9)).setObjects(*(("HC-RMON-MIB", "nlHostHighCapacityInOctets"), ("HC-RMON-MIB", "nlHostHighCapacityInPkts"), ("HC-RMON-MIB", "nlHostHighCapacityOutOverflowPkts"), ("HC-RMON-MIB", "nlHostHighCapacityOutOverflowOctets"), ("HC-RMON-MIB", "nlHostHighCapacityOutOctets"), ("HC-RMON-MIB", "nlHostHighCapacityOutPkts"), ("HC-RMON-MIB", "nlHostHighCapacityInOverflowOctets"), ("HC-RMON-MIB", "nlHostHighCapacityInOverflowPkts"), ) )
if mibBuilder.loadTexts: nlHostHighCapacityGroup.setDescription("Counts the amount of traffic sent from and to each network\naddress discovered by the probe.")
nlMatrixHighCapacityGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 7, 10)).setObjects(*(("HC-RMON-MIB", "nlMatrixSDHighCapacityOverflowPkts"), ("HC-RMON-MIB", "nlMatrixDSHighCapacityOverflowPkts"), ("HC-RMON-MIB", "nlMatrixDSHighCapacityOctets"), ("HC-RMON-MIB", "nlMatrixDSHighCapacityPkts"), ("HC-RMON-MIB", "nlMatrixDSHighCapacityOverflowOctets"), ("HC-RMON-MIB", "nlMatrixSDHighCapacityOverflowOctets"), ("HC-RMON-MIB", "nlMatrixSDHighCapacityOctets"), ("HC-RMON-MIB", "nlMatrixSDHighCapacityPkts"), ) )
if mibBuilder.loadTexts: nlMatrixHighCapacityGroup.setDescription("Counts the amount of traffic sent between each pair of\nnetwork addresses discovered by the probe.")
nlMatrixTopNHighCapacityGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 7, 11)).setObjects(*(("HC-RMON-MIB", "nlMatrixTopNHighCapacityPktRate"), ("HC-RMON-MIB", "nlMatrixTopNHighCapacityOctetRate"), ("HC-RMON-MIB", "nlMatrixTopNHighCapacityReverseOverflowPktRate"), ("HC-RMON-MIB", "nlMatrixTopNHighCapacityReverseBasePktRate"), ("HC-RMON-MIB", "nlMatrixTopNHighCapacityReverseBaseOctetRate"), ("HC-RMON-MIB", "nlMatrixTopNHighCapacityReverseOverflowOctetRate"), ("HC-RMON-MIB", "nlMatrixTopNHighCapacityBaseOctetRate"), ("HC-RMON-MIB", "nlMatrixTopNHighCapacityProtocolDirLocalIndex"), ("HC-RMON-MIB", "nlMatrixTopNHighCapacityDestAddress"), ("HC-RMON-MIB", "nlMatrixTopNHighCapacityReversePktRate"), ("HC-RMON-MIB", "nlMatrixTopNHighCapacitySourceAddress"), ("HC-RMON-MIB", "nlMatrixTopNHighCapacityReverseOctetRate"), ("HC-RMON-MIB", "nlMatrixTopNHighCapacityBasePktRate"), ("HC-RMON-MIB", "nlMatrixTopNHighCapacityOverflowPktRate"), ("HC-RMON-MIB", "nlMatrixTopNHighCapacityOverflowOctetRate"), ) )
if mibBuilder.loadTexts: nlMatrixTopNHighCapacityGroup.setDescription("Prepares sorted reports of the amount of traffic sent between\neach pair of network addresses discovered by the probe.")
alHostHighCapacityGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 7, 12)).setObjects(*(("HC-RMON-MIB", "alHostHighCapacityOutOverflowPkts"), ("HC-RMON-MIB", "alHostHighCapacityInOverflowOctets"), ("HC-RMON-MIB", "alHostHighCapacityInOctets"), ("HC-RMON-MIB", "alHostHighCapacityOutOverflowOctets"), ("HC-RMON-MIB", "alHostHighCapacityInPkts"), ("HC-RMON-MIB", "alHostHighCapacityInOverflowPkts"), ("HC-RMON-MIB", "alHostHighCapacityOutOctets"), ("HC-RMON-MIB", "alHostHighCapacityOutPkts"), ) )
if mibBuilder.loadTexts: alHostHighCapacityGroup.setDescription("Counts the amount of traffic, by protocol, sent from and to\neach network address discovered by the probe.")
alMatrixHighCapacityGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 7, 13)).setObjects(*(("HC-RMON-MIB", "alMatrixDSHighCapacityPkts"), ("HC-RMON-MIB", "alMatrixDSHighCapacityOverflowOctets"), ("HC-RMON-MIB", "alMatrixSDHighCapacityOctets"), ("HC-RMON-MIB", "alMatrixSDHighCapacityPkts"), ("HC-RMON-MIB", "alMatrixSDHighCapacityOverflowOctets"), ("HC-RMON-MIB", "alMatrixSDHighCapacityOverflowPkts"), ("HC-RMON-MIB", "alMatrixDSHighCapacityOctets"), ("HC-RMON-MIB", "alMatrixDSHighCapacityOverflowPkts"), ) )
if mibBuilder.loadTexts: alMatrixHighCapacityGroup.setDescription("Counts the amount of traffic, by protocol, sent between each\npair of network addresses discovered by the\nprobe.")
alMatrixTopNHighCapacityGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 7, 14)).setObjects(*(("HC-RMON-MIB", "alMatrixTopNHighCapacityOctetRate"), ("HC-RMON-MIB", "alMatrixTopNHighCapacityOverflowOctetRate"), ("HC-RMON-MIB", "alMatrixTopNHighCapacityReverseOverflowPktRate"), ("HC-RMON-MIB", "alMatrixTopNHighCapacityReverseOctetRate"), ("HC-RMON-MIB", "alMatrixTopNHighCapacityReverseBasePktRate"), ("HC-RMON-MIB", "alMatrixTopNHighCapacityProtocolDirLocalIndex"), ("HC-RMON-MIB", "alMatrixTopNHighCapacityReverseBaseOctetRate"), ("HC-RMON-MIB", "alMatrixTopNHighCapacityBaseOctetRate"), ("HC-RMON-MIB", "alMatrixTopNHighCapacityReverseOverflowOctetRate"), ("HC-RMON-MIB", "alMatrixTopNHighCapacityPktRate"), ("HC-RMON-MIB", "alMatrixTopNHighCapacityDestAddress"), ("HC-RMON-MIB", "alMatrixTopNHighCapacityOverflowPktRate"), ("HC-RMON-MIB", "alMatrixTopNHighCapacityAppProtocolDirLocalIndex"), ("HC-RMON-MIB", "alMatrixTopNHighCapacityReversePktRate"), ("HC-RMON-MIB", "alMatrixTopNHighCapacityBasePktRate"), ("HC-RMON-MIB", "alMatrixTopNHighCapacitySourceAddress"), ) )
if mibBuilder.loadTexts: alMatrixTopNHighCapacityGroup.setDescription("Prepares sorted reports of the amount of traffic per protocol\nsent between each pair of network addresses discovered by the\nprobe.")
usrHistoryHighCapacityGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 7, 15)).setObjects(*(("HC-RMON-MIB", "usrHistoryHighCapacityOverflowAbsValue"), ("HC-RMON-MIB", "usrHistoryHighCapacityAbsValue"), ) )
if mibBuilder.loadTexts: usrHistoryHighCapacityGroup.setDescription("Provides user-defined collection of historical information\nfrom MIB objects on the probe with scalability to statistics\nfrom high-capacity networks.")
hcRMONInformationGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 7, 16)).setObjects(*(("HC-RMON-MIB", "hcRMONCapabilities"), ) )
if mibBuilder.loadTexts: hcRMONInformationGroup.setDescription("An indication of the high capacity RMON groups supported on\nat least one interface by this probe.")

# Compliances

hcMediaIndependentCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 16, 20, 6, 1)).setObjects(*(("HC-RMON-MIB", "mediaIndependentGroup"), ("HC-RMON-MIB", "hcRMONInformationGroup"), ) )
if mibBuilder.loadTexts: hcMediaIndependentCompliance.setDescription("Describes the requirements for conformance to the\nHigh Capacity Media Independent Group.")
hcRmon1MIBCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 16, 20, 6, 2)).setObjects(*(("RMON-MIB", "rmonEthernetHistoryGroup"), ("HC-RMON-MIB", "matrixHighCapacityGroup"), ("RMON-MIB", "rmonFilterGroup"), ("RMON-MIB", "rmonMatrixGroup"), ("RMON-MIB", "rmonPacketCaptureGroup"), ("RMON-MIB", "rmonHistoryControlGroup"), ("HC-RMON-MIB", "etherStatsHighCapacityGroup"), ("HC-RMON-MIB", "hostHighCapacityGroup"), ("RMON-MIB", "rmonEtherStatsGroup"), ("HC-RMON-MIB", "captureBufferHighCapacityGroup"), ("HC-RMON-MIB", "etherHistoryHighCapacityGroup"), ("RMON-MIB", "rmonHostTopNGroup"), ("RMON-MIB", "rmonHostGroup"), ("HC-RMON-MIB", "hostTopNHighCapacityGroup"), ) )
if mibBuilder.loadTexts: hcRmon1MIBCompliance.setDescription("Describes the requirements for conformance to the High\nCapacity RMON-1 MIB")
hcRmon2MIBCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 16, 20, 6, 3)).setObjects(*(("HC-RMON-MIB", "nlMatrixTopNHighCapacityGroup"), ("RMON2-MIB", "nlMatrixGroup"), ("RMON2-MIB", "usrHistoryGroup"), ("HC-RMON-MIB", "nlHostHighCapacityGroup"), ("RMON2-MIB", "probeInformationGroup"), ("HC-RMON-MIB", "hcRMONInformationGroup"), ("RMON2-MIB", "protocolDirectoryGroup"), ("RMON2-MIB", "rmon1EnhancementGroup"), ("HC-RMON-MIB", "protocolDistributionHighCapacityGroup"), ("RMON2-MIB", "addressMapGroup"), ("HC-RMON-MIB", "nlMatrixHighCapacityGroup"), ("HC-RMON-MIB", "usrHistoryHighCapacityGroup"), ("RMON2-MIB", "protocolDistributionGroup"), ("RMON2-MIB", "nlHostGroup"), ) )
if mibBuilder.loadTexts: hcRmon2MIBCompliance.setDescription("Describes the requirements for conformance to\nthe High Capacity RMON-2 MIB")
hcRmon2MIBApplicationLayerCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 16, 20, 6, 4)).setObjects(*(("RMON2-MIB", "alMatrixGroup"), ("RMON2-MIB", "alHostGroup"), ("HC-RMON-MIB", "hcRMONInformationGroup"), ("HC-RMON-MIB", "nlMatrixTopNHighCapacityGroup"), ("RMON2-MIB", "probeInformationGroup"), ("RMON2-MIB", "rmon1EnhancementGroup"), ("RMON2-MIB", "addressMapGroup"), ("HC-RMON-MIB", "protocolDistributionHighCapacityGroup"), ("HC-RMON-MIB", "alMatrixHighCapacityGroup"), ("RMON2-MIB", "nlMatrixGroup"), ("RMON2-MIB", "usrHistoryGroup"), ("HC-RMON-MIB", "nlMatrixHighCapacityGroup"), ("HC-RMON-MIB", "alHostHighCapacityGroup"), ("HC-RMON-MIB", "usrHistoryHighCapacityGroup"), ("RMON2-MIB", "protocolDirectoryGroup"), ("HC-RMON-MIB", "nlHostHighCapacityGroup"), ("HC-RMON-MIB", "alMatrixTopNHighCapacityGroup"), ("RMON2-MIB", "protocolDistributionGroup"), ("RMON2-MIB", "nlHostGroup"), ) )
if mibBuilder.loadTexts: hcRmon2MIBApplicationLayerCompliance.setDescription("Describes the requirements for conformance to\nthe High Capacity RMON-2 MIB with Application Layer\nEnhancements.")

# Exports

# Module identity
mibBuilder.exportSymbols("HC-RMON-MIB", PYSNMP_MODULE_ID=hcRMON)

# Objects
mibBuilder.exportSymbols("HC-RMON-MIB", etherStatsHighCapacityTable=etherStatsHighCapacityTable, etherStatsHighCapacityEntry=etherStatsHighCapacityEntry, etherStatsHighCapacityOverflowPkts=etherStatsHighCapacityOverflowPkts, etherStatsHighCapacityPkts=etherStatsHighCapacityPkts, etherStatsHighCapacityOverflowOctets=etherStatsHighCapacityOverflowOctets, etherStatsHighCapacityOctets=etherStatsHighCapacityOctets, etherStatsHighCapacityOverflowPkts64Octets=etherStatsHighCapacityOverflowPkts64Octets, etherStatsHighCapacityPkts64Octets=etherStatsHighCapacityPkts64Octets, etherStatsHighCapacityOverflowPkts65to127Octets=etherStatsHighCapacityOverflowPkts65to127Octets, etherStatsHighCapacityPkts65to127Octets=etherStatsHighCapacityPkts65to127Octets, etherStatsHighCapacityOverflowPkts128to255Octets=etherStatsHighCapacityOverflowPkts128to255Octets, etherStatsHighCapacityPkts128to255Octets=etherStatsHighCapacityPkts128to255Octets, etherStatsHighCapacityOverflowPkts256to511Octets=etherStatsHighCapacityOverflowPkts256to511Octets, etherStatsHighCapacityPkts256to511Octets=etherStatsHighCapacityPkts256to511Octets, etherStatsHighCapacityOverflowPkts512to1023Octets=etherStatsHighCapacityOverflowPkts512to1023Octets, etherStatsHighCapacityPkts512to1023Octets=etherStatsHighCapacityPkts512to1023Octets, etherStatsHighCapacityOverflowPkts1024to1518Octets=etherStatsHighCapacityOverflowPkts1024to1518Octets, etherStatsHighCapacityPkts1024to1518Octets=etherStatsHighCapacityPkts1024to1518Octets, etherHistoryHighCapacityTable=etherHistoryHighCapacityTable, etherHistoryHighCapacityEntry=etherHistoryHighCapacityEntry, etherHistoryHighCapacityOverflowPkts=etherHistoryHighCapacityOverflowPkts, etherHistoryHighCapacityPkts=etherHistoryHighCapacityPkts, etherHistoryHighCapacityOverflowOctets=etherHistoryHighCapacityOverflowOctets, etherHistoryHighCapacityOctets=etherHistoryHighCapacityOctets, hostHighCapacityTable=hostHighCapacityTable, hostHighCapacityEntry=hostHighCapacityEntry, hostHighCapacityInOverflowPkts=hostHighCapacityInOverflowPkts, hostHighCapacityInPkts=hostHighCapacityInPkts, hostHighCapacityOutOverflowPkts=hostHighCapacityOutOverflowPkts, hostHighCapacityOutPkts=hostHighCapacityOutPkts, hostHighCapacityInOverflowOctets=hostHighCapacityInOverflowOctets, hostHighCapacityInOctets=hostHighCapacityInOctets, hostHighCapacityOutOverflowOctets=hostHighCapacityOutOverflowOctets, hostHighCapacityOutOctets=hostHighCapacityOutOctets, hostTimeHighCapacityTable=hostTimeHighCapacityTable, hostTimeHighCapacityEntry=hostTimeHighCapacityEntry, hostTimeHighCapacityInOverflowPkts=hostTimeHighCapacityInOverflowPkts, hostTimeHighCapacityInPkts=hostTimeHighCapacityInPkts, hostTimeHighCapacityOutOverflowPkts=hostTimeHighCapacityOutOverflowPkts, hostTimeHighCapacityOutPkts=hostTimeHighCapacityOutPkts, hostTimeHighCapacityInOverflowOctets=hostTimeHighCapacityInOverflowOctets, hostTimeHighCapacityInOctets=hostTimeHighCapacityInOctets, hostTimeHighCapacityOutOverflowOctets=hostTimeHighCapacityOutOverflowOctets, hostTimeHighCapacityOutOctets=hostTimeHighCapacityOutOctets, hostTopNHighCapacityTable=hostTopNHighCapacityTable, hostTopNHighCapacityEntry=hostTopNHighCapacityEntry, hostTopNHighCapacityAddress=hostTopNHighCapacityAddress, hostTopNHighCapacityBaseRate=hostTopNHighCapacityBaseRate, hostTopNHighCapacityOverflowRate=hostTopNHighCapacityOverflowRate, hostTopNHighCapacityRate=hostTopNHighCapacityRate, matrixSDHighCapacityTable=matrixSDHighCapacityTable, matrixSDHighCapacityEntry=matrixSDHighCapacityEntry, matrixSDHighCapacityOverflowPkts=matrixSDHighCapacityOverflowPkts, matrixSDHighCapacityPkts=matrixSDHighCapacityPkts, matrixSDHighCapacityOverflowOctets=matrixSDHighCapacityOverflowOctets, matrixSDHighCapacityOctets=matrixSDHighCapacityOctets, matrixDSHighCapacityTable=matrixDSHighCapacityTable, matrixDSHighCapacityEntry=matrixDSHighCapacityEntry, matrixDSHighCapacityOverflowPkts=matrixDSHighCapacityOverflowPkts, matrixDSHighCapacityPkts=matrixDSHighCapacityPkts, matrixDSHighCapacityOverflowOctets=matrixDSHighCapacityOverflowOctets, matrixDSHighCapacityOctets=matrixDSHighCapacityOctets, captureBufferHighCapacityTable=captureBufferHighCapacityTable, captureBufferHighCapacityEntry=captureBufferHighCapacityEntry, captureBufferPacketHighCapacityTime=captureBufferPacketHighCapacityTime, protocolDistStatsHighCapacityTable=protocolDistStatsHighCapacityTable, protocolDistStatsHighCapacityEntry=protocolDistStatsHighCapacityEntry, protocolDistStatsHighCapacityOverflowPkts=protocolDistStatsHighCapacityOverflowPkts, protocolDistStatsHighCapacityPkts=protocolDistStatsHighCapacityPkts, protocolDistStatsHighCapacityOverflowOctets=protocolDistStatsHighCapacityOverflowOctets, protocolDistStatsHighCapacityOctets=protocolDistStatsHighCapacityOctets, nlHostHighCapacityTable=nlHostHighCapacityTable, nlHostHighCapacityEntry=nlHostHighCapacityEntry, nlHostHighCapacityInOverflowPkts=nlHostHighCapacityInOverflowPkts, nlHostHighCapacityInPkts=nlHostHighCapacityInPkts, nlHostHighCapacityOutOverflowPkts=nlHostHighCapacityOutOverflowPkts, nlHostHighCapacityOutPkts=nlHostHighCapacityOutPkts, nlHostHighCapacityInOverflowOctets=nlHostHighCapacityInOverflowOctets, nlHostHighCapacityInOctets=nlHostHighCapacityInOctets, nlHostHighCapacityOutOverflowOctets=nlHostHighCapacityOutOverflowOctets, nlHostHighCapacityOutOctets=nlHostHighCapacityOutOctets, nlMatrixSDHighCapacityTable=nlMatrixSDHighCapacityTable, nlMatrixSDHighCapacityEntry=nlMatrixSDHighCapacityEntry, nlMatrixSDHighCapacityOverflowPkts=nlMatrixSDHighCapacityOverflowPkts, nlMatrixSDHighCapacityPkts=nlMatrixSDHighCapacityPkts, nlMatrixSDHighCapacityOverflowOctets=nlMatrixSDHighCapacityOverflowOctets, nlMatrixSDHighCapacityOctets=nlMatrixSDHighCapacityOctets, nlMatrixDSHighCapacityTable=nlMatrixDSHighCapacityTable, nlMatrixDSHighCapacityEntry=nlMatrixDSHighCapacityEntry, nlMatrixDSHighCapacityOverflowPkts=nlMatrixDSHighCapacityOverflowPkts, nlMatrixDSHighCapacityPkts=nlMatrixDSHighCapacityPkts, nlMatrixDSHighCapacityOverflowOctets=nlMatrixDSHighCapacityOverflowOctets, nlMatrixDSHighCapacityOctets=nlMatrixDSHighCapacityOctets, nlMatrixTopNHighCapacityTable=nlMatrixTopNHighCapacityTable, nlMatrixTopNHighCapacityEntry=nlMatrixTopNHighCapacityEntry, nlMatrixTopNHighCapacityProtocolDirLocalIndex=nlMatrixTopNHighCapacityProtocolDirLocalIndex, nlMatrixTopNHighCapacitySourceAddress=nlMatrixTopNHighCapacitySourceAddress, nlMatrixTopNHighCapacityDestAddress=nlMatrixTopNHighCapacityDestAddress, nlMatrixTopNHighCapacityBasePktRate=nlMatrixTopNHighCapacityBasePktRate, nlMatrixTopNHighCapacityOverflowPktRate=nlMatrixTopNHighCapacityOverflowPktRate, nlMatrixTopNHighCapacityPktRate=nlMatrixTopNHighCapacityPktRate, nlMatrixTopNHighCapacityReverseBasePktRate=nlMatrixTopNHighCapacityReverseBasePktRate, nlMatrixTopNHighCapacityReverseOverflowPktRate=nlMatrixTopNHighCapacityReverseOverflowPktRate, nlMatrixTopNHighCapacityReversePktRate=nlMatrixTopNHighCapacityReversePktRate, nlMatrixTopNHighCapacityBaseOctetRate=nlMatrixTopNHighCapacityBaseOctetRate, nlMatrixTopNHighCapacityOverflowOctetRate=nlMatrixTopNHighCapacityOverflowOctetRate, nlMatrixTopNHighCapacityOctetRate=nlMatrixTopNHighCapacityOctetRate, nlMatrixTopNHighCapacityReverseBaseOctetRate=nlMatrixTopNHighCapacityReverseBaseOctetRate, nlMatrixTopNHighCapacityReverseOverflowOctetRate=nlMatrixTopNHighCapacityReverseOverflowOctetRate, nlMatrixTopNHighCapacityReverseOctetRate=nlMatrixTopNHighCapacityReverseOctetRate, alHostHighCapacityTable=alHostHighCapacityTable, alHostHighCapacityEntry=alHostHighCapacityEntry, alHostHighCapacityInOverflowPkts=alHostHighCapacityInOverflowPkts, alHostHighCapacityInPkts=alHostHighCapacityInPkts, alHostHighCapacityOutOverflowPkts=alHostHighCapacityOutOverflowPkts, alHostHighCapacityOutPkts=alHostHighCapacityOutPkts, alHostHighCapacityInOverflowOctets=alHostHighCapacityInOverflowOctets, alHostHighCapacityInOctets=alHostHighCapacityInOctets, alHostHighCapacityOutOverflowOctets=alHostHighCapacityOutOverflowOctets, alHostHighCapacityOutOctets=alHostHighCapacityOutOctets, alMatrixSDHighCapacityTable=alMatrixSDHighCapacityTable, alMatrixSDHighCapacityEntry=alMatrixSDHighCapacityEntry, alMatrixSDHighCapacityOverflowPkts=alMatrixSDHighCapacityOverflowPkts, alMatrixSDHighCapacityPkts=alMatrixSDHighCapacityPkts, alMatrixSDHighCapacityOverflowOctets=alMatrixSDHighCapacityOverflowOctets, alMatrixSDHighCapacityOctets=alMatrixSDHighCapacityOctets)
mibBuilder.exportSymbols("HC-RMON-MIB", alMatrixDSHighCapacityTable=alMatrixDSHighCapacityTable, alMatrixDSHighCapacityEntry=alMatrixDSHighCapacityEntry, alMatrixDSHighCapacityOverflowPkts=alMatrixDSHighCapacityOverflowPkts, alMatrixDSHighCapacityPkts=alMatrixDSHighCapacityPkts, alMatrixDSHighCapacityOverflowOctets=alMatrixDSHighCapacityOverflowOctets, alMatrixDSHighCapacityOctets=alMatrixDSHighCapacityOctets, alMatrixTopNHighCapacityTable=alMatrixTopNHighCapacityTable, alMatrixTopNHighCapacityEntry=alMatrixTopNHighCapacityEntry, alMatrixTopNHighCapacityProtocolDirLocalIndex=alMatrixTopNHighCapacityProtocolDirLocalIndex, alMatrixTopNHighCapacitySourceAddress=alMatrixTopNHighCapacitySourceAddress, alMatrixTopNHighCapacityDestAddress=alMatrixTopNHighCapacityDestAddress, alMatrixTopNHighCapacityAppProtocolDirLocalIndex=alMatrixTopNHighCapacityAppProtocolDirLocalIndex, alMatrixTopNHighCapacityBasePktRate=alMatrixTopNHighCapacityBasePktRate, alMatrixTopNHighCapacityOverflowPktRate=alMatrixTopNHighCapacityOverflowPktRate, alMatrixTopNHighCapacityPktRate=alMatrixTopNHighCapacityPktRate, alMatrixTopNHighCapacityReverseBasePktRate=alMatrixTopNHighCapacityReverseBasePktRate, alMatrixTopNHighCapacityReverseOverflowPktRate=alMatrixTopNHighCapacityReverseOverflowPktRate, alMatrixTopNHighCapacityReversePktRate=alMatrixTopNHighCapacityReversePktRate, alMatrixTopNHighCapacityBaseOctetRate=alMatrixTopNHighCapacityBaseOctetRate, alMatrixTopNHighCapacityOverflowOctetRate=alMatrixTopNHighCapacityOverflowOctetRate, alMatrixTopNHighCapacityOctetRate=alMatrixTopNHighCapacityOctetRate, alMatrixTopNHighCapacityReverseBaseOctetRate=alMatrixTopNHighCapacityReverseBaseOctetRate, alMatrixTopNHighCapacityReverseOverflowOctetRate=alMatrixTopNHighCapacityReverseOverflowOctetRate, alMatrixTopNHighCapacityReverseOctetRate=alMatrixTopNHighCapacityReverseOctetRate, usrHistoryHighCapacityTable=usrHistoryHighCapacityTable, usrHistoryHighCapacityEntry=usrHistoryHighCapacityEntry, usrHistoryHighCapacityOverflowAbsValue=usrHistoryHighCapacityOverflowAbsValue, usrHistoryHighCapacityAbsValue=usrHistoryHighCapacityAbsValue, hcRMONCapabilities=hcRMONCapabilities, hcRMON=hcRMON, hcRmonMIBCompliances=hcRmonMIBCompliances, hcRmonMIBGroups=hcRmonMIBGroups, mediaIndependentStats=mediaIndependentStats, mediaIndependentTable=mediaIndependentTable, mediaIndependentEntry=mediaIndependentEntry, mediaIndependentIndex=mediaIndependentIndex, mediaIndependentDataSource=mediaIndependentDataSource, mediaIndependentDropEvents=mediaIndependentDropEvents, mediaIndependentDroppedFrames=mediaIndependentDroppedFrames, mediaIndependentInPkts=mediaIndependentInPkts, mediaIndependentInOverflowPkts=mediaIndependentInOverflowPkts, mediaIndependentInHighCapacityPkts=mediaIndependentInHighCapacityPkts, mediaIndependentOutPkts=mediaIndependentOutPkts, mediaIndependentOutOverflowPkts=mediaIndependentOutOverflowPkts, mediaIndependentOutHighCapacityPkts=mediaIndependentOutHighCapacityPkts, mediaIndependentInOctets=mediaIndependentInOctets, mediaIndependentInOverflowOctets=mediaIndependentInOverflowOctets, mediaIndependentInHighCapacityOctets=mediaIndependentInHighCapacityOctets, mediaIndependentOutOctets=mediaIndependentOutOctets, mediaIndependentOutOverflowOctets=mediaIndependentOutOverflowOctets, mediaIndependentOutHighCapacityOctets=mediaIndependentOutHighCapacityOctets, mediaIndependentInNUCastPkts=mediaIndependentInNUCastPkts, mediaIndependentInNUCastOverflowPkts=mediaIndependentInNUCastOverflowPkts, mediaIndependentInNUCastHighCapacityPkts=mediaIndependentInNUCastHighCapacityPkts, mediaIndependentOutNUCastPkts=mediaIndependentOutNUCastPkts, mediaIndependentOutNUCastOverflowPkts=mediaIndependentOutNUCastOverflowPkts, mediaIndependentOutNUCastHighCapacityPkts=mediaIndependentOutNUCastHighCapacityPkts, mediaIndependentInErrors=mediaIndependentInErrors, mediaIndependentOutErrors=mediaIndependentOutErrors, mediaIndependentInputSpeed=mediaIndependentInputSpeed, mediaIndependentOutputSpeed=mediaIndependentOutputSpeed, mediaIndependentDuplexMode=mediaIndependentDuplexMode, mediaIndependentDuplexChanges=mediaIndependentDuplexChanges, mediaIndependentDuplexLastChange=mediaIndependentDuplexLastChange, mediaIndependentOwner=mediaIndependentOwner, mediaIndependentStatus=mediaIndependentStatus)

# Groups
mibBuilder.exportSymbols("HC-RMON-MIB", mediaIndependentGroup=mediaIndependentGroup, etherStatsHighCapacityGroup=etherStatsHighCapacityGroup, etherHistoryHighCapacityGroup=etherHistoryHighCapacityGroup, hostHighCapacityGroup=hostHighCapacityGroup, hostTopNHighCapacityGroup=hostTopNHighCapacityGroup, matrixHighCapacityGroup=matrixHighCapacityGroup, captureBufferHighCapacityGroup=captureBufferHighCapacityGroup, protocolDistributionHighCapacityGroup=protocolDistributionHighCapacityGroup, nlHostHighCapacityGroup=nlHostHighCapacityGroup, nlMatrixHighCapacityGroup=nlMatrixHighCapacityGroup, nlMatrixTopNHighCapacityGroup=nlMatrixTopNHighCapacityGroup, alHostHighCapacityGroup=alHostHighCapacityGroup, alMatrixHighCapacityGroup=alMatrixHighCapacityGroup, alMatrixTopNHighCapacityGroup=alMatrixTopNHighCapacityGroup, usrHistoryHighCapacityGroup=usrHistoryHighCapacityGroup, hcRMONInformationGroup=hcRMONInformationGroup)

# Compliances
mibBuilder.exportSymbols("HC-RMON-MIB", hcMediaIndependentCompliance=hcMediaIndependentCompliance, hcRmon1MIBCompliance=hcRmon1MIBCompliance, hcRmon2MIBCompliance=hcRmon2MIBCompliance, hcRmon2MIBApplicationLayerCompliance=hcRmon2MIBApplicationLayerCompliance)
