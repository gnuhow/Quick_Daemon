# PySNMP SMI module. Autogenerated from smidump -f python GMPLS-TE-STD-MIB
# by libsmi2pysnmp-0.1.3 at Mon Apr  2 20:39:02 2012,
# Python version sys.version_info(major=2, minor=7, micro=2, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( IANAGmplsAdminStatusInformationTC, IANAGmplsGeneralizedPidTC, IANAGmplsLSPEncodingTypeTC, IANAGmplsSwitchingTypeTC, ) = mibBuilder.importSymbols("IANA-GMPLS-TC-MIB", "IANAGmplsAdminStatusInformationTC", "IANAGmplsGeneralizedPidTC", "IANAGmplsLSPEncodingTypeTC", "IANAGmplsSwitchingTypeTC")
( InetAddress, InetAddressType, ) = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType")
( mplsStdMIB, ) = mibBuilder.importSymbols("MPLS-TC-STD-MIB", "mplsStdMIB")
( mplsTunnelARHopIndex, mplsTunnelARHopListIndex, mplsTunnelAdminStatus, mplsTunnelCHopIndex, mplsTunnelCHopListIndex, mplsTunnelEgressLSRId, mplsTunnelEntry, mplsTunnelGroup, mplsTunnelHopIndex, mplsTunnelHopListIndex, mplsTunnelHopPathOptionIndex, mplsTunnelIndex, mplsTunnelIngressLSRId, mplsTunnelInstance, mplsTunnelOperStatus, mplsTunnelScalarGroup, ) = mibBuilder.importSymbols("MPLS-TE-STD-MIB", "mplsTunnelARHopIndex", "mplsTunnelARHopListIndex", "mplsTunnelAdminStatus", "mplsTunnelCHopIndex", "mplsTunnelCHopListIndex", "mplsTunnelEgressLSRId", "mplsTunnelEntry", "mplsTunnelGroup", "mplsTunnelHopIndex", "mplsTunnelHopListIndex", "mplsTunnelHopPathOptionIndex", "mplsTunnelIndex", "mplsTunnelIngressLSRId", "mplsTunnelInstance", "mplsTunnelOperStatus", "mplsTunnelScalarGroup")
( SnmpAdminString, ) = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
( ModuleCompliance, NotificationGroup, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
( Bits, Counter32, Counter64, Gauge32, Integer32, ModuleIdentity, MibIdentifier, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, Unsigned32, zeroDotZero, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "Counter64", "Gauge32", "Integer32", "ModuleIdentity", "MibIdentifier", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "Unsigned32", "zeroDotZero")
( RowPointer, TimeStamp, TruthValue, ) = mibBuilder.importSymbols("SNMPv2-TC", "RowPointer", "TimeStamp", "TruthValue")

# Objects

gmplsTeStdMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 10, 166, 13)).setRevisions(("2007-02-27 00:00",))
if mibBuilder.loadTexts: gmplsTeStdMIB.setOrganization("IETF Common Control and Measurement Plane (CCAMP) Working\nGroup")
if mibBuilder.loadTexts: gmplsTeStdMIB.setContactInfo("       Thomas D. Nadeau\nCisco Systems, Inc.\nEmail: tnadeau@cisco.com\nAdrian Farrel\nOld Dog Consulting\nEmail: adrian@olddog.co.uk\n\nComments about this document should be emailed directly\nto the CCAMP working group mailing list at\nccamp@ops.ietf.org.")
if mibBuilder.loadTexts: gmplsTeStdMIB.setDescription("Copyright (C) The IETF Trust (2007).  This version of\nthis MIB module is part of RFC 4802; see the RFC itself for\nfull legal notices.\n\nThis MIB module contains managed object definitions\nfor GMPLS Traffic Engineering (TE) as defined in:\n1. Generalized Multi-Protocol Label Switching (GMPLS)\n   Signaling Functional Description, Berger, L. (Editor),\n   RFC 3471, January 2003.\n2. Generalized MPLS Signaling - RSVP-TE Extensions, Berger,\n   L. (Editor), RFC 3473, January 2003.")
gmplsTeNotifications = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 13, 0))
gmplsTeScalars = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 13, 1))
gmplsTunnelsConfigured = MibScalar((1, 3, 6, 1, 2, 1, 10, 166, 13, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelsConfigured.setDescription("The number of GMPLS tunnels configured on this device.  A GMPLS\n\n\n\ntunnel is considered configured if an entry for the tunnel\nexists in the gmplsTunnelTable and the associated\nmplsTunnelRowStatus is active(1).")
gmplsTunnelsActive = MibScalar((1, 3, 6, 1, 2, 1, 10, 166, 13, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelsActive.setDescription("The number of GMPLS tunnels active on this device.  A GMPLS\ntunnel is considered active if there is an entry in the\ngmplsTunnelTable and the associated mplsTunnelOperStatus for the\ntunnel is up(1).")
gmplsTeObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 13, 2))
gmplsTunnelTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 1))
if mibBuilder.loadTexts: gmplsTunnelTable.setDescription("The gmplsTunnelTable sparsely extends the mplsTunnelTable of\nMPLS-TE-STD-MIB.  It allows GMPLS tunnels to be created between\nan LSR and a remote endpoint, and existing tunnels to be\nreconfigured or removed.\n\nNote that only point-to-point tunnel segments are supported,\nalthough multipoint-to-point and point-to-multipoint\nconnections are supported by an LSR acting as a cross-connect.\nEach tunnel can thus have one out-segment originating at this\nLSR and/or one in-segment terminating at this LSR.\n\nThe row status of an entry in this table is controlled by the\nmplsTunnelRowStatus in the corresponding entry in the\nmplsTunnelTable.  When the corresponding mplsTunnelRowStatus has\nvalue active(1), a row in this table may not be created or\nmodified.\n\nThe exception to this rule is the\ngmplsTunnelAdminStatusInformation object, which can be modified\nwhile the tunnel is active.")
gmplsTunnelEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 1, 1)).setIndexNames((0, "MPLS-TE-STD-MIB", "mplsTunnelIndex"), (0, "MPLS-TE-STD-MIB", "mplsTunnelInstance"), (0, "MPLS-TE-STD-MIB", "mplsTunnelIngressLSRId"), (0, "MPLS-TE-STD-MIB", "mplsTunnelEgressLSRId"))
if mibBuilder.loadTexts: gmplsTunnelEntry.setDescription("An entry in this table in association with the corresponding\nentry in the mplsTunnelTable represents a GMPLS tunnel.\n\nAn entry can be created by a network administrator via SNMP SET\ncommands, or in response to signaling protocol events.")
gmplsTunnelUnnumIf = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 1, 1, 1), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelUnnumIf.setDescription("Denotes whether or not this tunnel corresponds to an unnumbered\ninterface represented by an entry in the interfaces group table\n(the ifTable) with ifType set to mpls(166).\n\n\n\nThis object is only used if mplsTunnelIsIf is set to 'true'.\n\nIf both this object and the mplsTunnelIsIf object are set to\n'true', the originating LSR adds an LSP_TUNNEL_INTERFACE_ID\nobject to the outgoing Path message.\n\nThis object contains information that is only used by the\nterminating LSR.")
gmplsTunnelAttributes = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 1, 1, 2), Bits().subtype(namedValues=NamedValues(("labelRecordingDesired", 0), )).clone(())).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelAttributes.setDescription("This bitmask indicates optional parameters for this tunnel.\nThese bits should be taken in addition to those defined in\nmplsTunnelSessionAttributes in order to determine the full set\nof options to be signaled (for example SESSION_ATTRIBUTES flags\nin RSVP-TE).  The following describes these bitfields:\n\nlabelRecordingDesired\n  This flag is set to indicate that label information should be\n  included when doing a route record.  This bit is not valid\n  unless the recordRoute bit is set.")
gmplsTunnelLSPEncoding = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 1, 1, 3), IANAGmplsLSPEncodingTypeTC().clone('tunnelLspNotGmpls')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelLSPEncoding.setDescription("This object indicates the encoding of the LSP being requested.\n\nA value of 'tunnelLspNotGmpls' indicates that GMPLS signaling is\nnot in use.  Some objects in this MIB module may be of use for\nMPLS signaling extensions that do not use GMPLS signaling.  By\nsetting this object to 'tunnelLspNotGmpls', an application may\n\n\n\n\nindicate that only those objects meaningful in MPLS should be\nexamined.\n\nThe values to use are defined in the TEXTUAL-CONVENTION\nIANAGmplsLSPEncodingTypeTC found in the IANA-GMPLS-TC-MIB\nmodule.")
gmplsTunnelSwitchingType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 1, 1, 4), IANAGmplsSwitchingTypeTC().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelSwitchingType.setDescription("Indicates the type of switching that should be performed on\na particular link.  This field is needed for links that\nadvertise more than one type of switching capability.\n\nThe values to use are defined in the TEXTUAL-CONVENTION\nIANAGmplsSwitchingTypeTC found in the IANA-GMPLS-TC-MIB module.\n\nThis object is only meaningful if gmplsTunnelLSPEncodingType\nis not set to 'tunnelLspNotGmpls'.")
gmplsTunnelLinkProtection = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 1, 1, 5), Bits().subtype(namedValues=NamedValues(("extraTraffic", 0), ("unprotected", 1), ("shared", 2), ("dedicatedOneToOne", 3), ("dedicatedOnePlusOne", 4), ("enhanced", 5), )).clone(())).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelLinkProtection.setDescription("This bitmask indicates the level of link protection required.  A\nvalue of zero (no bits set) indicates that any protection may be\nused.  The following describes these bitfields:\n\nextraTraffic\n  This flag is set to indicate that the LSP should use links\n  that are protecting other (primary) traffic.  Such LSPs may be\n  preempted when the links carrying the (primary) traffic being\n  protected fail.\n\n\n\n\nunprotected\n  This flag is set to indicate that the LSP should not use any\n  link layer protection.\n\nshared\n  This flag is set to indicate that a shared link layer\n  protection scheme, such as 1:N protection, should be used to\n  support the LSP.\n\ndedicatedOneToOne\n  This flag is set to indicate that a dedicated link layer\n  protection scheme, i.e., 1:1 protection, should be used to\n  support the LSP.\n\ndedicatedOnePlusOne\n  This flag is set to indicate that a dedicated link layer\n  protection scheme, i.e., 1+1 protection, should be used to\n  support the LSP.\n\nenhanced\n  This flag is set to indicate that a protection scheme that is\n  more reliable than Dedicated 1+1 should be used, e.g., 4 fiber\n  BLSR/MS-SPRING.\n\nThis object is only meaningful if gmplsTunnelLSPEncoding is\nnot set to 'tunnelLspNotGmpls'.")
gmplsTunnelGPid = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 1, 1, 6), IANAGmplsGeneralizedPidTC().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelGPid.setDescription("This object indicates the payload carried by the LSP.  It is only\nrequired when GMPLS will be used for this LSP.\n\nThe values to use are defined in the TEXTUAL-CONVENTION\nIANAGmplsGeneralizedPidTC found in the IANA-GMPLS-TC-MIB module.\n\nThis object is only meaningful if gmplsTunnelLSPEncoding is not\nset to 'tunnelLspNotGmpls'.")
gmplsTunnelSecondary = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 1, 1, 7), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelSecondary.setDescription("Indicates that the requested LSP is a secondary LSP.\n\nThis object is only meaningful if gmplsTunnelLSPEncoding is not\nset to 'tunnelLspNotGmpls'.")
gmplsTunnelDirection = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 1, 1, 8), Integer().subtype(subtypeSpec=SingleValueConstraint(0,1,)).subtype(namedValues=NamedValues(("forward", 0), ("bidirectional", 1), )).clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelDirection.setDescription("Whether this tunnel carries forward data only (is\nunidirectional) or is bidirectional.\n\nValues of this object other than 'forward' are meaningful\nonly if gmplsTunnelLSPEncoding is not set to\n'tunnelLspNotGmpls'.")
gmplsTunnelPathComp = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 1, 1, 9), Integer().subtype(subtypeSpec=SingleValueConstraint(3,1,2,)).subtype(namedValues=NamedValues(("dynamicFull", 1), ("explicit", 2), ("dynamicPartial", 3), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelPathComp.setDescription("This value instructs the source node on how to perform path\ncomputation on the explicit route specified by the associated\nentries in the gmplsTunnelHopTable.\n\ndynamicFull\n  The user specifies at least the source and\n  destination of the path and expects that the Constrained\n\n\n\n  Shortest Path First (CSPF) will calculate the remainder\n  of the path.\n\nexplicit\n  The user specifies the entire path for the tunnel to\n  take.  This path may contain strict or loose hops.\n  Evaluation of the explicit route will be performed\n  hop by hop through the network.\n\ndynamicPartial\n  The user specifies at least the source and\n  destination of the path and expects that the CSPF\n  will calculate the remainder of the path.  The path\n  computed by CSPF is allowed to be only partially\n  computed allowing the remainder of the path to be\n  filled in across the network.\n\nWhen an entry is present in the gmplsTunnelTable for a\ntunnel, gmplsTunnelPathComp MUST be used and any\ncorresponding mplsTunnelHopEntryPathComp object in the\nmplsTunnelHopTable MUST be ignored and SHOULD not be set.\n\nmplsTunnelHopTable and mplsTunnelHopEntryPathComp are part of\nMPLS-TE-STD-MIB.\n\nThis object should be ignored if the value of\ngmplsTunnelLSPEncoding is 'tunnelLspNotGmpls'.")
gmplsTunnelUpstreamNotifyRecipientType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 1, 1, 10), InetAddressType().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelUpstreamNotifyRecipientType.setDescription("This object is used to aid in interpretation of\ngmplsTunnelUpstreamNotifyRecipient.")
gmplsTunnelUpstreamNotifyRecipient = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 1, 1, 11), InetAddress().clone(hexValue='00000000')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelUpstreamNotifyRecipient.setDescription("Indicates the address of the upstream recipient for Notify\nmessages relating to this tunnel and issued by this LSR.  This\ninformation is typically received from an upstream LSR in a Path\nmessage.\n\nThis object is only valid when signaling a tunnel using RSVP.\n\nIt is also not valid at the head end of a tunnel since there are\nno upstream LSRs to which to send a Notify message.\n\nThis object is interpreted in the context of the value of\ngmplsTunnelUpstreamNotifyRecipientType. If this object is set to\n0, the value of gmplsTunnelUpstreamNotifyRecipientType MUST be\nset to unknown(0).")
gmplsTunnelSendResvNotifyRecipientType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 1, 1, 12), InetAddressType().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelSendResvNotifyRecipientType.setDescription("This object is used to aid in interpretation of\ngmplsTunnelSendResvNotifyRecipient.")
gmplsTunnelSendResvNotifyRecipient = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 1, 1, 13), InetAddress().clone(hexValue='00000000')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelSendResvNotifyRecipient.setDescription("Indicates to an upstream LSR the address to which it should send\ndownstream Notify messages relating to this tunnel.\n\nThis object is only valid when signaling a tunnel using RSVP.\n\nIt is also not valid at the head end of the tunnel since no Resv\nmessages are sent from that LSR for this tunnel.\n\nIf set to 0, no Notify Request object will be included in the\noutgoing Resv messages.\n\nThis object is interpreted in the context of the value of\ngmplsTunnelSendResvNotifyRecipientType. If this object is set to\n\n\n\n0, the value of gmplsTunnelSendResvNotifyRecipientType MUST be\nset to unknown(0).")
gmplsTunnelDownstreamNotifyRecipientType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 1, 1, 14), InetAddressType().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelDownstreamNotifyRecipientType.setDescription("This object is used to aid in interpretation of\ngmplsTunnelDownstreamNotifyRecipient.")
gmplsTunnelDownstreamNotifyRecipient = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 1, 1, 15), InetAddress().clone(hexValue='00000000')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelDownstreamNotifyRecipient.setDescription("Indicates the address of the downstream recipient for Notify\nmessages relating to this tunnel and issued by this LSR.  This\ninformation is typically received from an upstream LSR in a Resv\nmessage.  This object is only valid when signaling a tunnel using\nRSVP.\n\nIt is also not valid at the tail end of a tunnel since there are\nno downstream LSRs to which to send a Notify message.\n\nThis object is interpreted in the context of the value of\ngmplsTunnelDownstreamNotifyRecipientType. If this object is set\nto 0, the value of gmplsTunnelDownstreamNotifyRecipientType MUST\nbe set to unknown(0).")
gmplsTunnelSendPathNotifyRecipientType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 1, 1, 16), InetAddressType().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelSendPathNotifyRecipientType.setDescription("This object is used to aid in interpretation of\ngmplsTunnelSendPathNotifyRecipient.")
gmplsTunnelSendPathNotifyRecipient = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 1, 1, 17), InetAddress().clone(hexValue='00000000')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelSendPathNotifyRecipient.setDescription("Indicates to a downstream LSR the address to which it should\nsend upstream Notify messages relating to this tunnel.\n\nThis object is only valid when signaling a tunnel using RSVP.\n\nIt is also not valid at the tail end of the tunnel since no Path\nmessages are sent from that LSR for this tunnel.\n\nIf set to 0, no Notify Request object will be included in the\noutgoing Path messages.\n\nThis object is interpreted in the context of the value of\ngmplsTunnelSendPathNotifyRecipientType.  If this object is set to\n0, the value of gmplsTunnelSendPathNotifyRecipientType MUST be\nset to unknown(0).")
gmplsTunnelAdminStatusFlags = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 1, 1, 18), IANAGmplsAdminStatusInformationTC().clone('()')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelAdminStatusFlags.setDescription("Determines the setting of the Admin Status flags in the\nAdmin Status object or TLV, as described in RFC 3471.  Setting\nthis field to a non-zero value will result in the inclusion of\nthe Admin Status object on signaling messages.\n\nThe values to use are defined in the TEXTUAL-CONVENTION\nIANAGmplsAdminStatusInformationTC found in the\nIANA-GMPLS-TC-MIB module.\n\nThis value of this object can be modified when the\ncorresponding mplsTunnelRowStatus and mplsTunnelAdminStatus\nis active(1).  By doing so, a new signaling message will be\n\n\n\ntriggered including the requested Admin Status object or\nTLV.")
gmplsTunnelExtraParamsPtr = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 1, 1, 19), RowPointer().clone('0.0')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelExtraParamsPtr.setDescription("Some tunnels will run over transports that can usefully support\ntechnology-specific additional parameters (for example,\nSynchronous Optical Network (SONET) resource usage).  Such\nparameters can be supplied in an external table and referenced\nfrom here.\n\nA value of zeroDotzero in this attribute indicates that there\nis no such additional information.")
gmplsTunnelHopTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 2))
if mibBuilder.loadTexts: gmplsTunnelHopTable.setDescription("The gmplsTunnelHopTable sparsely extends the mplsTunnelHopTable\nof MPLS-TE-STD-MIB.  It is used to indicate the Explicit Labels\nto be used in an explicit path for a GMPLS tunnel defined in the\nmplsTunnelTable and gmplsTunnelTable, when it is established\nusing signaling.  It does not insert new hops, but does define\nnew values for hops defined in the mplsTunnelHopTable.\n\nEach row in this table is indexed by the same indexes as in the\nmplsTunnelHopTable.  It is acceptable for some rows in the\nmplsTunnelHopTable to have corresponding entries in this table\nand some to have no corresponding entry in this table.\n\nThe storage type for this entry is given by the value\nof mplsTunnelHopStorageType in the corresponding entry in the\nmplsTunnelHopTable.\n\nThe row status of an entry in this table is controlled by\nmplsTunnelHopRowStatus in the corresponding entry in the\nmplsTunnelHopTable.  That is, it is not permitted to create a row\n\n\n\nin this table, or to modify an existing row, when the\ncorresponding mplsTunnelHopRowStatus has the value active(1).")
gmplsTunnelHopEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 2, 1)).setIndexNames((0, "MPLS-TE-STD-MIB", "mplsTunnelHopListIndex"), (0, "MPLS-TE-STD-MIB", "mplsTunnelHopPathOptionIndex"), (0, "MPLS-TE-STD-MIB", "mplsTunnelHopIndex"))
if mibBuilder.loadTexts: gmplsTunnelHopEntry.setDescription("An entry in this table represents additions to a tunnel hop\ndefined in mplsTunnelHopEntry.  At an ingress to a tunnel, an\nentry in this table is created by a network administrator for an\nERLSP to be set up by a signaling protocol.  At transit and\negress nodes, an entry in this table may be used to represent the\nexplicit path instructions received using the signaling\nprotocol.")
gmplsTunnelHopLabelStatuses = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 2, 1, 1), Bits().subtype(namedValues=NamedValues(("forwardPresent", 0), ("reversePresent", 1), )).clone(())).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelHopLabelStatuses.setDescription("This bitmask indicates the presence of labels indicated by the\ngmplsTunnelHopExplicitForwardLabel or\ngmplsTunnelHopExplicitForwardLabelPtr, and\ngmplsTunnelHopExplicitReverseLabel or\n\n\n\ngmplsTunnelHopExplicitReverseLabelPtr objects.\n\nFor the Present bits, a set bit indicates that a label is\npresent for this hop in the route.  This allows zero to be a\nvalid label value.")
gmplsTunnelHopExplicitForwardLabel = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 2, 1, 2), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelHopExplicitForwardLabel.setDescription("If gmplsTunnelHopLabelStatuses object indicates that a Forward\nLabel is present and gmplsTunnelHopExplicitForwardLabelPtr\ncontains the value zeroDotZero, then the label to use on this\nhop is represented by the value of this object.")
gmplsTunnelHopExplicitForwardLabelPtr = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 2, 1, 3), RowPointer().clone('0.0')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelHopExplicitForwardLabelPtr.setDescription("If the gmplsTunnelHopLabelStatuses object indicates that a\nForward Label is present, this object contains a pointer to a\nrow in another MIB table (such as the gmplsLabelTable of\nGMPLS-LABEL-STD-MIB) that contains the label to use on this hop\nin the forward direction.\n\nIf the gmplsTunnelHopLabelStatuses object indicates that a\nForward Label is present and this object contains the value\nzeroDotZero, then the label to use on this hop is found in the\ngmplsTunnelHopExplicitForwardLabel object.")
gmplsTunnelHopExplicitReverseLabel = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 2, 1, 4), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelHopExplicitReverseLabel.setDescription("If the gmplsTunnelHopLabelStatuses object indicates that a\nReverse Label is present and\ngmplsTunnelHopExplicitReverseLabelPtr contains the value\nzeroDotZero, then the label to use on this hop is found in\nthis object encoded as a 32-bit integer.")
gmplsTunnelHopExplicitReverseLabelPtr = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 2, 1, 5), RowPointer().clone('0.0')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelHopExplicitReverseLabelPtr.setDescription("If the gmplsTunnelHopLabelStatuses object indicates that a\nReverse Label is present, this object contains a pointer to a\nrow in another MIB table (such as the gmplsLabelTable of\nGMPLS-LABEL-STD-MIB) that contains the label to use on this hop\nin the reverse direction.\n\nIf the gmplsTunnelHopLabelStatuses object indicates that a\nReverse Label is present and this object contains the value\nzeroDotZero, then the label to use on this hop is found in the\ngmplsTunnelHopExplicitReverseLabel object.")
gmplsTunnelARHopTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 3))
if mibBuilder.loadTexts: gmplsTunnelARHopTable.setDescription("The gmplsTunnelARHopTable sparsely extends the\nmplsTunnelARHopTable of MPLS-TE-STD-MIB.  It is used to\nindicate the labels currently in use for a GMPLS tunnel\ndefined in the mplsTunnelTable and gmplsTunnelTable, as\nreported by the signaling protocol.  It does not insert\nnew hops, but does define new values for hops defined in\nthe mplsTunnelARHopTable.\n\nEach row in this table is indexed by the same indexes as in the\nmplsTunnelARHopTable.  It is acceptable for some rows in the\nmplsTunnelARHopTable to have corresponding entries in this table\nand some to have no corresponding entry in this table.\n\nNote that since the information necessary to build entries\nwithin this table is not provided by some signaling protocols\nand might not be returned in all cases of other signaling\nprotocols, implementation of this table and the\nmplsTunnelARHopTable is optional.  Furthermore, since the\ninformation in this table is actually provided by the\nsignaling protocol after the path has been set up, the entries\nin this table are provided only for observation, and hence,\nall variables in this table are accessible exclusively as\nread-only.")
gmplsTunnelARHopEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 3, 1)).setIndexNames((0, "MPLS-TE-STD-MIB", "mplsTunnelARHopListIndex"), (0, "MPLS-TE-STD-MIB", "mplsTunnelARHopIndex"))
if mibBuilder.loadTexts: gmplsTunnelARHopEntry.setDescription("An entry in this table represents additions to a tunnel hop\nvisible in mplsTunnelARHopEntry.  An entry is created by the\nsignaling protocol for a signaled ERLSP set up by the signaling\nprotocol.\n\nAt any node on the LSP (ingress, transit, or egress), this table\nand the mplsTunnelARHopTable (if the tables are supported and if\nthe signaling protocol is recording actual route information)\ncontain the actual route of the whole tunnel.  If the signaling\nprotocol is not recording the actual route, this table MAY\nreport the information from the gmplsTunnelHopTable or the\ngmplsTunnelCHopTable.\n\nNote that the recording of actual labels is distinct from the\nrecording of the actual route in some signaling protocols.  This\nfeature is enabled using the gmplsTunnelAttributes object.")
gmplsTunnelARHopLabelStatuses = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 3, 1, 1), Bits().subtype(namedValues=NamedValues(("forwardPresent", 0), ("reversePresent", 1), ("forwardGlobal", 2), ("reverseGlobal", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelARHopLabelStatuses.setDescription("This bitmask indicates the presence and status of labels\nindicated by the gmplsTunnelARHopExplicitForwardLabel or\ngmplsTunnelARHopExplicitForwardLabelPtr, and\ngmplsTunnelARHopExplicitReverseLabel or\ngmplsTunnelARHopExplicitReverseLabelPtr objects.\n\nFor the Present bits, a set bit indicates that a label is\npresent for this hop in the route.\n\nFor the Global bits, a set bit indicates that the label comes\nfrom the Global Label Space; a clear bit indicates that this is\na Per-Interface label.  A Global bit only has meaning if the\ncorresponding Present bit is set.")
gmplsTunnelARHopExplicitForwardLabel = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 3, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelARHopExplicitForwardLabel.setDescription("If the gmplsTunnelARHopLabelStatuses object indicates that a\nForward Label is present and\ngmplsTunnelARHopExplicitForwardLabelPtr contains the value\nzeroDotZero, then the label in use on this hop is found in this\nobject encoded as a 32-bit integer.")
gmplsTunnelARHopExplicitForwardLabelPtr = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 3, 1, 3), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelARHopExplicitForwardLabelPtr.setDescription("If the gmplsTunnelARHopLabelStatuses object indicates that a\nForward Label is present, this object contains a pointer to a\nrow in another MIB table (such as the gmplsLabelTable of\nGMPLS-LABEL-STD-MIB) that contains the label in use on this hop\nin the forward direction.\n\nIf the gmplsTunnelARHopLabelStatuses object indicates that a\nForward Label is present and this object contains the value\nzeroDotZero, then the label in use on this hop is found in the\ngmplsTunnelARHopExplicitForwardLabel object.")
gmplsTunnelARHopExplicitReverseLabel = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 3, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelARHopExplicitReverseLabel.setDescription("If the gmplsTunnelARHopLabelStatuses object indicates that a\nReverse Label is present and\ngmplsTunnelARHopExplicitReverseLabelPtr contains the value\nzeroDotZero, then the label in use on this hop is found in this\nobject encoded as a 32-bit integer.")
gmplsTunnelARHopExplicitReverseLabelPtr = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 3, 1, 5), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelARHopExplicitReverseLabelPtr.setDescription("If the gmplsTunnelARHopLabelStatuses object indicates that a\nReverse Label is present, this object contains a pointer to a\nrow in another MIB table (such as the gmplsLabelTable of\nGMPLS-LABEL-STD-MIB) that contains the label in use on this hop\nin the reverse direction.\n\nIf the gmplsTunnelARHopLabelStatuses object indicates that a\nReverse Label is present and this object contains the value\nzeroDotZero, then the label in use on this hop is found in the\ngmplsTunnelARHopExplicitReverseLabel object.")
gmplsTunnelARHopProtection = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 3, 1, 6), Bits().subtype(namedValues=NamedValues(("localAvailable", 0), ("localInUse", 1), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelARHopProtection.setDescription("Availability and usage of protection on the reported link.\n\nlocalAvailable\n  This flag is set to indicate that the link downstream of this\n  node is protected via a local repair mechanism.\n\nlocalInUse\n  This flag is set to indicate that a local repair mechanism is\n  in use to maintain this tunnel (usually in the face of an\n  outage of the link it was previously routed over).")
gmplsTunnelCHopTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 4))
if mibBuilder.loadTexts: gmplsTunnelCHopTable.setDescription("The gmplsTunnelCHopTable sparsely extends the\nmplsTunnelCHopTable of MPLS-TE-STD-MIB.  It is used to indicate\nadditional information about the hops of a GMPLS tunnel defined\nin the mplsTunnelTable and gmplsTunnelTable, as computed by a\nconstraint-based routing protocol, based on the\nmplsTunnelHopTable and the gmplsTunnelHopTable.\n\nEach row in this table is indexed by the same indexes as in the\nmplsTunnelCHopTable.  It is acceptable for some rows in the\nmplsTunnelCHopTable to have corresponding entries in this table\nand some to have no corresponding entry in this table.\n\nPlease note that since the information necessary to build\nentries within this table may not be supported by some LSRs,\nimplementation of this table is optional.\n\nFurthermore, since the information in this table is actually\nprovided by a path computation component after the path has been\ncomputed, the entries in this table are provided only for\nobservation, and hence, all objects in this table are accessible\nexclusively as read-only.")
gmplsTunnelCHopEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 4, 1)).setIndexNames((0, "MPLS-TE-STD-MIB", "mplsTunnelCHopListIndex"), (0, "MPLS-TE-STD-MIB", "mplsTunnelCHopIndex"))
if mibBuilder.loadTexts: gmplsTunnelCHopEntry.setDescription("An entry in this table represents additions to a computed tunnel\nhop visible in mplsTunnelCHopEntry.  An entry is created by a\npath computation component based on the hops specified in the\ncorresponding mplsTunnelHopTable and gmplsTunnelHopTable.\n\nAt a transit LSR, this table (if the table is supported) MAY\ncontain the path computed by a path computation engine on (or on\n\n\n\nbehalf of) the transit LSR.")
gmplsTunnelCHopLabelStatuses = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 4, 1, 1), Bits().subtype(namedValues=NamedValues(("forwardPresent", 0), ("reversePresent", 1), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelCHopLabelStatuses.setDescription("This bitmask indicates the presence of labels indicated by the\ngmplsTunnelCHopExplicitForwardLabel or\ngmplsTunnelCHopExplicitForwardLabelPtr and\ngmplsTunnelCHopExplicitReverseLabel or\ngmplsTunnelCHopExplicitReverseLabelPtr objects.\n\nA set bit indicates that a label is present for this hop in the\nroute, thus allowing zero to be a valid label value.")
gmplsTunnelCHopExplicitForwardLabel = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 4, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelCHopExplicitForwardLabel.setDescription("If the gmplsTunnelCHopLabelStatuses object indicates that a\nForward Label is present and\ngmplsTunnelCHopExplicitForwardLabelPtr contains the value\nzeroDotZero, then the label to use on this hop is found in this\nobject encoded as a 32-bit integer.")
gmplsTunnelCHopExplicitForwardLabelPtr = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 4, 1, 3), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelCHopExplicitForwardLabelPtr.setDescription("If the gmplsTunnelCHopLabelStatuses object indicates that a\nForward Label is present, this object contains a pointer to a\nrow in another MIB table (such as the gmplsLabelTable of\nGMPLS-LABEL-STD-MIB) that contains the label to use on this hop\nin the forward direction.\n\nIf the gmplsTunnelCHopLabelStatuses object indicates that a\nForward Label is present and this object contains the value\nzeroDotZero, then the label to use on this hop is found in the\ngmplsTunnelCHopExplicitForwardLabel object.")
gmplsTunnelCHopExplicitReverseLabel = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 4, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelCHopExplicitReverseLabel.setDescription("If the gmplsTunnelCHopLabelStatuses object indicates that a\nReverse Label is present and\ngmplsTunnelCHopExplicitReverseLabelPtr contains the value\nzeroDotZero, then the label to use on this hop is found in this\nobject encoded as a 32-bit integer.")
gmplsTunnelCHopExplicitReverseLabelPtr = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 4, 1, 5), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelCHopExplicitReverseLabelPtr.setDescription("If the gmplsTunnelCHopLabelStatuses object indicates that a\nReverse Label is present, this object contains a pointer to a\nrow in another MIB table (such as the gmplsLabelTable of\nGMPLS-LABEL-STD-MIB) that contains the label to use on this hop\nin the reverse direction.\n\nIf the gmplsTunnelCHopLabelStatuses object indicates that a\nReverse Label is present and this object contains the value\nzeroDotZero, then the label to use on this hop is found in the\ngmplsTunnelCHopExplicitReverseLabel object.")
gmplsTunnelReversePerfTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 5))
if mibBuilder.loadTexts: gmplsTunnelReversePerfTable.setDescription("This table augments the gmplsTunnelTable to provide\nper-tunnel packet performance information for the reverse\ndirection of a bidirectional tunnel.  It can be seen as\nsupplementing the mplsTunnelPerfTable, which augments the\nmplsTunnelTable.\n\nFor links that do not transport packets, these packet counters\ncannot be maintained.  For such links, attempts to read the\nobjects in this table will return noSuchInstance.\n\nA tunnel can be known to be bidirectional by inspecting the\ngmplsTunnelDirection object.")
gmplsTunnelReversePerfEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 5, 1))
if mibBuilder.loadTexts: gmplsTunnelReversePerfEntry.setDescription("An entry in this table is created by the LSR for every\nbidirectional GMPLS tunnel where packets are visible to the\nLSR.")
gmplsTunnelReversePerfPackets = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 5, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelReversePerfPackets.setDescription("Number of packets forwarded on the tunnel in the reverse\ndirection if it is bidirectional.\n\nThis object represents the 32-bit value of the least\nsignificant part of the 64-bit value if both\ngmplsTunnelReversePerfHCPackets and this object are returned.\n\n\n\n\nFor links that do not transport packets, this packet counter\ncannot be maintained.  For such links, this value will return\nnoSuchInstance.")
gmplsTunnelReversePerfHCPackets = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 5, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelReversePerfHCPackets.setDescription("High-capacity counter for number of packets forwarded on the\ntunnel in the reverse direction if it is bidirectional.\n\nFor links that do not transport packets, this packet counter\ncannot be maintained.  For such links, this value will return\nnoSuchInstance.")
gmplsTunnelReversePerfErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 5, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelReversePerfErrors.setDescription("Number of errored packets received on the tunnel in the reverse\ndirection if it is bidirectional.  For links that do not\ntransport packets, this packet counter cannot be maintained.  For\nsuch links, this value will return noSuchInstance.")
gmplsTunnelReversePerfBytes = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelReversePerfBytes.setDescription("Number of bytes forwarded on the tunnel in the reverse direction\nif it is bidirectional.\n\nThis object represents the 32-bit value of the least\nsignificant part of the 64-bit value if both\ngmplsTunnelReversePerfHCBytes and this object are returned.\n\nFor links that do not transport packets, this packet counter\ncannot be maintained.  For such links, this value will return\nnoSuchInstance.")
gmplsTunnelReversePerfHCBytes = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 5, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelReversePerfHCBytes.setDescription("High-capacity counter for number of bytes forwarded on the\ntunnel in the reverse direction if it is bidirectional.\n\nFor links that do not transport packets, this packet counter\ncannot be maintained.  For such links, this value will return\nnoSuchInstance.")
gmplsTunnelErrorTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 6))
if mibBuilder.loadTexts: gmplsTunnelErrorTable.setDescription("This table augments the mplsTunnelTable.\n\nThis table provides per-tunnel information about errors.  Errors\nmay be detected locally or reported through the signaling\nprotocol.  Error reporting is not exclusive to GMPLS, and this\ntable may be applied in MPLS systems.\n\nEntries in this table are not persistent over system resets\nor re-initializations of the management system.")
gmplsTunnelErrorEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 6, 1))
if mibBuilder.loadTexts: gmplsTunnelErrorEntry.setDescription("An entry in this table is created by the LSR for every tunnel\nwhere error information is visible to the LSR.\n\nNote that systems that read the objects in this table one at\na time and do not perform atomic operations to read entire\ninstantiated table rows at once, should, for each conceptual\ncolumn with valid data, read gmplsTunnelErrorLastTime\nprior to the other objects in the row and again subsequent to\nreading the last object of the row.  They should verify that\nthe value of gmplsTunnelErrorLastTime did not change and\nthereby ensure that all data read belongs to the same error\nevent.")
gmplsTunnelErrorLastErrorType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 6, 1, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(0,4,2,3,1,5,6,)).subtype(namedValues=NamedValues(("noError", 0), ("unknown", 1), ("protocol", 2), ("pathComputation", 3), ("localConfiguration", 4), ("localResources", 5), ("localOther", 6), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelErrorLastErrorType.setDescription("The nature of the last error.  Provides interpretation context\nfor gmplsTunnelErrorProtocolCode and\ngmplsTunnelErrorProtocolSubcode.\n\nA value of noError(0) shows that there is no error associated\nwith this tunnel and means that the other objects in this table\nentry (conceptual row) have no meaning.\n\nA value of unknown(1) shows that there is an error but that no\nadditional information about the cause is known.  The error may\nhave been received in a signaled message or generated locally.\n\nA value of protocol(2) or pathComputation(3) indicates the\ncause of an error and identifies an error that has been received\nthrough signaling or will itself be signaled.\n\nA value of localConfiguration(4), localResources(5) or\nlocalOther(6) identifies an error that has been detected\nby the local node but that will not be reported through\nsignaling.")
gmplsTunnelErrorLastTime = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 6, 1, 2), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelErrorLastTime.setDescription("The time at which the last error occurred.  This is presented as\nthe value of SysUpTime when the error occurred or was reported\nto this node.\n\nIf gmplsTunnelErrorLastErrorType has the value noError(0), then\nthis object is not valid and should be ignored.\n\nNote that entries in this table are not persistent over system\nresets or re-initializations of the management system.")
gmplsTunnelErrorReporterType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 6, 1, 3), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelErrorReporterType.setDescription("The address type of the error reported.\n\nThis object is used to aid in interpretation of\ngmplsTunnelErrorReporter.")
gmplsTunnelErrorReporter = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 6, 1, 4), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelErrorReporter.setDescription("The address of the node reporting the last error, or the address\nof the resource (such as an interface) associated with the\nerror.\n\nIf gmplsTunnelErrorLastErrorType has the value noError(0), then\nthis object is not valid and should be ignored.\n\nIf gmplsTunnelErrorLastErrorType has the value unknown(1),\nlocalConfiguration(4), localResources(5), or localOther(6),\nthis object MAY contain a zero value.\n\nThis object should be interpreted in the context of the value of\nthe object gmplsTunnelErrorReporterType.")
gmplsTunnelErrorCode = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 6, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelErrorCode.setDescription("The primary error code associated with the last error.\n\nThe interpretation of this error code depends on the value of\ngmplsTunnelErrorLastErrorType.  If the value of\ngmplsTunnelErrorLastErrorType is noError(0), the value of this\nobject should be 0 and should be ignored.  If the value of\ngmplsTunnelErrorLastErrorType is protocol(2), the error should\nbe interpreted in the context of the signaling protocol\nidentified by the mplsTunnelSignallingProto object.")
gmplsTunnelErrorSubcode = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 6, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelErrorSubcode.setDescription("The secondary error code associated with the last error and the\nprotocol used to signal this tunnel.  This value is interpreted\nin the context of the value of gmplsTunnelErrorCode.\nIf the value of gmplsTunnelErrorLastErrorType is noError(0), the\nvalue of this object should be 0 and should be ignored.")
gmplsTunnelErrorTLVs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 6, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelErrorTLVs.setDescription("The sequence of interface identifier TLVs reported with the\nerror by the protocol code.  The interpretation of the TLVs and\nthe encoding within the protocol are described in the\nreferences.  A value of zero in the first octet indicates that no\nTLVs are present.")
gmplsTunnelErrorHelpString = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 6, 1, 8), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelErrorHelpString.setDescription("A textual string containing information about the last error,\nrecovery actions, and support advice.  If there is no help string,\nthis object contains a zero length string.\nIf the value of gmplsTunnelErrorLastErrorType is noError(0),\nthis object should contain a zero length string, but may contain\na help string indicating that there is no error.")
gmplsTeConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 13, 3))
gmplsTeGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 13, 3, 1))
gmplsTeCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 13, 3, 2))

# Augmentions
mplsTunnelEntry, = mibBuilder.importSymbols("MPLS-TE-STD-MIB", "mplsTunnelEntry")
mplsTunnelEntry.registerAugmentions(("GMPLS-TE-STD-MIB", "gmplsTunnelErrorEntry"))
gmplsTunnelErrorEntry.setIndexNames(*mplsTunnelEntry.getIndexNames())
gmplsTunnelEntry.registerAugmentions(("GMPLS-TE-STD-MIB", "gmplsTunnelReversePerfEntry"))
gmplsTunnelReversePerfEntry.setIndexNames(*gmplsTunnelEntry.getIndexNames())

# Notifications

gmplsTunnelDown = NotificationType((1, 3, 6, 1, 2, 1, 10, 166, 13, 0, 1)).setObjects(*(("GMPLS-TE-STD-MIB", "gmplsTunnelErrorReporterType"), ("GMPLS-TE-STD-MIB", "gmplsTunnelErrorReporter"), ("GMPLS-TE-STD-MIB", "gmplsTunnelErrorCode"), ("GMPLS-TE-STD-MIB", "gmplsTunnelErrorLastErrorType"), ("MPLS-TE-STD-MIB", "mplsTunnelAdminStatus"), ("GMPLS-TE-STD-MIB", "gmplsTunnelErrorSubcode"), ("MPLS-TE-STD-MIB", "mplsTunnelOperStatus"), ) )
if mibBuilder.loadTexts: gmplsTunnelDown.setDescription("This notification is generated when an mplsTunnelOperStatus\nobject for a tunnel in the gmplsTunnelTable is about to enter\nthe down state from some other state (but not from the\nnotPresent state).  This other state is indicated by the\nincluded value of mplsTunnelOperStatus.\n\nThe objects in this notification provide additional error\ninformation that indicates the reason why the tunnel has\n\n\n\ntransitioned to down(2).\n\nNote that an implementation MUST only issue one of\nmplsTunnelDown and gmplsTunnelDown for any single event on a\nsingle tunnel.  If the tunnel has an entry in the\ngmplsTunnelTable, an implementation SHOULD use gmplsTunnelDown\nfor all tunnel-down events and SHOULD NOT use mplsTunnelDown.\n\nThis notification is subject to the control of\nmplsTunnelNotificationEnable.  When that object is set\nto false(2), then the notification must not be issued.\n\nFurther, this notification is also subject to\nmplsTunnelNotificationMaxRate.  That object indicates the\nmaximum number of notifications issued per second.  If events\noccur more rapidly, the implementation may simply fail to emit\nsome notifications during that period, or may queue them until\nan appropriate time.  The notification rate applies to the sum\nof all notifications in the MPLS-TE-STD-MIB and\nGMPLS-TE-STD-MIB modules applied across the whole of the\nreporting device.\n\nmplsTunnelOperStatus, mplsTunnelAdminStatus, mplsTunnelDown,\nmplsTunnelNotificationEnable, and mplsTunnelNotificationMaxRate\nobjects are found in MPLS-TE-STD-MIB.")

# Groups

gmplsTunnelGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 166, 13, 3, 1, 1)).setObjects(*(("GMPLS-TE-STD-MIB", "gmplsTunnelReversePerfPackets"), ("GMPLS-TE-STD-MIB", "gmplsTunnelErrorReporterType"), ("GMPLS-TE-STD-MIB", "gmplsTunnelErrorCode"), ("GMPLS-TE-STD-MIB", "gmplsTunnelErrorTLVs"), ("GMPLS-TE-STD-MIB", "gmplsTunnelReversePerfBytes"), ("GMPLS-TE-STD-MIB", "gmplsTunnelErrorSubcode"), ("GMPLS-TE-STD-MIB", "gmplsTunnelDirection"), ("GMPLS-TE-STD-MIB", "gmplsTunnelUnnumIf"), ("GMPLS-TE-STD-MIB", "gmplsTunnelErrorHelpString"), ("GMPLS-TE-STD-MIB", "gmplsTunnelErrorReporter"), ("GMPLS-TE-STD-MIB", "gmplsTunnelReversePerfErrors"), ("GMPLS-TE-STD-MIB", "gmplsTunnelErrorLastErrorType"), ("GMPLS-TE-STD-MIB", "gmplsTunnelReversePerfHCBytes"), ("GMPLS-TE-STD-MIB", "gmplsTunnelErrorLastTime"), ("GMPLS-TE-STD-MIB", "gmplsTunnelReversePerfHCPackets"), ) )
if mibBuilder.loadTexts: gmplsTunnelGroup.setDescription("Necessary, but not sufficient, set of objects to implement\ntunnels.  In addition, depending on the type of the tunnels\nsupported (for example, manually configured or signaled,\npersistent or non-persistent, etc.), the\ngmplsTunnelSignaledGroup group is mandatory.")
gmplsTunnelSignaledGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 166, 13, 3, 1, 2)).setObjects(*(("GMPLS-TE-STD-MIB", "gmplsTunnelUpstreamNotifyRecipientType"), ("GMPLS-TE-STD-MIB", "gmplsTunnelHopExplicitReverseLabelPtr"), ("GMPLS-TE-STD-MIB", "gmplsTunnelSendResvNotifyRecipientType"), ("GMPLS-TE-STD-MIB", "gmplsTunnelSendPathNotifyRecipient"), ("GMPLS-TE-STD-MIB", "gmplsTunnelLinkProtection"), ("GMPLS-TE-STD-MIB", "gmplsTunnelPathComp"), ("GMPLS-TE-STD-MIB", "gmplsTunnelHopExplicitForwardLabel"), ("GMPLS-TE-STD-MIB", "gmplsTunnelAdminStatusFlags"), ("GMPLS-TE-STD-MIB", "gmplsTunnelDownstreamNotifyRecipient"), ("GMPLS-TE-STD-MIB", "gmplsTunnelHopExplicitForwardLabelPtr"), ("GMPLS-TE-STD-MIB", "gmplsTunnelHopLabelStatuses"), ("GMPLS-TE-STD-MIB", "gmplsTunnelSendPathNotifyRecipientType"), ("GMPLS-TE-STD-MIB", "gmplsTunnelGPid"), ("GMPLS-TE-STD-MIB", "gmplsTunnelAttributes"), ("GMPLS-TE-STD-MIB", "gmplsTunnelUpstreamNotifyRecipient"), ("GMPLS-TE-STD-MIB", "gmplsTunnelDownstreamNotifyRecipientType"), ("GMPLS-TE-STD-MIB", "gmplsTunnelSwitchingType"), ("GMPLS-TE-STD-MIB", "gmplsTunnelHopExplicitReverseLabel"), ("GMPLS-TE-STD-MIB", "gmplsTunnelSendResvNotifyRecipient"), ("GMPLS-TE-STD-MIB", "gmplsTunnelSecondary"), ("GMPLS-TE-STD-MIB", "gmplsTunnelLSPEncoding"), ) )
if mibBuilder.loadTexts: gmplsTunnelSignaledGroup.setDescription("Objects needed to implement signaled tunnels.")
gmplsTunnelScalarGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 166, 13, 3, 1, 3)).setObjects(*(("GMPLS-TE-STD-MIB", "gmplsTunnelsActive"), ("GMPLS-TE-STD-MIB", "gmplsTunnelsConfigured"), ) )
if mibBuilder.loadTexts: gmplsTunnelScalarGroup.setDescription("Scalar objects needed to implement MPLS tunnels.")
gmplsTunnelOptionalGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 166, 13, 3, 1, 4)).setObjects(*(("GMPLS-TE-STD-MIB", "gmplsTunnelExtraParamsPtr"), ("GMPLS-TE-STD-MIB", "gmplsTunnelCHopExplicitReverseLabelPtr"), ("GMPLS-TE-STD-MIB", "gmplsTunnelARHopExplicitForwardLabel"), ("GMPLS-TE-STD-MIB", "gmplsTunnelCHopLabelStatuses"), ("GMPLS-TE-STD-MIB", "gmplsTunnelARHopLabelStatuses"), ("GMPLS-TE-STD-MIB", "gmplsTunnelARHopExplicitReverseLabel"), ("GMPLS-TE-STD-MIB", "gmplsTunnelCHopExplicitForwardLabelPtr"), ("GMPLS-TE-STD-MIB", "gmplsTunnelARHopProtection"), ("GMPLS-TE-STD-MIB", "gmplsTunnelARHopExplicitReverseLabelPtr"), ("GMPLS-TE-STD-MIB", "gmplsTunnelARHopExplicitForwardLabelPtr"), ("GMPLS-TE-STD-MIB", "gmplsTunnelCHopExplicitReverseLabel"), ("GMPLS-TE-STD-MIB", "gmplsTunnelCHopExplicitForwardLabel"), ) )
if mibBuilder.loadTexts: gmplsTunnelOptionalGroup.setDescription("The objects in this group are optional.")
gmplsTeNotificationGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 10, 166, 13, 3, 1, 5)).setObjects(*(("GMPLS-TE-STD-MIB", "gmplsTunnelDown"), ) )
if mibBuilder.loadTexts: gmplsTeNotificationGroup.setDescription("Set of notifications implemented in this module.  None is\nmandatory.")

# Compliances

gmplsTeModuleFullCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 166, 13, 3, 2, 1)).setObjects(*(("GMPLS-TE-STD-MIB", "gmplsTunnelOptionalGroup"), ("GMPLS-TE-STD-MIB", "gmplsTunnelScalarGroup"), ("GMPLS-TE-STD-MIB", "gmplsTunnelGroup"), ("GMPLS-TE-STD-MIB", "gmplsTeNotificationGroup"), ("MPLS-TE-STD-MIB", "mplsTunnelScalarGroup"), ("MPLS-TE-STD-MIB", "mplsTunnelGroup"), ("GMPLS-TE-STD-MIB", "gmplsTunnelSignaledGroup"), ) )
if mibBuilder.loadTexts: gmplsTeModuleFullCompliance.setDescription("Compliance statement for agents that provide full support for\nGMPLS-TE-STD-MIB.  Such devices can then be monitored and also\nbe configured using this MIB module.\n\nThe mandatory group has to be implemented by all LSRs that\noriginate, terminate, or act as transit for TE-LSPs/tunnels.\nIn addition, depending on the type of tunnels supported, other\n\n\n\ngroups become mandatory as explained below.")
gmplsTeModuleReadOnlyCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 166, 13, 3, 2, 2)).setObjects(*(("GMPLS-TE-STD-MIB", "gmplsTunnelScalarGroup"), ("GMPLS-TE-STD-MIB", "gmplsTeNotificationGroup"), ("GMPLS-TE-STD-MIB", "gmplsTunnelGroup"), ("GMPLS-TE-STD-MIB", "gmplsTunnelSignaledGroup"), ("GMPLS-TE-STD-MIB", "gmplsTunnelOptionalGroup"), ) )
if mibBuilder.loadTexts: gmplsTeModuleReadOnlyCompliance.setDescription("Compliance requirement for implementations that only provide\nread-only support for GMPLS-TE-STD-MIB.  Such devices can then be\nmonitored but cannot be configured using this MIB module.")

# Exports

# Module identity
mibBuilder.exportSymbols("GMPLS-TE-STD-MIB", PYSNMP_MODULE_ID=gmplsTeStdMIB)

# Objects
mibBuilder.exportSymbols("GMPLS-TE-STD-MIB", gmplsTeStdMIB=gmplsTeStdMIB, gmplsTeNotifications=gmplsTeNotifications, gmplsTeScalars=gmplsTeScalars, gmplsTunnelsConfigured=gmplsTunnelsConfigured, gmplsTunnelsActive=gmplsTunnelsActive, gmplsTeObjects=gmplsTeObjects, gmplsTunnelTable=gmplsTunnelTable, gmplsTunnelEntry=gmplsTunnelEntry, gmplsTunnelUnnumIf=gmplsTunnelUnnumIf, gmplsTunnelAttributes=gmplsTunnelAttributes, gmplsTunnelLSPEncoding=gmplsTunnelLSPEncoding, gmplsTunnelSwitchingType=gmplsTunnelSwitchingType, gmplsTunnelLinkProtection=gmplsTunnelLinkProtection, gmplsTunnelGPid=gmplsTunnelGPid, gmplsTunnelSecondary=gmplsTunnelSecondary, gmplsTunnelDirection=gmplsTunnelDirection, gmplsTunnelPathComp=gmplsTunnelPathComp, gmplsTunnelUpstreamNotifyRecipientType=gmplsTunnelUpstreamNotifyRecipientType, gmplsTunnelUpstreamNotifyRecipient=gmplsTunnelUpstreamNotifyRecipient, gmplsTunnelSendResvNotifyRecipientType=gmplsTunnelSendResvNotifyRecipientType, gmplsTunnelSendResvNotifyRecipient=gmplsTunnelSendResvNotifyRecipient, gmplsTunnelDownstreamNotifyRecipientType=gmplsTunnelDownstreamNotifyRecipientType, gmplsTunnelDownstreamNotifyRecipient=gmplsTunnelDownstreamNotifyRecipient, gmplsTunnelSendPathNotifyRecipientType=gmplsTunnelSendPathNotifyRecipientType, gmplsTunnelSendPathNotifyRecipient=gmplsTunnelSendPathNotifyRecipient, gmplsTunnelAdminStatusFlags=gmplsTunnelAdminStatusFlags, gmplsTunnelExtraParamsPtr=gmplsTunnelExtraParamsPtr, gmplsTunnelHopTable=gmplsTunnelHopTable, gmplsTunnelHopEntry=gmplsTunnelHopEntry, gmplsTunnelHopLabelStatuses=gmplsTunnelHopLabelStatuses, gmplsTunnelHopExplicitForwardLabel=gmplsTunnelHopExplicitForwardLabel, gmplsTunnelHopExplicitForwardLabelPtr=gmplsTunnelHopExplicitForwardLabelPtr, gmplsTunnelHopExplicitReverseLabel=gmplsTunnelHopExplicitReverseLabel, gmplsTunnelHopExplicitReverseLabelPtr=gmplsTunnelHopExplicitReverseLabelPtr, gmplsTunnelARHopTable=gmplsTunnelARHopTable, gmplsTunnelARHopEntry=gmplsTunnelARHopEntry, gmplsTunnelARHopLabelStatuses=gmplsTunnelARHopLabelStatuses, gmplsTunnelARHopExplicitForwardLabel=gmplsTunnelARHopExplicitForwardLabel, gmplsTunnelARHopExplicitForwardLabelPtr=gmplsTunnelARHopExplicitForwardLabelPtr, gmplsTunnelARHopExplicitReverseLabel=gmplsTunnelARHopExplicitReverseLabel, gmplsTunnelARHopExplicitReverseLabelPtr=gmplsTunnelARHopExplicitReverseLabelPtr, gmplsTunnelARHopProtection=gmplsTunnelARHopProtection, gmplsTunnelCHopTable=gmplsTunnelCHopTable, gmplsTunnelCHopEntry=gmplsTunnelCHopEntry, gmplsTunnelCHopLabelStatuses=gmplsTunnelCHopLabelStatuses, gmplsTunnelCHopExplicitForwardLabel=gmplsTunnelCHopExplicitForwardLabel, gmplsTunnelCHopExplicitForwardLabelPtr=gmplsTunnelCHopExplicitForwardLabelPtr, gmplsTunnelCHopExplicitReverseLabel=gmplsTunnelCHopExplicitReverseLabel, gmplsTunnelCHopExplicitReverseLabelPtr=gmplsTunnelCHopExplicitReverseLabelPtr, gmplsTunnelReversePerfTable=gmplsTunnelReversePerfTable, gmplsTunnelReversePerfEntry=gmplsTunnelReversePerfEntry, gmplsTunnelReversePerfPackets=gmplsTunnelReversePerfPackets, gmplsTunnelReversePerfHCPackets=gmplsTunnelReversePerfHCPackets, gmplsTunnelReversePerfErrors=gmplsTunnelReversePerfErrors, gmplsTunnelReversePerfBytes=gmplsTunnelReversePerfBytes, gmplsTunnelReversePerfHCBytes=gmplsTunnelReversePerfHCBytes, gmplsTunnelErrorTable=gmplsTunnelErrorTable, gmplsTunnelErrorEntry=gmplsTunnelErrorEntry, gmplsTunnelErrorLastErrorType=gmplsTunnelErrorLastErrorType, gmplsTunnelErrorLastTime=gmplsTunnelErrorLastTime, gmplsTunnelErrorReporterType=gmplsTunnelErrorReporterType, gmplsTunnelErrorReporter=gmplsTunnelErrorReporter, gmplsTunnelErrorCode=gmplsTunnelErrorCode, gmplsTunnelErrorSubcode=gmplsTunnelErrorSubcode, gmplsTunnelErrorTLVs=gmplsTunnelErrorTLVs, gmplsTunnelErrorHelpString=gmplsTunnelErrorHelpString, gmplsTeConformance=gmplsTeConformance, gmplsTeGroups=gmplsTeGroups, gmplsTeCompliances=gmplsTeCompliances)

# Notifications
mibBuilder.exportSymbols("GMPLS-TE-STD-MIB", gmplsTunnelDown=gmplsTunnelDown)

# Groups
mibBuilder.exportSymbols("GMPLS-TE-STD-MIB", gmplsTunnelGroup=gmplsTunnelGroup, gmplsTunnelSignaledGroup=gmplsTunnelSignaledGroup, gmplsTunnelScalarGroup=gmplsTunnelScalarGroup, gmplsTunnelOptionalGroup=gmplsTunnelOptionalGroup, gmplsTeNotificationGroup=gmplsTeNotificationGroup)

# Compliances
mibBuilder.exportSymbols("GMPLS-TE-STD-MIB", gmplsTeModuleFullCompliance=gmplsTeModuleFullCompliance, gmplsTeModuleReadOnlyCompliance=gmplsTeModuleReadOnlyCompliance)
