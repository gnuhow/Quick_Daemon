# PySNMP SMI module. Autogenerated from smidump -f python TUNNEL-MIB
# by libsmi2pysnmp-0.1.3 at Mon Apr  2 20:39:47 2012,
# Python version sys.version_info(major=2, minor=7, micro=2, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( IANAtunnelType, ) = mibBuilder.importSymbols("IANAifType-MIB", "IANAtunnelType")
( InterfaceIndexOrZero, ifIndex, ) = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero", "ifIndex")
( InetAddress, InetAddressType, ) = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType")
( IPv6FlowLabelOrAny, ) = mibBuilder.importSymbols("IPV6-FLOW-LABEL-MIB", "IPv6FlowLabelOrAny")
( ModuleCompliance, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup")
( Bits, Integer32, Integer32, IpAddress, ModuleIdentity, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, transmission, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Integer32", "Integer32", "IpAddress", "ModuleIdentity", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "transmission")
( RowStatus, StorageType, ) = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "StorageType")

# Objects

tunnelMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 10, 131)).setRevisions(("2005-05-16 00:00","1999-08-24 12:00",))
if mibBuilder.loadTexts: tunnelMIB.setOrganization("IETF IP Version 6 (IPv6) Working Group")
if mibBuilder.loadTexts: tunnelMIB.setContactInfo(" Dave Thaler\nMicrosoft Corporation\nOne Microsoft Way\nRedmond, WA  98052-6399\nEMail: dthaler@microsoft.com")
if mibBuilder.loadTexts: tunnelMIB.setDescription("The MIB module for management of IP Tunnels,\nindependent of the specific encapsulation scheme in\nuse.\n\nCopyright (C) The Internet Society (2005).  This\nversion of this MIB module is part of RFC 4087;  see\nthe RFC itself for full legal notices.")
tunnelMIBObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 131, 1))
tunnel = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 131, 1, 1))
tunnelIfTable = MibTable((1, 3, 6, 1, 2, 1, 10, 131, 1, 1, 1))
if mibBuilder.loadTexts: tunnelIfTable.setDescription("The (conceptual) table containing information on\nconfigured tunnels.")
tunnelIfEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 131, 1, 1, 1, 1)).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: tunnelIfEntry.setDescription("An entry (conceptual row) containing the information\non a particular configured tunnel.")
tunnelIfLocalAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 131, 1, 1, 1, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tunnelIfLocalAddress.setDescription("The address of the local endpoint of the tunnel\n(i.e., the source address used in the outer IP\nheader), or 0.0.0.0 if unknown or if the tunnel is\nover IPv6.\n\nSince this object does not support IPv6, it is\ndeprecated in favor of tunnelIfLocalInetAddress.")
tunnelIfRemoteAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 131, 1, 1, 1, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tunnelIfRemoteAddress.setDescription("The address of the remote endpoint of the tunnel\n(i.e., the destination address used in the outer IP\nheader), or 0.0.0.0 if unknown, or an IPv6 address, or\n\n\n\nthe tunnel is not a point-to-point link (e.g., if it\nis a 6to4 tunnel).\n\nSince this object does not support IPv6, it is\ndeprecated in favor of tunnelIfRemoteInetAddress.")
tunnelIfEncapsMethod = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 131, 1, 1, 1, 1, 3), IANAtunnelType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tunnelIfEncapsMethod.setDescription("The encapsulation method used by the tunnel.")
tunnelIfHopLimit = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 131, 1, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tunnelIfHopLimit.setDescription("The IPv4 TTL or IPv6 Hop Limit to use in the outer IP\nheader.  A value of 0 indicates that the value is\ncopied from the payload's header.")
tunnelIfSecurity = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 131, 1, 1, 1, 1, 5), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,3,)).subtype(namedValues=NamedValues(("none", 1), ("ipsec", 2), ("other", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tunnelIfSecurity.setDescription("The method used by the tunnel to secure the outer IP\nheader.  The value ipsec indicates that IPsec is used\nbetween the tunnel endpoints for authentication or\nencryption or both.  More specific security-related\ninformation may be available in a MIB module for the\nsecurity protocol in use.")
tunnelIfTOS = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 131, 1, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tunnelIfTOS.setDescription("The method used to set the high 6 bits (the\n\n\n\ndifferentiated services codepoint) of the IPv4 TOS or\nIPv6 Traffic Class in the outer IP header.  A value of\n-1 indicates that the bits are copied from the\npayload's header.  A value of -2 indicates that a\ntraffic conditioner is invoked and more information\nmay be available in a traffic conditioner MIB module.\nA value between 0 and 63 inclusive indicates that the\nbit field is set to the indicated value.\n\nNote: instead of the name tunnelIfTOS, a better name\nwould have been tunnelIfDSCPMethod, but the existing\nname appeared in RFC 2667 and existing objects cannot\nbe renamed.")
tunnelIfFlowLabel = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 131, 1, 1, 1, 1, 7), IPv6FlowLabelOrAny()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tunnelIfFlowLabel.setDescription("The method used to set the IPv6 Flow Label value.\nThis object need not be present in rows where\ntunnelIfAddressType indicates the tunnel is not over\nIPv6.  A value of -1 indicates that a traffic\nconditioner is invoked and more information may be\navailable in a traffic conditioner MIB.  Any other\nvalue indicates that the Flow Label field is set to\nthe indicated value.")
tunnelIfAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 131, 1, 1, 1, 1, 8), InetAddressType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tunnelIfAddressType.setDescription("The type of address in the corresponding\ntunnelIfLocalInetAddress and tunnelIfRemoteInetAddress\nobjects.")
tunnelIfLocalInetAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 131, 1, 1, 1, 1, 9), InetAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tunnelIfLocalInetAddress.setDescription("The address of the local endpoint of the tunnel\n(i.e., the source address used in the outer IP\nheader).  If the address is unknown, the value is\n\n\n\n0.0.0.0 for IPv4 or :: for IPv6.  The type of this\nobject is given by tunnelIfAddressType.")
tunnelIfRemoteInetAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 131, 1, 1, 1, 1, 10), InetAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tunnelIfRemoteInetAddress.setDescription("The address of the remote endpoint of the tunnel\n(i.e., the destination address used in the outer IP\nheader).  If the address is unknown or the tunnel is\nnot a point-to-point link (e.g., if it is a 6to4\ntunnel), the value is 0.0.0.0 for tunnels over IPv4 or\n:: for tunnels over IPv6.  The type of this object is\ngiven by tunnelIfAddressType.")
tunnelIfEncapsLimit = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 131, 1, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tunnelIfEncapsLimit.setDescription("The maximum number of additional encapsulations\npermitted for packets undergoing encapsulation at this\nnode.  A value of -1 indicates that no limit is\npresent (except as a result of the packet size).")
tunnelConfigTable = MibTable((1, 3, 6, 1, 2, 1, 10, 131, 1, 1, 2))
if mibBuilder.loadTexts: tunnelConfigTable.setDescription("The (conceptual) table containing information on\nconfigured tunnels.  This table can be used to map a\nset of tunnel endpoints to the associated ifIndex\nvalue.  It can also be used for row creation.  Note\nthat every row in the tunnelIfTable with a fixed IPv4\ndestination address should have a corresponding row in\nthe tunnelConfigTable, regardless of whether it was\ncreated via SNMP.\n\nSince this table does not support IPv6, it is\ndeprecated in favor of tunnelInetConfigTable.")
tunnelConfigEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 131, 1, 1, 2, 1)).setIndexNames((0, "TUNNEL-MIB", "tunnelConfigLocalAddress"), (0, "TUNNEL-MIB", "tunnelConfigRemoteAddress"), (0, "TUNNEL-MIB", "tunnelConfigEncapsMethod"), (0, "TUNNEL-MIB", "tunnelConfigID"))
if mibBuilder.loadTexts: tunnelConfigEntry.setDescription("An entry (conceptual row) containing the information\non a particular configured tunnel.\n\nSince this entry does not support IPv6, it is\ndeprecated in favor of tunnelInetConfigEntry.")
tunnelConfigLocalAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 131, 1, 1, 2, 1, 1), IpAddress()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: tunnelConfigLocalAddress.setDescription("The address of the local endpoint of the tunnel, or\n0.0.0.0 if the device is free to choose any of its\naddresses at tunnel establishment time.\n\nSince this object does not support IPv6, it is\ndeprecated in favor of tunnelInetConfigLocalAddress.")
tunnelConfigRemoteAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 131, 1, 1, 2, 1, 2), IpAddress()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: tunnelConfigRemoteAddress.setDescription("The address of the remote endpoint of the tunnel.\n\nSince this object does not support IPv6, it is\ndeprecated in favor of tunnelInetConfigRemoteAddress.")
tunnelConfigEncapsMethod = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 131, 1, 1, 2, 1, 3), IANAtunnelType()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: tunnelConfigEncapsMethod.setDescription("The encapsulation method used by the tunnel.\n\nSince this object does not support IPv6, it is\ndeprecated in favor of tunnelInetConfigEncapsMethod.")
tunnelConfigID = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 131, 1, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: tunnelConfigID.setDescription("An identifier used to distinguish between multiple\ntunnels of the same encapsulation method, with the\nsame endpoints.  If the encapsulation protocol only\nallows one tunnel per set of endpoint addresses (such\nas for GRE or IP-in-IP), the value of this object is\n1.  For encapsulation methods (such as L2F) which\nallow multiple parallel tunnels, the manager is\nresponsible for choosing any ID which does not\nconflict with an existing row, such as choosing a\nrandom number.\n\nSince this object does not support IPv6, it is\ndeprecated in favor of tunnelInetConfigID.")
tunnelConfigIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 131, 1, 1, 2, 1, 5), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tunnelConfigIfIndex.setDescription("If the value of tunnelConfigStatus for this row is\nactive, then this object contains the value of ifIndex\ncorresponding to the tunnel interface.  A value of 0\nis not legal in the active state, and means that the\ninterface index has not yet been assigned.\n\nSince this object does not support IPv6, it is\ndeprecated in favor of tunnelInetConfigIfIndex.")
tunnelConfigStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 131, 1, 1, 2, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tunnelConfigStatus.setDescription("The status of this row, by which new entries may be\ncreated, or old entries deleted from this table.  The\nagent need not support setting this object to\ncreateAndWait or notInService since there are no other\nwritable objects in this table, and writable objects\nin rows of corresponding tables such as the\ntunnelIfTable may be modified while this row is\nactive.\n\nTo create a row in this table for an encapsulation\nmethod which does not support multiple parallel\ntunnels with the same endpoints, the management\nstation should simply use a tunnelConfigID of 1, and\nset tunnelConfigStatus to createAndGo.  For\nencapsulation methods such as L2F which allow multiple\nparallel tunnels, the management station may select a\npseudo-random number to use as the tunnelConfigID and\nset tunnelConfigStatus to createAndGo.  In the event\nthat this ID is already in use and an\ninconsistentValue is returned in response to the set\noperation, the management station should simply select\na new pseudo-random number and retry the operation.\n\nCreating a row in this table will cause an interface\nindex to be assigned by the agent in an\nimplementation-dependent manner, and corresponding\nrows will be instantiated in the ifTable and the\ntunnelIfTable.  The status of this row will become\nactive as soon as the agent assigns the interface\nindex, regardless of whether the interface is\noperationally up.\n\nDeleting a row in this table will likewise delete the\ncorresponding row in the ifTable and in the\ntunnelIfTable.\n\nSince this object does not support IPv6, it is\ndeprecated in favor of tunnelInetConfigStatus.")
tunnelInetConfigTable = MibTable((1, 3, 6, 1, 2, 1, 10, 131, 1, 1, 3))
if mibBuilder.loadTexts: tunnelInetConfigTable.setDescription("The (conceptual) table containing information on\nconfigured tunnels.  This table can be used to map a\nset of tunnel endpoints to the associated ifIndex\nvalue.  It can also be used for row creation.  Note\nthat every row in the tunnelIfTable with a fixed\ndestination address should have a corresponding row in\nthe tunnelInetConfigTable, regardless of whether it\nwas created via SNMP.")
tunnelInetConfigEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 131, 1, 1, 3, 1)).setIndexNames((0, "TUNNEL-MIB", "tunnelInetConfigAddressType"), (0, "TUNNEL-MIB", "tunnelInetConfigLocalAddress"), (0, "TUNNEL-MIB", "tunnelInetConfigRemoteAddress"), (0, "TUNNEL-MIB", "tunnelInetConfigEncapsMethod"), (0, "TUNNEL-MIB", "tunnelInetConfigID"))
if mibBuilder.loadTexts: tunnelInetConfigEntry.setDescription("An entry (conceptual row) containing the information\non a particular configured tunnel.  Note that there is\na 128 subid maximum for object OIDs.  Implementers\nneed to be aware that if the total number of octets in\ntunnelInetConfigLocalAddress and\ntunnelInetConfigRemoteAddress exceeds 110 then OIDs of\ncolumn instances in this table will have more than 128\nsub-identifiers and cannot be accessed using SNMPv1,\nSNMPv2c, or SNMPv3.  In practice this is not expected\nto be a problem since IPv4 and IPv6 addresses will not\ncause the limit to be reached, but if other types are\nsupported by an agent, care must be taken to ensure\nthat the sum of the lengths do not cause the limit to\nbe exceeded.")
tunnelInetConfigAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 131, 1, 1, 3, 1, 1), InetAddressType()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: tunnelInetConfigAddressType.setDescription("The address type over which the tunnel encapsulates\npackets.")
tunnelInetConfigLocalAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 131, 1, 1, 3, 1, 2), InetAddress()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: tunnelInetConfigLocalAddress.setDescription("The address of the local endpoint of the tunnel, or\n0.0.0.0 (for IPv4) or :: (for IPv6) if the device is\nfree to choose any of its addresses at tunnel\nestablishment time.")
tunnelInetConfigRemoteAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 131, 1, 1, 3, 1, 3), InetAddress()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: tunnelInetConfigRemoteAddress.setDescription("The address of the remote endpoint of the tunnel.")
tunnelInetConfigEncapsMethod = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 131, 1, 1, 3, 1, 4), IANAtunnelType()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: tunnelInetConfigEncapsMethod.setDescription("The encapsulation method used by the tunnel.")
tunnelInetConfigID = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 131, 1, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: tunnelInetConfigID.setDescription("An identifier used to distinguish between multiple\ntunnels of the same encapsulation method, with the\nsame endpoints.  If the encapsulation protocol only\nallows one tunnel per set of endpoint addresses (such\nas for GRE or IP-in-IP), the value of this object is\n1.  For encapsulation methods (such as L2F) which\nallow multiple parallel tunnels, the manager is\nresponsible for choosing any ID which does not\n\n\n\nconflict with an existing row, such as choosing a\nrandom number.")
tunnelInetConfigIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 131, 1, 1, 3, 1, 6), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tunnelInetConfigIfIndex.setDescription("If the value of tunnelInetConfigStatus for this row\nis active, then this object contains the value of\nifIndex corresponding to the tunnel interface.  A\nvalue of 0 is not legal in the active state, and means\nthat the interface index has not yet been assigned.")
tunnelInetConfigStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 131, 1, 1, 3, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tunnelInetConfigStatus.setDescription("The status of this row, by which new entries may be\ncreated, or old entries deleted from this table.  The\nagent need not support setting this object to\ncreateAndWait or notInService since there are no other\nwritable objects in this table, and writable objects\nin rows of corresponding tables such as the\ntunnelIfTable may be modified while this row is\nactive.\n\nTo create a row in this table for an encapsulation\nmethod which does not support multiple parallel\ntunnels with the same endpoints, the management\nstation should simply use a tunnelInetConfigID of 1,\nand set tunnelInetConfigStatus to createAndGo.  For\nencapsulation methods such as L2F which allow multiple\nparallel tunnels, the management station may select a\npseudo-random number to use as the tunnelInetConfigID\nand set tunnelInetConfigStatus to createAndGo.  In the\nevent that this ID is already in use and an\ninconsistentValue is returned in response to the set\noperation, the management station should simply select\na new pseudo-random number and retry the operation.\n\nCreating a row in this table will cause an interface\nindex to be assigned by the agent in an\nimplementation-dependent manner, and corresponding\nrows will be instantiated in the ifTable and the\n\n\n\ntunnelIfTable.  The status of this row will become\nactive as soon as the agent assigns the interface\nindex, regardless of whether the interface is\noperationally up.\n\nDeleting a row in this table will likewise delete the\ncorresponding row in the ifTable and in the\ntunnelIfTable.")
tunnelInetConfigStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 131, 1, 1, 3, 1, 8), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tunnelInetConfigStorageType.setDescription("The storage type of this row.  If the row is\npermanent(4), no objects in the row need be writable.")
tunnelMIBConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 131, 2))
tunnelMIBCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 131, 2, 1))
tunnelMIBGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 131, 2, 2))

# Augmentions

# Groups

tunnelMIBBasicGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 131, 2, 2, 1)).setObjects(*(("TUNNEL-MIB", "tunnelConfigIfIndex"), ("TUNNEL-MIB", "tunnelIfHopLimit"), ("TUNNEL-MIB", "tunnelIfEncapsMethod"), ("TUNNEL-MIB", "tunnelIfLocalAddress"), ("TUNNEL-MIB", "tunnelIfRemoteAddress"), ("TUNNEL-MIB", "tunnelIfSecurity"), ("TUNNEL-MIB", "tunnelConfigStatus"), ("TUNNEL-MIB", "tunnelIfTOS"), ) )
if mibBuilder.loadTexts: tunnelMIBBasicGroup.setDescription("A collection of objects to support basic management\n\n\n\nof IPv4 Tunnels.  Since this group cannot support\nIPv6, it is deprecated in favor of\ntunnelMIBInetGroup.")
tunnelMIBInetGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 131, 2, 2, 2)).setObjects(*(("TUNNEL-MIB", "tunnelIfRemoteInetAddress"), ("TUNNEL-MIB", "tunnelInetConfigStorageType"), ("TUNNEL-MIB", "tunnelIfFlowLabel"), ("TUNNEL-MIB", "tunnelIfEncapsLimit"), ("TUNNEL-MIB", "tunnelIfEncapsMethod"), ("TUNNEL-MIB", "tunnelIfTOS"), ("TUNNEL-MIB", "tunnelIfAddressType"), ("TUNNEL-MIB", "tunnelIfSecurity"), ("TUNNEL-MIB", "tunnelInetConfigStatus"), ("TUNNEL-MIB", "tunnelIfHopLimit"), ("TUNNEL-MIB", "tunnelInetConfigIfIndex"), ("TUNNEL-MIB", "tunnelIfLocalInetAddress"), ) )
if mibBuilder.loadTexts: tunnelMIBInetGroup.setDescription("A collection of objects to support basic management\nof IPv4 and IPv6 Tunnels.")

# Compliances

tunnelMIBCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 131, 2, 1, 1)).setObjects(*(("TUNNEL-MIB", "tunnelMIBBasicGroup"), ) )
if mibBuilder.loadTexts: tunnelMIBCompliance.setDescription("The (deprecated) IPv4-only compliance statement for\nthe IP Tunnel MIB.\n\nThis is deprecated in favor of\ntunnelMIBInetFullCompliance and\ntunnelMIBInetReadOnlyCompliance.")
tunnelMIBInetFullCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 131, 2, 1, 2)).setObjects(*(("TUNNEL-MIB", "tunnelMIBInetGroup"), ) )
if mibBuilder.loadTexts: tunnelMIBInetFullCompliance.setDescription("The full compliance statement for the IP Tunnel MIB.")
tunnelMIBInetReadOnlyCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 131, 2, 1, 3)).setObjects(*(("TUNNEL-MIB", "tunnelMIBInetGroup"), ) )
if mibBuilder.loadTexts: tunnelMIBInetReadOnlyCompliance.setDescription("The read-only compliance statement for the IP Tunnel\nMIB.")

# Exports

# Module identity
mibBuilder.exportSymbols("TUNNEL-MIB", PYSNMP_MODULE_ID=tunnelMIB)

# Objects
mibBuilder.exportSymbols("TUNNEL-MIB", tunnelMIB=tunnelMIB, tunnelMIBObjects=tunnelMIBObjects, tunnel=tunnel, tunnelIfTable=tunnelIfTable, tunnelIfEntry=tunnelIfEntry, tunnelIfLocalAddress=tunnelIfLocalAddress, tunnelIfRemoteAddress=tunnelIfRemoteAddress, tunnelIfEncapsMethod=tunnelIfEncapsMethod, tunnelIfHopLimit=tunnelIfHopLimit, tunnelIfSecurity=tunnelIfSecurity, tunnelIfTOS=tunnelIfTOS, tunnelIfFlowLabel=tunnelIfFlowLabel, tunnelIfAddressType=tunnelIfAddressType, tunnelIfLocalInetAddress=tunnelIfLocalInetAddress, tunnelIfRemoteInetAddress=tunnelIfRemoteInetAddress, tunnelIfEncapsLimit=tunnelIfEncapsLimit, tunnelConfigTable=tunnelConfigTable, tunnelConfigEntry=tunnelConfigEntry, tunnelConfigLocalAddress=tunnelConfigLocalAddress, tunnelConfigRemoteAddress=tunnelConfigRemoteAddress, tunnelConfigEncapsMethod=tunnelConfigEncapsMethod, tunnelConfigID=tunnelConfigID, tunnelConfigIfIndex=tunnelConfigIfIndex, tunnelConfigStatus=tunnelConfigStatus, tunnelInetConfigTable=tunnelInetConfigTable, tunnelInetConfigEntry=tunnelInetConfigEntry, tunnelInetConfigAddressType=tunnelInetConfigAddressType, tunnelInetConfigLocalAddress=tunnelInetConfigLocalAddress, tunnelInetConfigRemoteAddress=tunnelInetConfigRemoteAddress, tunnelInetConfigEncapsMethod=tunnelInetConfigEncapsMethod, tunnelInetConfigID=tunnelInetConfigID, tunnelInetConfigIfIndex=tunnelInetConfigIfIndex, tunnelInetConfigStatus=tunnelInetConfigStatus, tunnelInetConfigStorageType=tunnelInetConfigStorageType, tunnelMIBConformance=tunnelMIBConformance, tunnelMIBCompliances=tunnelMIBCompliances, tunnelMIBGroups=tunnelMIBGroups)

# Groups
mibBuilder.exportSymbols("TUNNEL-MIB", tunnelMIBBasicGroup=tunnelMIBBasicGroup, tunnelMIBInetGroup=tunnelMIBInetGroup)

# Compliances
mibBuilder.exportSymbols("TUNNEL-MIB", tunnelMIBCompliance=tunnelMIBCompliance, tunnelMIBInetFullCompliance=tunnelMIBInetFullCompliance, tunnelMIBInetReadOnlyCompliance=tunnelMIBInetReadOnlyCompliance)
