# PySNMP SMI module. Autogenerated from smidump -f python SNMP-REPEATER-MIB
# by libsmi2pysnmp-0.1.3 at Mon Apr  2 20:39:39 2012,
# Python version sys.version_info(major=2, minor=7, micro=2, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( OwnerString, ) = mibBuilder.importSymbols("IF-MIB", "OwnerString")
( ModuleCompliance, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup")
( Bits, Counter32, Counter64, Gauge32, Integer32, Integer32, ModuleIdentity, MibIdentifier, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, TimeTicks, mib_2, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "Counter64", "Gauge32", "Integer32", "Integer32", "ModuleIdentity", "MibIdentifier", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "TimeTicks", "mib-2")
( DisplayString, MacAddress, RowStatus, TextualConvention, TestAndIncr, TimeStamp, ) = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "MacAddress", "RowStatus", "TextualConvention", "TestAndIncr", "TimeStamp")

# Types

class OptMacAddr(TextualConvention, OctetString):
    displayHint = "1x:"
    subtypeSpec = OctetString.subtypeSpec+ConstraintsUnion(ValueSizeConstraint(0,0),ValueSizeConstraint(6,6),)
    

# Objects

snmpDot3RptrMgt = MibIdentifier((1, 3, 6, 1, 2, 1, 22))
rptrBasicPackage = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 1))
rptrRptrInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 1, 1))
rptrGroupCapacity = MibScalar((1, 3, 6, 1, 2, 1, 22, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrGroupCapacity.setDescription("********* THIS OBJECT IS DEPRECATED **********\n\nThe rptrGroupCapacity is the number of groups\nthat can be contained within the repeater.  Within\neach managed repeater, the groups are uniquely\nnumbered in the range from 1 to rptrGroupCapacity.\n\nSome groups may not be present in the repeater, in\nwhich case the actual number of groups present\nwill be less than rptrGroupCapacity.  The number\nof groups present will never be greater than\nrptrGroupCapacity.\n\nNote:  In practice, this will generally be the\nnumber of field-replaceable units (i.e., modules,\ncards, or boards) that can fit in the physical\nrepeater enclosure, and the group numbers will\ncorrespond to numbers marked on the physical\nenclosure.")
rptrOperStatus = MibScalar((1, 3, 6, 1, 2, 1, 22, 1, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(6,2,3,5,1,4,)).subtype(namedValues=NamedValues(("other", 1), ("ok", 2), ("rptrFailure", 3), ("groupFailure", 4), ("portFailure", 5), ("generalFailure", 6), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrOperStatus.setDescription("********* THIS OBJECT IS DEPRECATED **********\n\nThe rptrOperStatus object indicates the\noperational state of the repeater.  The\nrptrHealthText object may be consulted for more\nspecific information about the state of the\nrepeater's health.\n\nIn the case of multiple kinds of failures (e.g.,\nrepeater failure and port failure), the value of\nthis attribute shall reflect the highest priority\nfailure in the following order, listed highest\npriority first:\n\n    rptrFailure(3)\n    groupFailure(4)\n    portFailure(5)\n    generalFailure(6).")
rptrHealthText = MibScalar((1, 3, 6, 1, 2, 1, 22, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrHealthText.setDescription("********* THIS OBJECT IS DEPRECATED **********\n\nThe health text object is a text string that\nprovides information relevant to the operational\nstate of the repeater.  Agents may use this string\nto provide detailed information on current\nfailures, including how they were detected, and/or\ninstructions for problem resolution.  The contents\nare agent-specific.")
rptrReset = MibScalar((1, 3, 6, 1, 2, 1, 22, 1, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("noReset", 1), ("reset", 2), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rptrReset.setDescription("********* THIS OBJECT IS DEPRECATED **********\n\nSetting this object to reset(2) causes a\ntransition to the START state of Fig 9-2 in\nsection 9 [IEEE 802.3 Std] for a 10Mb/s repeater,\nand the START state of Fig 27-2 in section 27\nof that standard for a 100Mb/s repeater.\n\nSetting this object to noReset(1) has no effect.\nThe agent will always return the value noReset(1)\nwhen this object is read.\n\nAfter receiving a request to set this variable to\nreset(2), the agent is allowed to delay the reset\nfor a short period.  For example, the implementor\nmay choose to delay the reset long enough to allow\nthe SNMP response to be transmitted.  In any\nevent, the SNMP response must be transmitted.\n\nThis action does not reset the management counters\ndefined in this document nor does it affect the\nportAdminStatus parameters.  Included in this\naction is the execution of a disruptive Self-Test\nwith the following characteristics:  a) The nature\nof the tests is not specified.  b) The test resets\nthe repeater but without affecting management\ninformation about the repeater.  c) The test does\nnot inject packets onto any segment.  d) Packets\nreceived during the test may or may not be\ntransferred.  e) The test does not interfere with\nmanagement functions.\n\nAfter performing this self-test, the agent will\nupdate the repeater health information (including\nrptrOperStatus and rptrHealthText), and send a\nrptrHealth trap.")
rptrNonDisruptTest = MibScalar((1, 3, 6, 1, 2, 1, 22, 1, 1, 5), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("noSelfTest", 1), ("selfTest", 2), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rptrNonDisruptTest.setDescription("********* THIS OBJECT IS DEPRECATED **********\n\nSetting this object to selfTest(2) causes the\nrepeater to perform a agent-specific, non-\ndisruptive self-test that has the following\ncharacteristics:  a) The nature of the tests is\nnot specified.  b) The test does not change the\nstate of the repeater or management information\nabout the repeater.  c) The test does not inject\npackets onto any segment.  d) The test does not\nprevent the relay of any packets.  e) The test\ndoes not interfere with management functions.\n\nAfter performing this test, the agent will update\nthe repeater health information (including\nrptrOperStatus and rptrHealthText) and send a\nrptrHealth trap.\n\nNote that this definition allows returning an\n'okay' result after doing a trivial test.\n\nSetting this object to noSelfTest(1) has no\neffect.  The agent will always return the value\nnoSelfTest(1) when this object is read.")
rptrTotalPartitionedPorts = MibScalar((1, 3, 6, 1, 2, 1, 22, 1, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrTotalPartitionedPorts.setDescription("********* THIS OBJECT IS DEPRECATED **********\n\nThis object returns the total number of ports in\nthe repeater whose current state meets all three\nof the following criteria:  rptrPortOperStatus\ndoes not have the value notPresent(3),\nrptrPortAdminStatus is enabled(1), and\nrptrPortAutoPartitionState is autoPartitioned(2).")
rptrGroupInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 1, 2))
rptrGroupTable = MibTable((1, 3, 6, 1, 2, 1, 22, 1, 2, 1))
if mibBuilder.loadTexts: rptrGroupTable.setDescription("Table of descriptive and status information about\nthe groups of ports.")
rptrGroupEntry = MibTableRow((1, 3, 6, 1, 2, 1, 22, 1, 2, 1, 1)).setIndexNames((0, "SNMP-REPEATER-MIB", "rptrGroupIndex"))
if mibBuilder.loadTexts: rptrGroupEntry.setDescription("An entry in the table, containing information\nabout a single group of ports.")
rptrGroupIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrGroupIndex.setDescription("This object identifies the group within the\nsystem for which this entry contains\ninformation.")
rptrGroupDescr = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 2, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrGroupDescr.setDescription("********* THIS OBJECT IS DEPRECATED **********\n\nA textual description of the group.  This value\nshould include the full name and version\nidentification of the group's hardware type and\nindicate how the group is differentiated from\nother types of groups in the repeater.  Plug-in\nModule, Rev A' or 'Barney Rubble 10BASE-T 4-port\nSIMM socket Version 2.1' are examples of valid\ngroup descriptions.\n\nIt is mandatory that this only contain printable\nASCII characters.")
rptrGroupObjectID = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 2, 1, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrGroupObjectID.setDescription("The vendor's authoritative identification of the\ngroup.  This value may be allocated within the SMI\nenterprises subtree (1.3.6.1.4.1) and provides a\nstraight-forward and unambiguous means for\ndetermining what kind of group is being managed.\n\nFor example, this object could take the value\n1.3.6.1.4.1.4242.1.2.14 if vendor 'Flintstones,\nInc.' was assigned the subtree 1.3.6.1.4.1.4242,\nand had assigned the identifier\n1.3.6.1.4.1.4242.1.2.14 to its 'Wilma Flintstone\n6-Port FOIRL Plug-in Module.'")
rptrGroupOperStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 2, 1, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(5,3,6,2,1,4,)).subtype(namedValues=NamedValues(("other", 1), ("operational", 2), ("malfunctioning", 3), ("notPresent", 4), ("underTest", 5), ("resetInProgress", 6), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrGroupOperStatus.setDescription("An object that indicates the operational status\nof the group.\n\nA status of notPresent(4) indicates that the group\nis temporarily or permanently physically and/or\nlogically not a part of the repeater.  It is an\nimplementation-specific matter as to whether the\nagent effectively removes notPresent entries from\nthe table.\n\nA status of operational(2) indicates that the\ngroup is functioning, and a status of\nmalfunctioning(3) indicates that the group is\nmalfunctioning in some way.")
rptrGroupLastOperStatusChange = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 2, 1, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrGroupLastOperStatusChange.setDescription("********* THIS OBJECT IS DEPRECATED **********\n\nAn object that contains the value of sysUpTime at\nthe time when the last of the following occurred:\n  1) the agent cold- or warm-started;\n  2) the row for the group was created (such\n     as when the group was added to the system); or\n  3) the value of rptrGroupOperStatus for the\n     group changed.\n\nA value of zero indicates that the group's\noperational status has not changed since the agent\nlast restarted.")
rptrGroupPortCapacity = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrGroupPortCapacity.setDescription("The rptrGroupPortCapacity is the number of ports\nthat can be contained within the group.  Valid\nrange is 1-2147483647.  Within each group, the\nports are uniquely numbered in the range from 1 to\nrptrGroupPortCapacity.\n\nSome ports may not be present in the system, in\nwhich case the actual number of ports present\nwill be less than the value of rptrGroupPortCapacity.\nThe number of ports present in the group will never\nbe greater than the value of rptrGroupPortCapacity.\n\nNote:  In practice, this will generally be the\nnumber of ports on a module, card, or board, and\nthe port numbers will correspond to numbers marked\non the physical embodiment.")
rptrPortInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 1, 3))
rptrPortTable = MibTable((1, 3, 6, 1, 2, 1, 22, 1, 3, 1))
if mibBuilder.loadTexts: rptrPortTable.setDescription("Table of descriptive and status information about\nthe repeater ports in the system.  The number of\nentries is independent of the number of repeaters\nin the managed system.")
rptrPortEntry = MibTableRow((1, 3, 6, 1, 2, 1, 22, 1, 3, 1, 1)).setIndexNames((0, "SNMP-REPEATER-MIB", "rptrPortGroupIndex"), (0, "SNMP-REPEATER-MIB", "rptrPortIndex"))
if mibBuilder.loadTexts: rptrPortEntry.setDescription("An entry in the table, containing information\nabout a single port.")
rptrPortGroupIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortGroupIndex.setDescription("This object identifies the group containing the\nport for which this entry contains information.")
rptrPortIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortIndex.setDescription("This object identifies the port within the group\nfor which this entry contains information.  This\nidentifies the port independently from the repeater\nit may be attached to.  The numbering scheme for\nports is implementation specific; however, this\nvalue can never be greater than\nrptrGroupPortCapacity for the associated group.")
rptrPortAdminStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 3, 1, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rptrPortAdminStatus.setDescription("Setting this object to disabled(2) disables the\nport.  A disabled port neither transmits nor\nreceives.  Once disabled, a port must be\nexplicitly enabled to restore operation.  A port\nwhich is disabled when power is lost or when a\nreset is exerted shall remain disabled when normal\noperation resumes.\n\nThe admin status takes precedence over auto-\npartition and functionally operates between the\nauto-partition mechanism and the AUI/PMA.\n\nSetting this object to enabled(1) enables the port\nand exerts a BEGIN on the port's auto-partition\nstate machine.\n\n(In effect, when a port is disabled, the value of\nrptrPortAutoPartitionState for that port is frozen\nuntil the port is next enabled.  When the port\nbecomes enabled, the rptrPortAutoPartitionState\nbecomes notAutoPartitioned(1), regardless of its\npre-disabling state.)")
rptrPortAutoPartitionState = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 3, 1, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("notAutoPartitioned", 1), ("autoPartitioned", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortAutoPartitionState.setDescription("The autoPartitionState flag indicates whether the\nport is currently partitioned by the repeater's\nauto-partition protection.\n\nThe conditions that cause port partitioning are\nspecified in partition state machine in Sections\n9 and 27 of [IEEE 802.3 Std].  They are not\ndifferentiated here.")
rptrPortOperStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 3, 1, 1, 5), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,3,)).subtype(namedValues=NamedValues(("operational", 1), ("notOperational", 2), ("notPresent", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortOperStatus.setDescription("This object indicates the port's operational\nstatus.  The notPresent(3) status indicates the\nport is physically removed (note this may or may\nnot be possible depending on the type of port.)\nThe operational(1) status indicates that the port\nis enabled (see rptrPortAdminStatus) and working,\neven though it might be auto-partitioned (see\nrptrPortAutoPartitionState).\n\nIf this object has the value operational(1) and\nrptrPortAdminStatus is set to disabled(2), it is\nexpected that this object's value will soon change\nto notOperational(2).")
rptrPortRptrId = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortRptrId.setDescription("This object identifies the repeater to\nwhich this port belongs.  The repeater\nidentified by a particular value of this object\nis the same as that identified by the same\nvalue of rptrInfoId.  A value of zero\nindicates that this port currently is not\na member of any repeater.")
rptrAllRptrInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 1, 4))
rptrInfoTable = MibTable((1, 3, 6, 1, 2, 1, 22, 1, 4, 1))
if mibBuilder.loadTexts: rptrInfoTable.setDescription("A table of information about each\nnon-trivial repeater. The number of entries\ndepends on the physical configuration of the\nmanaged system.")
rptrInfoEntry = MibTableRow((1, 3, 6, 1, 2, 1, 22, 1, 4, 1, 1)).setIndexNames((0, "SNMP-REPEATER-MIB", "rptrInfoId"))
if mibBuilder.loadTexts: rptrInfoEntry.setDescription("An entry in the table, containing information\nabout a single non-trivial repeater.")
rptrInfoId = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrInfoId.setDescription("This object identifies the repeater for which\nthis entry contains information.")
rptrInfoRptrType = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 4, 1, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(2,3,1,4,)).subtype(namedValues=NamedValues(("other", 1), ("tenMb", 2), ("onehundredMbClassI", 3), ("onehundredMbClassII", 4), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrInfoRptrType.setDescription("The rptrInfoRptrType returns a value that identifies\nthe CSMA/CD repeater type.")
rptrInfoOperStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 4, 1, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(3,1,2,)).subtype(namedValues=NamedValues(("other", 1), ("ok", 2), ("failure", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrInfoOperStatus.setDescription("The rptrInfoOperStatus object indicates the\noperational state of the repeater.")
rptrInfoReset = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 4, 1, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("noReset", 1), ("reset", 2), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rptrInfoReset.setDescription("Setting this object to reset(2) causes a\ntransition to the START state of Fig 9-2 in\nsection 9 [IEEE 802.3 Std] for a 10Mb/s repeater,\nand to the START state of Fig 27-2 in section 27\nof that standard for a 100Mb/s repeater.\n\nSetting this object to noReset(1) has no effect.\nThe agent will always return the value noReset(1)\nwhen this object is read.\n\nAfter receiving a request to set this variable to\nreset(2), the agent is allowed to delay the reset\nfor a short period.  For example, the implementor\nmay choose to delay the reset long enough to allow\nthe SNMP response to be transmitted.  In any\nevent, the SNMP response must be transmitted.\n\nThis action does not reset the management counters\ndefined in this document nor does it affect the\nportAdminStatus parameters.  Included in this\naction is the execution of a disruptive Self-Test\nwith the following characteristics:  a) The nature\nof the tests is not specified.  b) The test resets\nthe repeater but without affecting management\ninformation about the repeater.  c) The test does\nnot inject packets onto any segment.  d) Packets\nreceived during the test may or may not be\ntransferred.  e) The test does not interfere with\nmanagement functions.\n\nAfter performing this self-test, the agent will\nupdate the repeater health information (including\nrptrInfoOperStatus), and send a rptrInfoResetEvent\nnotification.")
rptrInfoPartitionedPorts = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 4, 1, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrInfoPartitionedPorts.setDescription("This object returns the total number of ports in\nthe repeater whose current state meets all three\nof the following criteria:  rptrPortOperStatus\ndoes not have the value notPresent(3),\nrptrPortAdminStatus is enabled(1), and\nrptrPortAutoPartitionState is autoPartitioned(2).")
rptrInfoLastChange = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 4, 1, 1, 6), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrInfoLastChange.setDescription("The value of sysUpTime when any of the following\nconditions occurred:\n  1) agent cold- or warm-started;\n  2) this instance of repeater was created\n     (such as when a device or module was\n     added to the system);\n  3) a change in the value of rptrInfoOperStatus;\n  4) ports were added or removed as members of\n     the repeater; or\n  5) any of the counters associated with this\n     repeater had a discontinuity.")
rptrMonitorPackage = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 2))
rptrMonitorRptrInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 2, 1))
rptrMonitorTransmitCollisions = MibScalar((1, 3, 6, 1, 2, 1, 22, 2, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorTransmitCollisions.setDescription("********* THIS OBJECT IS DEPRECATED **********\n\nFor a clause 9 (10Mb/s) repeater, this counter\nis incremented every time the repeater state\nmachine enters the TRANSMIT COLLISION state\nfrom any state other than ONE PORT LEFT\n(Ref: Fig 9-2 [IEEE 802.3 Std]).\n\nFor a clause 27 repeater, this counter is\nincremented every time the repeater core state\ndiagram enters the Jam state as a result of\nActivity(ALL) > 1 (fig 27-2 [IEEE 802.3 Std]).\nThe approximate minimum time for rollover of this\ncounter is 16 hours in a 10Mb/s repeater and 1.6\nhours in a 100Mb/s repeater.")
rptrMonitorGroupInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 2, 2))
rptrMonitorGroupTable = MibTable((1, 3, 6, 1, 2, 1, 22, 2, 2, 1))
if mibBuilder.loadTexts: rptrMonitorGroupTable.setDescription("********* THIS OBJECT IS DEPRECATED **********\n\nTable of performance and error statistics for the\ngroups within the repeater.  The number of entries\nis the same as that in the rptrGroupTable.")
rptrMonitorGroupEntry = MibTableRow((1, 3, 6, 1, 2, 1, 22, 2, 2, 1, 1)).setIndexNames((0, "SNMP-REPEATER-MIB", "rptrMonitorGroupIndex"))
if mibBuilder.loadTexts: rptrMonitorGroupEntry.setDescription("********* THIS OBJECT IS DEPRECATED **********\n\nAn entry in the table, containing total\nperformance and error statistics for a single\ngroup.  Regular retrieval of the information in\nthis table provides a means of tracking the\nperformance and health of the networked devices\nattached to this group's ports.\n\nThe counters in this table are redundant in the\nsense that they are the summations of information\nalready available through other objects.  However,\nthese sums provide a considerable optimization of\nnetwork management traffic over the otherwise\nnecessary retrieval of the individual counters\nincluded in each sum.\n\nNote:  Group-level counters are\ndeprecated in this MIB.  It is recommended\nthat management applications instead use\nthe repeater-level counters contained in\nthe rptrMonTable.")
rptrMonitorGroupIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorGroupIndex.setDescription("********* THIS OBJECT IS DEPRECATED **********\n\nThis object identifies the group within the\nrepeater for which this entry contains\ninformation.")
rptrMonitorGroupTotalFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 2, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorGroupTotalFrames.setDescription("********* THIS OBJECT IS DEPRECATED **********\n\nThe total number of frames of valid frame length\nthat have been received on the ports in this group\nand for which the FCSError and CollisionEvent\nsignals were not asserted.  This counter is the\nsummation of the values of the\nrptrMonitorPortReadableFrames counters for all of\nthe ports in the group.\n\nThis statistic provides one of the parameters\nnecessary for obtaining the packet error rate.\nThe approximate minimum time for rollover of this\ncounter is 80 hours in a 10Mb/s repeater.")
rptrMonitorGroupTotalOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 2, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorGroupTotalOctets.setDescription("********* THIS OBJECT IS DEPRECATED **********\n\nThe total number of octets contained in the valid\nframes that have been received on the ports in\nthis group.  This counter is the summation of the\nvalues of the rptrMonitorPortReadableOctets\ncounters for all of the ports in the group.\n\nThis statistic provides an indicator of the total\ndata transferred.  The approximate minimum time\nfor rollover of this counter is 58 minutes in a\n10Mb/s repeater.")
rptrMonitorGroupTotalErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorGroupTotalErrors.setDescription("********* THIS OBJECT IS DEPRECATED **********\n\nThe total number of errors which have occurred on\nall of the ports in this group.  This counter is\nthe summation of the values of the\nrptrMonitorPortTotalErrors counters for all of the\nports in the group.")
rptrMonitorPortInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 2, 3))
rptrMonitorPortTable = MibTable((1, 3, 6, 1, 2, 1, 22, 2, 3, 1))
if mibBuilder.loadTexts: rptrMonitorPortTable.setDescription("Table of performance and error statistics for the\nports.  The number of entries is the same as that\nin the rptrPortTable.\n\nThe columnar object rptrMonitorPortLastChange\nis used to indicate possible discontinuities\nof counter type columnar objects in the table.")
rptrMonitorPortEntry = MibTableRow((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1)).setIndexNames((0, "SNMP-REPEATER-MIB", "rptrMonitorPortGroupIndex"), (0, "SNMP-REPEATER-MIB", "rptrMonitorPortIndex"))
if mibBuilder.loadTexts: rptrMonitorPortEntry.setDescription("An entry in the table, containing performance and\nerror statistics for a single port.")
rptrMonitorPortGroupIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortGroupIndex.setDescription("This object identifies the group containing the\nport for which this entry contains information.")
rptrMonitorPortIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortIndex.setDescription("This object identifies the port within the group\nfor which this entry contains information.")
rptrMonitorPortReadableFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortReadableFrames.setDescription("This object is the number of frames of valid\nframe length that have been received on this port.\nThis counter is incremented by one for each frame\nreceived on this port whose OctetCount is greater\nthan or equal to minFrameSize and less than or\nequal to maxFrameSize (Ref: IEEE 802.3 Std,\n4.4.2.1) and for which the FCSError and\nCollisionEvent signals are not asserted.\n\nA discontinuity may occur in the value\nwhen the value of object\nrptrMonitorPortLastChange changes.\n\nThis statistic provides one of the parameters\nnecessary for obtaining the packet error rate.\nThe approximate minimum time for rollover of this\ncounter is 80 hours at 10Mb/s.")
rptrMonitorPortReadableOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortReadableOctets.setDescription("This object is the number of octets contained in\nvalid frames that have been received on this port.\nThis counter is incremented by OctetCount for each\nframe received on this port which has been\ndetermined to be a readable frame (i.e., including\nFCS octets but excluding framing bits and dribble\nbits).\n\nA discontinuity may occur in the value\nwhen the value of object\nrptrMonitorPortLastChange changes.\n\nThis statistic provides an indicator of the total\ndata transferred.  The approximate minimum time\nfor rollover of this counter in a 10Mb/s repeater\nis 58 minutes.\n\nFor ports receiving traffic at a maximum rate in\na 100Mb/s repeater, this counter can roll over\nin less than 6 minutes.  Since that amount of time\ncould be less than a management station's poll cycle\ntime, in order to avoid a loss of information a\nmanagement station is advised to also poll the\nrptrMonitorPortUpper32Octets object, or to use the\n64-bit counter defined by\nrptrMonitorPortHCReadableOctets instead of the\ntwo 32-bit counters.")
rptrMonitorPortFCSErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortFCSErrors.setDescription("This counter is incremented by one for each frame\nreceived on this port with the FCSError signal\nasserted and the FramingError and CollisionEvent\nsignals deasserted and whose OctetCount is greater\nthan or equal to minFrameSize and less than or\nequal to maxFrameSize (Ref: 4.4.2.1, IEEE 802.3\nStd).\n\nA discontinuity may occur in the value\nwhen the value of object\nrptrMonitorPortLastChange changes.\n\nThe approximate minimum time for rollover of this\ncounter is 80 hours at 10Mb/s.")
rptrMonitorPortAlignmentErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortAlignmentErrors.setDescription("This counter is incremented by one for each frame\nreceived on this port with the FCSError and\nFramingError signals asserted and CollisionEvent\nsignal deasserted and whose OctetCount is greater\nthan or equal to minFrameSize and less than or\nequal to maxFrameSize (Ref: IEEE 802.3 Std,\n4.4.2.1).  If rptrMonitorPortAlignmentErrors is\nincremented then the rptrMonitorPortFCSErrors\nCounter shall not be incremented for the same\nframe.\n\nA discontinuity may occur in the value\nwhen the value of object\nrptrMonitorPortLastChange changes.\n\nThe approximate minimum time for rollover of this\ncounter is 80 hours at 10Mb/s.")
rptrMonitorPortFrameTooLongs = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortFrameTooLongs.setDescription("This counter is incremented by one for each frame\nreceived on this port whose OctetCount is greater\nthan maxFrameSize (Ref: 4.4.2.1, IEEE 802.3 Std).\nIf rptrMonitorPortFrameTooLongs is incremented\nthen neither the rptrMonitorPortAlignmentErrors\nnor the rptrMonitorPortFCSErrors counter shall be\nincremented for the frame.\n\nA discontinuity may occur in the value\nwhen the value of object\nrptrMonitorPortLastChange changes.\n\nThe approximate minimum time for rollover of this\ncounter is 61 days in a 10Mb/s repeater.")
rptrMonitorPortShortEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortShortEvents.setDescription("This counter is incremented by one for each\nCarrierEvent on this port with ActivityDuration\nless than ShortEventMaxTime.  ShortEventMaxTime is\ngreater than 74 bit times and less than 82 bit\ntimes.  ShortEventMaxTime has tolerances included\nto provide for circuit losses between a\nconformance test point at the AUI and the\nmeasurement point within the state machine.\n\nNotes:\n\nShortEvents may indicate externally\ngenerated noise hits which will cause the repeater\nto transmit Runts to its other ports, or propagate\na collision (which may be late) back to the\ntransmitting DTE and damaged frames to the rest of\nthe network.\n\nImplementors may wish to consider selecting the\nShortEventMaxTime towards the lower end of the\nallowed tolerance range to accommodate bit losses\nsuffered through physical channel devices not\nbudgeted for within this standard.\n\nThe significance of this attribute is different\nin 10 and 100 Mb/s collision domains.  Clause 9\nrepeaters perform fragment extension of short\nevents which would be counted as runts on the\ninterconnect ports of other repeaters.  Clause\n27 repeaters do not perform fragment extension.\n\nA discontinuity may occur in the value\nwhen the value of object\nrptrMonitorPortLastChange changes.\n\nThe approximate minimum time for rollover of this\ncounter is 16 hours in a 10Mb/s repeater.")
rptrMonitorPortRunts = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortRunts.setDescription("This counter is incremented by one for each\nCarrierEvent on this port that meets one of the\nfollowing two conditions.  Only one test need be\nmade.  a) The ActivityDuration is greater than\nShortEventMaxTime and less than ValidPacketMinTime\nand the CollisionEvent signal is deasserted.  b)\nThe OctetCount is less than 64, the\nActivityDuration is greater than ShortEventMaxTime\nand the CollisionEvent signal is deasserted.\nValidPacketMinTime is greater than or equal to 552\nbit times and less than 565 bit times.\n\nAn event whose length is greater than 74 bit times\nbut less than 82 bit times shall increment either\nthe shortEvents counter or the runts counter but\nnot both.  A CarrierEvent greater than or equal to\n552 bit times but less than 565 bit times may or\nmay not be counted as a runt.\n\nValidPacketMinTime has tolerances included to\nprovide for circuit losses between a conformance\ntest point at the AUI and the measurement point\nwithin the state machine.\n\nRunts usually indicate collision fragments, a\nnormal network event.  In certain situations\nassociated with large diameter networks a\npercentage of collision fragments may exceed\nValidPacketMinTime.\nA discontinuity may occur in the value\nwhen the value of object\nrptrMonitorPortLastChange changes.\n\nThe approximate minimum time for rollover of this\ncounter is 16 hours in a 10Mb/s repeater.")
rptrMonitorPortCollisions = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortCollisions.setDescription("For a clause 9 repeater, this counter is\nincremented by one for any CarrierEvent signal\non any port for which the CollisionEvent signal\non this port is asserted.  For a clause 27\nrepeater port the counter increments on entering\nthe Collision Count Increment state of the\npartition state diagram (fig 27-8 of\n[IEEE 802.3 Std]).\n\nA discontinuity may occur in the value\nwhen the value of object\nrptrMonitorPortLastChange changes.\n\nThe approximate minimum time for rollover of this\ncounter is 16 hours in a 10Mb/s repeater.")
rptrMonitorPortLateEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortLateEvents.setDescription("For a clause 9 repeater port, this counter is\nincremented by one for each CarrierEvent\non this port in which the CollIn(X)\nvariable transitions to the value SQE (Ref:\n9.6.6.2, IEEE 802.3 Std) while the\nActivityDuration is greater than the\nLateEventThreshold.  For a clause 27 repeater\nport, this counter is incremented by one on\nentering the Collision Count Increment state\nof the  partition state diagram (fig 27-8)\nwhile the  ActivityDuration is greater than\nthe LateEvent- Threshold.  Such a CarrierEvent\nis counted twice, as both a collision and as a\nlateEvent.\n\nThe LateEventThreshold is greater than 480 bit\ntimes and less than 565 bit times.\nLateEventThreshold has tolerances included to\npermit an implementation to build a single\nthreshold to serve as both the LateEventThreshold\nand ValidPacketMinTime threshold.\n\nA discontinuity may occur in the value\nwhen the value of object\nrptrMonitorPortLastChange changes.\n\nThe approximate minimum time for rollover of this\ncounter is 81 hours in a 10Mb/s repeater.")
rptrMonitorPortVeryLongEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortVeryLongEvents.setDescription("For a clause 9 repeater port, this counter\nis incremented by one for each CarrierEvent\nwhose ActivityDuration is greater than the\nMAU Jabber Lockup Protection timer TW3\n(Ref: 9.6.1 & 9.6.5, IEEE 802.3 Std).\n\nFor a clause 27 repeater port, this counter\nis incremented by one on entry to the\nRx Jabber state of the receiver timer state\ndiagram (fig 27-7).  Other counters may\nbe incremented as appropriate.\n\nA discontinuity may occur in the value\nwhen the value of object\nrptrMonitorPortLastChange changes.")
rptrMonitorPortDataRateMismatches = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortDataRateMismatches.setDescription("This counter is incremented by one for each\nframe received by this port that meets all\nof the conditions required by only one of the\nfollowing two measurement methods:\n\nMeasurement method A:  1) The CollisionEvent\nsignal is not asserted (10Mb/s operation) or\nthe Collision Count Increment state of the\npartition state diagram (fig 27-8 of\n[IEEE 802.3 Std]) has not been entered\n(100Mb/s operation).  2) The ActivityDuration\nis greater than ValidPacketMinTime.  3) The\nfrequency (data rate) is detectably mismatched\nfrom the local transmit frequency.\n\nMeasurement method B:  1) The CollisionEvent\nsignal is not asserted (10Mb/s operation)\nor the Collision Count Increment state of the\npartition state diagram (fig 27-8 of\n[IEEE 802.3 Std]) has not been entered\n(100Mb/s operation).  2) The OctetCount is\ngreater than 63.  3) The frequency (data\nrate) is detectably mismatched from the local\ntransmit frequency.  The exact degree of\nmismatch is vendor specific and is to be\ndefined by the vendor for conformance testing.\n\nWhen this event occurs, other counters whose\nincrement conditions were satisfied may or may not\nalso be incremented, at the implementor's\ndiscretion.  Whether or not the repeater was able\nto maintain data integrity is beyond the scope of\nthis standard.\n\nA discontinuity may occur in the value\nwhen the value of object\nrptrMonitorPortLastChange changes.")
rptrMonitorPortAutoPartitions = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortAutoPartitions.setDescription("This counter is incremented by one for\neach time the repeater has automatically\npartitioned this port.\n\nThe conditions that cause a clause 9\nrepeater port to partition are specified in\nthe partition state diagram in clause 9 of\n[IEEE 802.3 Std].  They are not differentiated\nhere.  A clause 27 repeater port partitions\non entry to the Partition Wait state of the\npartition state diagram (fig 27-8 in\n[IEEE 802.3 Std]).\n\nA discontinuity may occur in the value\nwhen the value of object\nrptrMonitorPortLastChange changes.")
rptrMonitorPortTotalErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortTotalErrors.setDescription("The total number of errors which have occurred on\nthis port.  This counter is the summation of the\nvalues of other error counters (for the same\nport), namely:\n\n    rptrMonitorPortFCSErrors,\n    rptrMonitorPortAlignmentErrors,\n    rptrMonitorPortFrameTooLongs,\n    rptrMonitorPortShortEvents,\n    rptrMonitorPortLateEvents,\n    rptrMonitorPortVeryLongEvents,\n    rptrMonitorPortDataRateMismatches, and\n    rptrMonitorPortSymbolErrors.\n\nThis counter is redundant in the sense that it is\nthe summation of information already available\nthrough other objects.  However, it is included\nspecifically because the regular retrieval of this\nobject as a means of tracking the health of a port\nprovides a considerable optimization of network\nmanagement traffic over the otherwise necessary\nretrieval of the summed counters.\n\nNote that rptrMonitorPortRunts is not included\nin this total; this is because runts usually\nindicate collision fragments, a normal network\nevent.\n\nA discontinuity may occur in the value\nwhen the value of object\nrptrMonitorPortLastChange changes.")
rptrMonitorPortLastChange = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 16), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortLastChange.setDescription("The value of sysUpTime when the last of\nthe following occurred:\n  1) the agent cold- or warm-started;\n  2) the row for the port was created\n     (such as when a device or module was added\n      to the system); or\n  3) any condition that would cause one of\n     the counters for the row to experience\n     a discontinuity.")
rptrMonitor100PortTable = MibTable((1, 3, 6, 1, 2, 1, 22, 2, 3, 2))
if mibBuilder.loadTexts: rptrMonitor100PortTable.setDescription("Table of additional performance and error\nstatistics for 100Mb/s ports, above and\nbeyond those parameters that apply to both\n10 and 100Mbps ports.  Entries exist only for\nports attached to 100Mbps repeaters.\n\nThe columnar object rptrMonitorPortLastChange\nis used to indicate possible discontinuities\nof counter type columnar objects in this table.")
rptrMonitor100PortEntry = MibTableRow((1, 3, 6, 1, 2, 1, 22, 2, 3, 2, 1)).setIndexNames((0, "SNMP-REPEATER-MIB", "rptrMonitorPortGroupIndex"), (0, "SNMP-REPEATER-MIB", "rptrMonitorPortIndex"))
if mibBuilder.loadTexts: rptrMonitor100PortEntry.setDescription("An entry in the table, containing performance\nand error statistics for a single 100Mb/s port.")
rptrMonitorPortIsolates = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 2, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortIsolates.setDescription("This counter is incremented by one each time that\nthe repeater port automatically isolates as a\nconsequence of false carrier events.  The conditions\nwhich cause a port to automatically isolate are\ndefined by the transition from the False Carrier\nstate to the Link Unstable state of the carrier\nintegrity state diagram (figure 27-9)\n[IEEE 802.3 Standard].\n\nNote:  Isolates do not affect the value of\nthe PortOperStatus object.\n\nA discontinuity may occur in the value\nwhen the value of object\nrptrMonitorPortLastChange changes.")
rptrMonitorPortSymbolErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortSymbolErrors.setDescription("This counter is incremented by one each time when\nvalid length packet was received at the port and\nthere was at least one occurrence of an invalid\ndata symbol. This can increment only once per valid\ncarrier event. A collision presence at any port of\nthe repeater containing port N, will not cause this\nattribute to increment.\n\nA discontinuity may occur in the value\nwhen the value of object\nrptrMonitorPortLastChange changes.\n\nThe approximate minimum time for rollover of this\ncounter is 7.4 hours at 100Mb/s.")
rptrMonitorPortUpper32Octets = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortUpper32Octets.setDescription("This object is the number of octets contained in\nvalid frames that have been received on this port,\nmodulo 2**32.  That is, it contains the upper 32\nbits of a 64-bit octets counter, of which the\nlower 32 bits are contained in the\nrptrMonitorPortReadableOctets object.\n\nThis two-counter mechanism is provided for those\nnetwork management protocols that do not support\n64-bit counters (e.g. SNMP V1) and are used to\nmanage a repeater type of 100Mb/s.\n\nConformance clauses for this MIB are defined such\nthat implementation of this object is not required\nin a system which does not support 100Mb/s.\nHowever, systems with mixed 10 and 100Mb/s ports\nmay implement this object across all ports,\nincluding 10Mb/s.  If this object is implemented,\nit must be according to the definition in the first\nparagraph of this description; that is, the value\nof this object MUST be a valid count.\n\nA discontinuity may occur in the value\nwhen the value of object\nrptrMonitorPortLastChange changes.")
rptrMonitorPortHCReadableOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 2, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortHCReadableOctets.setDescription("This object is the number of octets contained in\nvalid frames that have been received on this port.\nThis counter is incremented by OctetCount for each\nframe received on this port which has been\ndetermined to be a readable frame (i.e., including\nFCS octets but excluding framing bits and dribble\nbits).\n\nThis statistic provides an indicator of the total\ndata transferred.\n\nThis counter is a 64-bit version of rptrMonitor-\nPortReadableOctets. It should be used by network\nmanagement protocols which suppport 64-bit counters\n(e.g. SNMPv2).\n\nConformance clauses for this MIB are defined such\nthat implementation of this object is not required\nin a system which does not support 100Mb/s.\nHowever, systems with mixed 10 and 100Mb/s ports\nmay implement this object across all ports,\nincluding 10Mb/s.  If this object is implemented,\nit must be according to the definition in the first\nparagraph of this description; that is, the value\nof this object MUST be a valid count.\n\nA discontinuity may occur in the value\nwhen the value of object\nrptrMonitorPortLastChange changes.")
rptrMonitorAllRptrInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 2, 4))
rptrMonTable = MibTable((1, 3, 6, 1, 2, 1, 22, 2, 4, 1))
if mibBuilder.loadTexts: rptrMonTable.setDescription("A table of information about each\nnon-trivial repeater.  The number of entries\nin this table is the same as the number of\nentries in the rptrInfoTable.\n\nThe columnar object rptrInfoLastChange is\nused to indicate possible discontinuities of\ncounter type columnar objects in this table.")
rptrMonEntry = MibTableRow((1, 3, 6, 1, 2, 1, 22, 2, 4, 1, 1)).setIndexNames((0, "SNMP-REPEATER-MIB", "rptrInfoId"))
if mibBuilder.loadTexts: rptrMonEntry.setDescription("An entry in the table, containing information\nabout a single non-trivial repeater.")
rptrMonTxCollisions = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 4, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonTxCollisions.setDescription("For a clause 9 (10Mb/s) repeater, this counter\nis incremented every time the repeater state\nmachine enters the TRANSMIT COLLISION state\nfrom any state other than ONE PORT LEFT\n(Ref: Fig 9-2 [IEEE 802.3 Std]).\n\nFor a clause 27 repeater, this counter is\nincremented every time the repeater core state\ndiagram enters the Jam state as a result of\nActivity(ALL) > 1 (fig 27-2 [IEEE 802.3 Std]).\n\nThe approximate minimum time for rollover of this\ncounter is 16 hours in a 10Mb/s repeater and 1.6\nhours in a 100Mb/s repeater.")
rptrMonTotalFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 4, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonTotalFrames.setDescription("The number of frames of valid frame length\nthat have been received on the ports in this repeater\nand for which the FCSError and CollisionEvent\nsignals were not asserted.  If an implementation\ncan not obtain a count of frames as seen by\nthe repeater itself, this counter may be\nimplemented as the summation of the values of the\nrptrMonitorPortReadableFrames counters for all of\nthe ports in the repeater.\n\nThis statistic provides one of the parameters\nnecessary for obtaining the packet error rate.\nThe approximate minimum time for rollover of this\ncounter is 80 hours in a 10Mb/s repeater.")
rptrMonTotalErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 4, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonTotalErrors.setDescription("The total number of errors which have occurred on\nall of the ports in this repeater.  The errors\nincluded in this count are the same as those listed\nfor the rptrMonitorPortTotalErrors counter.  If an\nimplementation can not obtain a count of these\nerrors as seen by the repeater itself, this counter\nmay be implemented as the summation of the values of\nthe rptrMonitorPortTotalErrors counters for all of\nthe ports in the repeater.")
rptrMonTotalOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 4, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonTotalOctets.setDescription("The total number of octets contained in the valid\nframes that have been received on the ports in\nthis group.  If an implementation can not obtain\na count of octets as seen by the repeater itself,\nthis counter may be the summation of the\nvalues of the rptrMonitorPortReadableOctets\ncounters for all of the ports in the group.\n\nThis statistic provides an indicator of the total\ndata transferred.  The approximate minimum time\nfor rollover of this counter in a 10Mb/s repeater\nis 58 minutes divided by the number of ports in\nthe repeater.\n\nFor 100Mb/s repeaters processing traffic at a\nmaximum rate, this counter can roll over in less\nthan 6 minutes divided by the number of ports in\nthe repeater.  Since that amount of time could\nbe less than a management station's poll cycle\ntime, in order to avoid a loss of information a\nmanagement station is advised to also poll the\nrptrMonUpper32TotalOctets object, or to use the\n64-bit counter defined by rptrMonHCTotalOctets\ninstead of the two 32-bit counters.")
rptrMon100Table = MibTable((1, 3, 6, 1, 2, 1, 22, 2, 4, 2))
if mibBuilder.loadTexts: rptrMon100Table.setDescription("A table of additional information about each\n100Mb/s repeater, augmenting the entries in\nthe rptrMonTable.  Entries exist in this table\nonly for 100Mb/s repeaters.\n\nThe columnar object rptrInfoLastChange is\nused to indicate possible discontinuities of\ncounter type columnar objects in this table.")
rptrMon100Entry = MibTableRow((1, 3, 6, 1, 2, 1, 22, 2, 4, 2, 1)).setIndexNames((0, "SNMP-REPEATER-MIB", "rptrInfoId"))
if mibBuilder.loadTexts: rptrMon100Entry.setDescription("An entry in the table, containing information\nabout a single 100Mbps repeater.")
rptrMonUpper32TotalOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 4, 2, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonUpper32TotalOctets.setDescription("The total number of octets contained in the valid\nframes that have been received on the ports in\nthis repeater, modulo 2**32.  That is, it contains\nthe upper 32 bits of a 64-bit counter, of which\nthe lower 32 bits are contained in the\nrptrMonTotalOctets object.  If an implementation\ncan not obtain a count of octets as seen\nby the repeater itself, the 64-bit value\nmay be the summation of the values of the\nrptrMonitorPortReadableOctets counters combined\nwith the corresponding rptrMonitorPortUpper32Octets\ncounters for all of the ports in the repeater.\n\nThis statistic provides an indicator of the total\ndata transferred within the repeater.\n\nThis two-counter mechanism is provided for those\nnetwork management protocols that do not support\n64-bit counters (e.g. SNMP V1) and are used to\nmanage a repeater type of 100Mb/s.\n\nConformance clauses for this MIB are defined such\nthat implementation of this object is not required\nin a system which does not support 100Mb/s.\nHowever, systems with mixed 10 and 100Mb/s ports\nmay implement this object across all ports,\nincluding 10Mb/s.  If this object is implemented,\nit must be according to the definition in the first\nparagraph of this description; that is, the value\nof this object MUST be a valid count.")
rptrMonHCTotalOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 4, 2, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonHCTotalOctets.setDescription("The total number of octets contained in the valid\nframes that have been received on the ports in\nthis group.  If a implementation can not obtain\na count of octets as seen by the repeater itself,\nthis counter may be the summation of the\nvalues of the rptrMonitorPortReadableOctets\ncounters for all of the ports in the group.\n\nThis statistic provides an indicator of the total\ndata transferred.\n\nThis counter is a 64-bit (high-capacity) version\nof rptrMonUpper32TotalOctets and rptrMonTotalOctets.\nIt should be used by network management protocols\nwhich support 64-bit counters (e.g. SNMPv2).\n\nConformance clauses for this MIB are defined such\nthat implementation of this object is not required\nin a system which does not support 100Mb/s.\nHowever, systems with mixed 10 and 100Mb/s ports\nmay implement this object across all ports,\nincluding 10Mb/s.  If this object is implemented,\nit must be according to the definition in the first\nparagraph of this description; that is, the value\nof this object MUST be a valid count.")
rptrAddrTrackPackage = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 3))
rptrAddrTrackRptrInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 3, 1))
rptrAddrSearchTable = MibTable((1, 3, 6, 1, 2, 1, 22, 3, 1, 1))
if mibBuilder.loadTexts: rptrAddrSearchTable.setDescription("This table contains one entry per repeater in the\nsystem.  It defines objects which allow a network\nmanagement application to instruct an agent to watch\nfor a given MAC address and report which port it\nwas seen on.  Only one address search can be in\nprogress on each repeater at any one time.  Before\nstarting an address search, a management application\nshould obtain 'ownership' of the entry in\nrptrAddrSearchTable for the repeater that is to\nperform the search.  This is accomplished with the\nrptrAddrSearchLock and rptrAddrSearchStatus as\nfollows:\n\ntry_again:\n    get(rptrAddrSearchLock, rptrAddrSearchStatus)\n    while (rptrAddrSearchStatus != notInUse)\n    {\n        /* Loop waiting for objects to be available*/\n        short delay\n        get(rptrAddrSearchLock, rptrAddrSearchStatus)\n    }\n\n    /* Try to claim map objects */\n    lock_value = rptrAddrSearchLock\n    if ( set(rptrAddrSearchLock = lock_value,\n             rptrAddrSearchStatus = inUse,\n             rptrAddrSearchOwner = 'my-IP-address)\n          == FAILURE)\n        /* Another manager got the lock */\n        goto try_again\n\n    /* I have the lock */\n    set (rptrAddrSearchAddress = <search target>)\n\n    wait for rptrAddrSearchState to change from none\n\n    if (rptrAddrSearchState == single)\n        get (rptrAddrSearchGroup, rptrAddrSearchPort)\n    /* release the lock, making sure not to overwrite\n       anyone else's lock */\n    set (rptrAddrSearchLock = lock_value+1,\n         rptrAddrSearchStatus = notInUse,\n         rptrAddrSearchOwner = '')\n\nA management station first retrieves the values of\nthe appropriate instances of the rptrAddrSearchLock\nand rptrAddrSearchStatus objects, periodically\nrepeating the retrieval if necessary, until the value\nof rptrAddrSearchStatus is 'notInUse'.  The\nmanagement station then tries to set the same\ninstance of the rptrAddrSearchLock object to the\nvalue it just retrieved, the same instance of the\nrptrAddrSearchStatus object to 'inUse', and the\ncorresponding instance of rptrAddrSearchOwner to a\nvalue indicating itself.  If the set operation\nsucceeds, then the management station has obtained\nownership of the rptrAddrSearchEntry, and the value\nof rptrAddrSearchLock is incremented by the agent (as\nper the semantics of TestAndIncr).  Failure of the\nset operation indicates that some other manager has\nobtained ownership of the rptrAddrSearchEntry.\n\nOnce ownership is obtained, the management station\ncan proceed with the search operation.  Note that the\nagent will reset rptrAddrSearchStatus to 'notInUse'\nif it has been in the 'inUse' state for an abnormally\nlong period of time, to prevent a misbehaving manager\nfrom permanently locking the entry.  It is suggested\nthat this timeout period be between one and five\nminutes.\n\nWhen the management station has completed its search\noperation, it should free the entry by setting\nthe instance of the rptrAddrSearchLock object to the\nprevious value + 1, the instance of the\nrptrAddrSearchStatus to 'notInUse', and the instance\nof rptrAddrSearchOwner to a zero length string.  This\nis done to prevent overwriting another station's\nlock.")
rptrAddrSearchEntry = MibTableRow((1, 3, 6, 1, 2, 1, 22, 3, 1, 1, 1)).setIndexNames((0, "SNMP-REPEATER-MIB", "rptrInfoId"))
if mibBuilder.loadTexts: rptrAddrSearchEntry.setDescription("An entry containing objects for invoking an address\nsearch on a repeater.")
rptrAddrSearchLock = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 3, 1, 1, 1, 1), TestAndIncr()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rptrAddrSearchLock.setDescription("This object is used by a management station as an\nadvisory lock for this rptrAddrSearchEntry.")
rptrAddrSearchStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 3, 1, 1, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("notInUse", 1), ("inUse", 2), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rptrAddrSearchStatus.setDescription("This object is used to indicate that some management\nstation is currently using this rptrAddrSearchEntry.\nCooperating managers should set this object to\n'notInUse' when they are finished using this entry.\nThe agent will automatically set the value of this\nobject to 'notInUse' if it has been set to 'inUse'\nfor an unusually long period of time.")
rptrAddrSearchAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 3, 1, 1, 1, 3), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rptrAddrSearchAddress.setDescription("This object is used to search for a specified MAC\naddress.  When this object is set, an address search\nbegins.  This automatically sets the corresponding\ninstance of the rptrAddrSearchState object  to 'none'\nand the corresponding instances of the\nrptrAddrSearchGroup and rptrAddrSearchPort objects to\n0.\n\nWhen a valid frame is received by this repeater with\na source MAC address which matches the current value\nof rptrAddrSearchAddress, the agent will update the\ncorresponding instances of rptrAddrSearchState,\nrptrAddrSearchGroup and rptrAddrSearchPort to reflect\nthe current status of the search, and the group and\nport on which the frame was seen.")
rptrAddrSearchState = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 3, 1, 1, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(1,3,2,)).subtype(namedValues=NamedValues(("none", 1), ("single", 2), ("multiple", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrAddrSearchState.setDescription("The current state of the MAC address search on this\nrepeater.  This object is initialized to 'none' when\nthe corresponding instance of rptrAddrSearchAddress\nis set.  If the agent detects the address on exactly\none port, it will set this object to 'single', and\nset the corresponding instances of\nrptrAddrSearchGroup and rptrAddrSearchPort to reflect\nthe group and port on which the address was heard.\nIf the agent detects the address on more than one\nport, it will set this object to 'multiple'.")
rptrAddrSearchGroup = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 3, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrAddrSearchGroup.setDescription("The group from which an error-free frame whose\nsource address is equal to the corresponding instance\nof rptrAddrSearchAddress has been received.  The\nvalue of this object is undefined when the\ncorresponding instance of rptrAddrSearchState is\nequal to 'none' or 'multiple'.")
rptrAddrSearchPort = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 3, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrAddrSearchPort.setDescription("The port rom which an error-free frame whose\nsource address is equal to the corresponding instance\nof rptrAddrSearchAddress has been received.  The\nvalue of this object is undefined when the\ncorresponding instance of rptrAddrSearchState is\nequal to 'none' or 'multiple'.")
rptrAddrSearchOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 3, 1, 1, 1, 7), OwnerString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rptrAddrSearchOwner.setDescription("The entity which currently has 'ownership' of this\nrptrAddrSearchEntry.")
rptrAddrTrackGroupInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 3, 2))
rptrAddrTrackPortInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 3, 3))
rptrAddrTrackTable = MibTable((1, 3, 6, 1, 2, 1, 22, 3, 3, 1))
if mibBuilder.loadTexts: rptrAddrTrackTable.setDescription("Table of address mapping information about the\nports.")
rptrAddrTrackEntry = MibTableRow((1, 3, 6, 1, 2, 1, 22, 3, 3, 1, 1)).setIndexNames((0, "SNMP-REPEATER-MIB", "rptrAddrTrackGroupIndex"), (0, "SNMP-REPEATER-MIB", "rptrAddrTrackPortIndex"))
if mibBuilder.loadTexts: rptrAddrTrackEntry.setDescription("An entry in the table, containing address mapping\ninformation about a single port.")
rptrAddrTrackGroupIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 3, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrAddrTrackGroupIndex.setDescription("This object identifies the group containing the\nport for which this entry contains information.")
rptrAddrTrackPortIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 3, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrAddrTrackPortIndex.setDescription("This object identifies the port within the group\nfor which this entry contains information.")
rptrAddrTrackLastSourceAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 3, 3, 1, 1, 3), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrAddrTrackLastSourceAddress.setDescription("********* THIS OBJECT IS DEPRECATED **********\nThis object is the SourceAddress of the last\nreadable frame (i.e., counted by\nrptrMonitorPortReadableFrames) received by this\nport.\n\nThis object has been deprecated because its value\nis undefined when no frames have been observed on\nthis port.  The replacement object is\nrptrAddrTrackNewLastSrcAddress.")
rptrAddrTrackSourceAddrChanges = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 3, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrAddrTrackSourceAddrChanges.setDescription("This counter is incremented by one for each time\nthat the rptrAddrTrackLastSourceAddress attribute\nfor this port has changed.\n\nThis may indicate whether a link is connected to a\nsingle DTE or another multi-user segment.\n\nA discontinuity may occur in the value when the\nvalue of object rptrMonitorPortLastChange changes.\n\nThe approximate minimum time for rollover of this\ncounter is 81 hours in a 10Mb/s repeater.")
rptrAddrTrackNewLastSrcAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 3, 3, 1, 1, 5), OptMacAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrAddrTrackNewLastSrcAddress.setDescription("This object is the SourceAddress of the last\nreadable frame (i.e., counted by\nrptrMonitorPortReadableFrames) received by this\nport.  If no frames have been received by this\nport since the agent began monitoring the port\nactivity, the agent shall return a string of\nlength zero.")
rptrAddrTrackCapacity = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 3, 3, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrAddrTrackCapacity.setDescription("The maximum number of addresses that can be\ndetected on this port. This value indicates\nto the maximum  number of entries in the\nrptrExtAddrTrackTable relative to this port.\n\nIf this object has the value of 1, the agent\nimplements only the LastSourceAddress mechanism\ndescribed by RFC 1368 or RFC 1516.")
rptrExtAddrTrackTable = MibTable((1, 3, 6, 1, 2, 1, 22, 3, 3, 2))
if mibBuilder.loadTexts: rptrExtAddrTrackTable.setDescription("A table to extend the address tracking table (i.e.,\nrptrAddrTrackTable) with a list of source MAC\naddresses that were recently received on each port.\nThe number of ports is the same as the number\nof entries in table rptrPortTable. The number of\nentries in this table depends on the agent/repeater\nimplementation and the number of different\naddresses received on each port.\n\nThe first entry for each port contains\nthe same MAC address that is given by the\nrptrAddrTrackNewLastSrcAddress for that port.\n\nEntries in this table for a particular port are\nretained when that port is switched from one\nrepeater to another.\n\nThe ordering of MAC addresses listed for a\nparticular port is implementation dependent.")
rptrExtAddrTrackEntry = MibTableRow((1, 3, 6, 1, 2, 1, 22, 3, 3, 2, 1)).setIndexNames((0, "SNMP-REPEATER-MIB", "rptrAddrTrackGroupIndex"), (0, "SNMP-REPEATER-MIB", "rptrAddrTrackPortIndex"), (0, "SNMP-REPEATER-MIB", "rptrExtAddrTrackMacIndex"))
if mibBuilder.loadTexts: rptrExtAddrTrackEntry.setDescription("A row in the table of extended address tracking\ninformation for ports. Entries can not be directly\ncreated or deleted via SNMP operations.")
rptrExtAddrTrackMacIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 3, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrExtAddrTrackMacIndex.setDescription("The index of a source MAC address seen on\nthe port.\n\nThe ordering of MAC addresses listed for a\nparticular port is implementation dependent.\n\nThere is no implied relationship between a\nparticular index and a particular MAC\naddress.  The index for a particular MAC\naddress may change without notice.")
rptrExtAddrTrackSourceAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 3, 3, 2, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrExtAddrTrackSourceAddress.setDescription("The source MAC address from a readable frame\n(i.e., counted by rptrMonitorPortReadableFrames)\nrecently received by the port.")
rptrTopNPackage = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 4))
rptrTopNRptrInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 4, 1))
rptrTopNGroupInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 4, 2))
rptrTopNPortInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 4, 3))
rptrTopNPortControlTable = MibTable((1, 3, 6, 1, 2, 1, 22, 4, 3, 1))
if mibBuilder.loadTexts: rptrTopNPortControlTable.setDescription("A table of control records for reports on the top `N'\nports for the rate of a selected counter. The number\nof entries depends on the configuration of the agent.\nThe maximum number of entries is implementation\ndependent.")
rptrTopNPortControlEntry = MibTableRow((1, 3, 6, 1, 2, 1, 22, 4, 3, 1, 1)).setIndexNames((0, "SNMP-REPEATER-MIB", "rptrTopNPortControlIndex"))
if mibBuilder.loadTexts: rptrTopNPortControlEntry.setDescription("A set of parameters that control the creation of a\nreport of the top N ports according to several metrics.")
rptrTopNPortControlIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 4, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrTopNPortControlIndex.setDescription("An index that uniquely identifies an entry in the\nrptrTopNPortControl table.  Each such entry defines\none top N report prepared for a repeater or system.")
rptrTopNPortRepeaterId = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 4, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rptrTopNPortRepeaterId.setDescription("Identifies the repeater for which a top N report will\nbe prepared (see rptrInfoId).  If the value of this\nobject is positive, only ports assigned to this repeater\nwill be used to form the list in which to order the\nTop N table.  If this value is zero, all ports will be\neligible for inclusion on the list.\n\nThe value of this object may not be modified if the\nassociated rptrTopNPortRowStatus object is equal to\nactive(1).\nIf, for a particular row in this table, the repeater\nspecified by the value of this object goes away (is\nremoved from the rptrInfoTable) while the associated\nrptrTopNPortRowStatus object is equal to active(1),\nthe row in this table is preserved by the agent but\nthe value of rptrTopNPortRowStatus is changed to\nnotInService(2), and the agent may time out the row\nif appropriate.  If the specified repeater comes\nback (reappears in the rptrInfoTable) before the row\nhas been timed out, the management station must set\nthe value of the rptrTopNPortRowStatus object back\nto active(1) if desired (the agent doesn't do this\nautomatically).")
rptrTopNPortRateBase = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 4, 3, 1, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(13,11,3,4,12,9,8,2,10,1,7,6,5,14,15,)).subtype(namedValues=NamedValues(("readableFrames", 1), ("veryLongEvents", 10), ("dataRateMismatches", 11), ("autoPartitions", 12), ("totalErrors", 13), ("isolates", 14), ("symbolErrors", 15), ("readableOctets", 2), ("fcsErrors", 3), ("alignmentErrors", 4), ("frameTooLongs", 5), ("shortEvents", 6), ("runts", 7), ("collisions", 8), ("lateEvents", 9), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rptrTopNPortRateBase.setDescription("The monitored variable, which the rptrTopNPortRate\nvariable is based upon.\n\nThe value of this object may not be modified if\nthe associated rptrTopNPortRowStatus object has\na value of active(1).")
rptrTopNPortTimeRemaining = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 4, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rptrTopNPortTimeRemaining.setDescription("The number of seconds left in the report\ncurrently being collected.  When this object\nis modified by the management station, a new\ncollection is started, possibly aborting a\ncurrently running report.  The new value is\nused as the requested duration of this report,\nwhich is loaded into the associated\nrptrTopNPortDuration object.\n\nWhen this object is set to a non-zero value,\nany associated rptrTopNPortEntries shall be\nmade inaccessible by the agent.  While the value\nof this object is non-zero, it decrements by one\nper second until it reaches zero.  During this\ntime, all associated rptrTopNPortEntries shall\nremain inaccessible.  At the time that this object\ndecrements to zero, the report is made accessible\nin the rptrTopNPortTable.  Thus, the rptrTopNPort\ntable needs to be created only at the end of the\ncollection interval.\n\nIf the value of this object is set to zero\nwhile the associated report is running, the\nrunning report is aborted and no associated\nrptrTopNPortEntries are created.")
rptrTopNPortDuration = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 4, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrTopNPortDuration.setDescription("The number of seconds that this report has\ncollected during the last sampling interval,\nor if this report is currently being collected,\nthe number of seconds that this report is being\ncollected during this sampling interval.\n\nWhen the associated rptrTopNPortTimeRemaining\nobject is set, this object shall be set by the\nagent to the same value and shall not be modified\nuntil the next time the rptrTopNPortTimeRemaining\nis set.\n\nThis value shall be zero if no reports have been\nrequested for this rptrTopNPortControlEntry.")
rptrTopNPortRequestedSize = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 4, 3, 1, 1, 6), Integer32().clone(10)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rptrTopNPortRequestedSize.setDescription("The maximum number of repeater ports requested\nfor the Top N Table.\n\nWhen this object is created or modified, the\nagent should set rptrTopNPortGrantedSize as close\nto this object as is possible for the particular\nimplementation and available resources.")
rptrTopNPortGrantedSize = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 4, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrTopNPortGrantedSize.setDescription("The maximum number of repeater ports in the\ntop N table.\n\nWhen the associated rptrTopNPortRequestedSize object is\ncreated or modified, the agent should set this object as\nclosely to the requested value as is possible for the\nparticular implementation and available resources.  The\nagent must not lower this value except as a result of a\nset to the associated rptrTopNPortRequestedSize object.")
rptrTopNPortStartTime = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 4, 3, 1, 1, 8), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrTopNPortStartTime.setDescription("The value of sysUpTime when this top N report was\nlast started.  In other words, this is the time that\nthe associated rptrTopNPortTimeRemaining object was\nmodified to start the requested report.\n\nIf the report has not yet been started, the value\nof this object is zero.")
rptrTopNPortOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 4, 3, 1, 1, 9), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rptrTopNPortOwner.setDescription("The entity that configured this entry and is\nusing the resources assigned to it.")
rptrTopNPortRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 4, 3, 1, 1, 10), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rptrTopNPortRowStatus.setDescription("The status of this row.\n\nIf the value of this object is not equal to\nactive(1), all associated entries in the\nrptrTopNPortTable shall be deleted by the\nagent.")
rptrTopNPortTable = MibTable((1, 3, 6, 1, 2, 1, 22, 4, 3, 2))
if mibBuilder.loadTexts: rptrTopNPortTable.setDescription("A table of reports for the top `N' ports based on\nsetting of associated control table entries. The\nmaximum number of entries depends on the number\nof entries in table rptrTopNPortControlTable and\nthe value of object rptrTopNPortGrantedSize for\neach entry.\n\nFor each entry in the rptrTopNPortControlTable,\nrepeater ports with the highest value of\nrptrTopNPortRate shall be placed in this table\nin decreasing order of that rate until there is\nno more room or until there are no more ports.")
rptrTopNPortEntry = MibTableRow((1, 3, 6, 1, 2, 1, 22, 4, 3, 2, 1)).setIndexNames((0, "SNMP-REPEATER-MIB", "rptrTopNPortControlIndex"), (0, "SNMP-REPEATER-MIB", "rptrTopNPortIndex"))
if mibBuilder.loadTexts: rptrTopNPortEntry.setDescription("A set of statistics for a repeater port that is\npart of a top N report.")
rptrTopNPortIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 4, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrTopNPortIndex.setDescription("An index that uniquely identifies an entry in\nthe rptrTopNPort table among those in the same\nreport.  This index is between 1 and N, where N\nis the number of entries in this report.  Increasing\nvalues of rptrTopNPortIndex shall be assigned to\nentries with decreasing values of rptrTopNPortRate\nuntil index N is assigned to the entry with the\nlowest value of rptrTopNPortRate or there are no\nmore rptrTopNPortEntries.\n\nNo ports are included in a report where their\nvalue of rptrTopNPortRate would be zero.")
rptrTopNPortGroupIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 4, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrTopNPortGroupIndex.setDescription("This object identifes the group containing\nthe port for this entry. (See also object\ntype rptrGroupIndex.)")
rptrTopNPortPortIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 4, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrTopNPortPortIndex.setDescription("The index of the repeater port.\n(See object type rptrPortIndex.)")
rptrTopNPortRate = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 4, 3, 2, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrTopNPortRate.setDescription("The amount of change in the selected variable\nduring this sampling interval for the identified\nport.  The selected variable is that port's\ninstance of the object selected by\nrptrTopNPortRateBase.")
snmpRptrMod = ModuleIdentity((1, 3, 6, 1, 2, 1, 22, 5)).setRevisions(("1996-09-14 00:00","1993-09-01 00:00","1992-10-01 00:00",))
if mibBuilder.loadTexts: snmpRptrMod.setOrganization("IETF HUB MIB Working Group")
if mibBuilder.loadTexts: snmpRptrMod.setContactInfo("WG E-mail: hubmib@hprnd.rose.hp.com\n\nChair: Dan Romascanu\nPostal: Madge Networks (Israel) Ltd.\n       Atidim Technology Park, Bldg. 3\n       Tel Aviv 61131, Israel\n  Tel: 972-3-6458414, 6458458\n  Fax: 972-3-6487146\nE-mail: dromasca@madge.com\n\nEditor: Kathryn de Graaf\nPostal: 3Com Corporation\n       118 Turnpike Rd.\n       Southborough, MA 01772 USA\n  Tel: (508)229-1627\n  Fax: (508)490-5882\nE-mail: kdegraaf@isd.3com.com")
if mibBuilder.loadTexts: snmpRptrMod.setDescription("Management information for 802.3 repeaters.\n\nThe following references are used throughout\nthis MIB module:\n\n[IEEE 802.3 Std]\n    refers to IEEE 802.3/ISO 8802-3 Information\n    processing systems - Local area networks -\n    Part 3: Carrier sense multiple access with\n    collision detection (CSMA/CD) access method\n    and physical layer specifications (1993).\n\n[IEEE 802.3 Mgt]\n    refers to IEEE 802.3u-1995, '10 Mb/s &\n    100 Mb/s Management, Section 30,'\n    Supplement to ANSI/IEEE 802.3.\n\nThe following terms are used throughout this\nMIB module.  For complete formal definitions,\nthe IEEE 802.3 standards should be consulted\nwherever possible:\n\nSystem - A managed entity compliant with this\nMIB, and incorporating at least one managed\n802.3 repeater.\n\nChassis - An enclosure for one managed repeater,\npart of a managed repeater, or several managed\nrepeaters.  It typically contains an integral\npower supply and a variable number of available\nmodule slots.\n\nRepeater-unit - The portion of the repeater set\nthat is inboard of the physical media interfaces.\nThe physical media interfaces (MAUs, AUIs) may be\nphysically separated from the repeater-unit, or\nthey may be integrated into the same physical\npackage.\n\nTrivial repeater-unit - An isolated port that can\ngather statistics.\n\nGroup - A recommended, but optional, entity\ndefined by the IEEE 802.3 management standard,\nin order to support a modular numbering scheme.\nThe classical example allows an implementor to\nrepresent field-replaceable units as groups of\nports, with the port numbering matching the\nmodular hardware implementation.\n\nSystem interconnect segment - An internal\nsegment allowing interconnection of ports\nbelonging to different physical entities\ninto the same logical manageable repeater.\nExamples of implementation might be\nbackplane busses in modular hubs, or\nchaining cables in stacks of hubs.\nStack - A scalable system that may include\nmanaged repeaters, in which modularity is\nachieved by interconnecting a number of\ndifferent chassis.\n\nModule - A building block in a modular\nchassis.  It typically maps into one 'slot';\nhowever, the range of configurations may be\nvery large, with several modules entering\none slot, or one module covering several\nslots.")
snmpRptrModConf = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 5, 1))
snmpRptrModCompls = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 5, 1, 1))
snmpRptrModObjGrps = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 5, 1, 2))
snmpRptrModNotGrps = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 5, 1, 3))

# Augmentions

# Notifications

rptrHealth = NotificationType((1, 3, 6, 1, 2, 1, 22, 0, 1)).setObjects(*(("SNMP-REPEATER-MIB", "rptrOperStatus"), ) )
if mibBuilder.loadTexts: rptrHealth.setDescription("********* THIS OBJECT IS DEPRECATED **********\n\nIn a system containing a single managed repeater,\nthe rptrHealth notification conveys information\nrelated to the operational status of the repeater.\nIt is sent either when the value of\nrptrOperStatus changes, or upon completion of a\nnon-disruptive test.\n\nThe rptrHealth notification must contain the\nrptrOperStatus object.  The agent may optionally\ninclude the rptrHealthText object in the varBind\nlist.  See the rptrOperStatus and rptrHealthText\nobjects for descriptions of the information that\nis sent.\n\nThe agent must throttle the generation of\nconsecutive rptrHealth traps so that there is at\nleast a five-second gap between traps of this\ntype.  When traps are throttled, they are dropped,\nnot queued for sending at a future time.  (Note\nthat 'generating' a trap means sending to all\nconfigured recipients.)")
rptrGroupChange = NotificationType((1, 3, 6, 1, 2, 1, 22, 0, 2)).setObjects(*(("SNMP-REPEATER-MIB", "rptrGroupIndex"), ) )
if mibBuilder.loadTexts: rptrGroupChange.setDescription("********* THIS OBJECT IS DEPRECATED **********\n\nIn a system containing a single managed repeater,\nthis notification is sent when a change occurs in the\ngroup structure of the repeater.  This occurs only\nwhen a group is logically or physically removed\nfrom or added to a repeater.  The varBind list\ncontains the identifier of the group that was\nremoved or added.\n\nThe agent must throttle the generation of\nconsecutive rptrGroupChange traps for the same\ngroup so that there is at least a five-second gap\nbetween traps of this type.  When traps are\nthrottled, they are dropped, not queued for\nsending at a future time.  (Note that 'generating'\na trap means sending to all configured\nrecipients.)")
rptrResetEvent = NotificationType((1, 3, 6, 1, 2, 1, 22, 0, 3)).setObjects(*(("SNMP-REPEATER-MIB", "rptrOperStatus"), ) )
if mibBuilder.loadTexts: rptrResetEvent.setDescription("********* THIS OBJECT IS DEPRECATED **********\n\nIn a system containing a single managed repeater-unit,\nthe rptrResetEvent notification conveys information\nrelated to the operational status of the repeater.\nThis trap is sent on completion of a repeater\nreset action.  A repeater reset action is defined\nas an a transition to the START state of Fig 9-2\nin section 9 [IEEE 802.3 Std], when triggered by a\nmanagement command (e.g., an SNMP Set on the\nrptrReset object).\n\nThe agent must throttle the generation of\nconsecutive rptrResetEvent traps so that there is\nat least a five-second gap between traps of this\ntype.  When traps are throttled, they are dropped,\nnot queued for sending at a future time.  (Note\nthat 'generating' a trap means sending to all\nconfigured recipients.)\n\nThe rptrResetEvent trap is not sent when the agent\nrestarts and sends an SNMP coldStart or warmStart\ntrap.  However, it is recommended that a repeater\nagent send the rptrOperStatus object as an\noptional object with its coldStart and warmStart\ntrap PDUs.\n\nThe rptrOperStatus object must be included in the\nvarbind list sent with this trap.  The agent may\noptionally include the rptrHealthText object as\nwell.")
rptrInfoHealth = NotificationType((1, 3, 6, 1, 2, 1, 22, 0, 4)).setObjects(*(("SNMP-REPEATER-MIB", "rptrInfoOperStatus"), ) )
if mibBuilder.loadTexts: rptrInfoHealth.setDescription("In a system containing multiple managed repeaters,\nthe rptrInfoHealth notification conveys information\nrelated to the operational status of a repeater.\nIt is sent either when the value of rptrInfoOperStatus\nchanges, or upon completion of a non-disruptive test.\n\nThe agent must throttle the generation of\nconsecutive rptrInfoHealth notifications for\nthe same repeater so that there is at least\na five-second gap between notifications of this type.\nWhen notifications are throttled, they are dropped,\nnot queued for sending at a future time.  (Note\nthat 'generating' a notification means sending\nto all configured recipients.)")
rptrInfoResetEvent = NotificationType((1, 3, 6, 1, 2, 1, 22, 0, 5)).setObjects(*(("SNMP-REPEATER-MIB", "rptrInfoOperStatus"), ) )
if mibBuilder.loadTexts: rptrInfoResetEvent.setDescription("In a system containing multiple managed\nrepeaters, the rptrInfoResetEvent notification\nconveys information related to the operational\nstatus of a repeater. This notification is sent\non completion of a repeater reset action.  A\nrepeater reset action is defined as a transition\nto the START state of Fig 9-2 in section 9 of\n[IEEE 802.3 Std], when triggered by a management\ncommand (e.g., an SNMP Set on the rptrInfoReset\nobject).\n\nThe agent must throttle the generation of\nconsecutive rptrInfoResetEvent notifications for\na single repeater so that there is at least\na five-second gap between notifications of\nthis type.  When notifications are throttled,\nthey are dropped, not queued for sending at\na future time.  (Note that 'generating' a\nnotification means sending to all configured\nrecipients.)\n\nThe rptrInfoResetEvent is not sent when the\nagent restarts and sends an SNMP coldStart or\nwarmStart trap.  However, it is recommended that\na repeater agent send the rptrInfoOperStatus\nobject as an optional object with its coldStart\nand warmStart trap PDUs.")

# Groups

snmpRptrGrpBasic1516 = ObjectGroup((1, 3, 6, 1, 2, 1, 22, 5, 1, 2, 1)).setObjects(*(("SNMP-REPEATER-MIB", "rptrTotalPartitionedPorts"), ("SNMP-REPEATER-MIB", "rptrPortGroupIndex"), ("SNMP-REPEATER-MIB", "rptrGroupDescr"), ("SNMP-REPEATER-MIB", "rptrReset"), ("SNMP-REPEATER-MIB", "rptrPortIndex"), ("SNMP-REPEATER-MIB", "rptrOperStatus"), ("SNMP-REPEATER-MIB", "rptrGroupLastOperStatusChange"), ("SNMP-REPEATER-MIB", "rptrGroupCapacity"), ("SNMP-REPEATER-MIB", "rptrGroupPortCapacity"), ("SNMP-REPEATER-MIB", "rptrPortAutoPartitionState"), ("SNMP-REPEATER-MIB", "rptrGroupObjectID"), ("SNMP-REPEATER-MIB", "rptrHealthText"), ("SNMP-REPEATER-MIB", "rptrPortOperStatus"), ("SNMP-REPEATER-MIB", "rptrNonDisruptTest"), ("SNMP-REPEATER-MIB", "rptrGroupOperStatus"), ("SNMP-REPEATER-MIB", "rptrGroupIndex"), ("SNMP-REPEATER-MIB", "rptrPortAdminStatus"), ) )
if mibBuilder.loadTexts: snmpRptrGrpBasic1516.setDescription("********* THIS GROUP IS DEPRECATED **********\n\nBasic group from RFCs 1368 and 1516.\n\nNOTE: this object group is DEPRECATED and replaced\n      with snmpRptrGrpBasic.")
snmpRptrGrpMonitor1516 = ObjectGroup((1, 3, 6, 1, 2, 1, 22, 5, 1, 2, 2)).setObjects(*(("SNMP-REPEATER-MIB", "rptrMonitorPortFCSErrors"), ("SNMP-REPEATER-MIB", "rptrMonitorGroupTotalFrames"), ("SNMP-REPEATER-MIB", "rptrMonitorPortTotalErrors"), ("SNMP-REPEATER-MIB", "rptrMonitorGroupTotalOctets"), ("SNMP-REPEATER-MIB", "rptrMonitorGroupTotalErrors"), ("SNMP-REPEATER-MIB", "rptrMonitorPortCollisions"), ("SNMP-REPEATER-MIB", "rptrMonitorPortReadableFrames"), ("SNMP-REPEATER-MIB", "rptrMonitorPortIndex"), ("SNMP-REPEATER-MIB", "rptrMonitorPortReadableOctets"), ("SNMP-REPEATER-MIB", "rptrMonitorPortVeryLongEvents"), ("SNMP-REPEATER-MIB", "rptrMonitorTransmitCollisions"), ("SNMP-REPEATER-MIB", "rptrMonitorGroupIndex"), ("SNMP-REPEATER-MIB", "rptrMonitorPortAlignmentErrors"), ("SNMP-REPEATER-MIB", "rptrMonitorPortDataRateMismatches"), ("SNMP-REPEATER-MIB", "rptrMonitorPortAutoPartitions"), ("SNMP-REPEATER-MIB", "rptrMonitorPortFrameTooLongs"), ("SNMP-REPEATER-MIB", "rptrMonitorPortRunts"), ("SNMP-REPEATER-MIB", "rptrMonitorPortLateEvents"), ("SNMP-REPEATER-MIB", "rptrMonitorPortShortEvents"), ("SNMP-REPEATER-MIB", "rptrMonitorPortGroupIndex"), ) )
if mibBuilder.loadTexts: snmpRptrGrpMonitor1516.setDescription("********* THIS GROUP IS DEPRECATED **********\n\nMonitor group from RFCs 1368 and 1516.\n\nNOTE: this object group is DEPRECATED and replaced\n      with snmpRptrGrpMonitor.")
snmpRptrGrpAddrTrack1368 = ObjectGroup((1, 3, 6, 1, 2, 1, 22, 5, 1, 2, 3)).setObjects(*(("SNMP-REPEATER-MIB", "rptrAddrTrackSourceAddrChanges"), ("SNMP-REPEATER-MIB", "rptrAddrTrackLastSourceAddress"), ("SNMP-REPEATER-MIB", "rptrAddrTrackGroupIndex"), ("SNMP-REPEATER-MIB", "rptrAddrTrackPortIndex"), ) )
if mibBuilder.loadTexts: snmpRptrGrpAddrTrack1368.setDescription("Address tracking group from RFC 1368.\n\nNOTE: this object group is OBSOLETE and replaced\n      with snmpRptrGrpAddrTrack1516.")
snmpRptrGrpAddrTrack1516 = ObjectGroup((1, 3, 6, 1, 2, 1, 22, 5, 1, 2, 4)).setObjects(*(("SNMP-REPEATER-MIB", "rptrAddrTrackNewLastSrcAddress"), ("SNMP-REPEATER-MIB", "rptrAddrTrackSourceAddrChanges"), ("SNMP-REPEATER-MIB", "rptrAddrTrackLastSourceAddress"), ("SNMP-REPEATER-MIB", "rptrAddrTrackGroupIndex"), ("SNMP-REPEATER-MIB", "rptrAddrTrackPortIndex"), ) )
if mibBuilder.loadTexts: snmpRptrGrpAddrTrack1516.setDescription("********* THIS GROUP IS DEPRECATED **********\nAddress tracking group from RFC 1516.\n\nNOTE: this object group is DEPRECATED and\n      replaced with snmpRptrGrpAddrTrack.")
snmpRptrGrpBasic = ObjectGroup((1, 3, 6, 1, 2, 1, 22, 5, 1, 2, 5)).setObjects(*(("SNMP-REPEATER-MIB", "rptrPortGroupIndex"), ("SNMP-REPEATER-MIB", "rptrInfoId"), ("SNMP-REPEATER-MIB", "rptrPortOperStatus"), ("SNMP-REPEATER-MIB", "rptrPortIndex"), ("SNMP-REPEATER-MIB", "rptrInfoOperStatus"), ("SNMP-REPEATER-MIB", "rptrGroupPortCapacity"), ("SNMP-REPEATER-MIB", "rptrInfoLastChange"), ("SNMP-REPEATER-MIB", "rptrPortRptrId"), ("SNMP-REPEATER-MIB", "rptrPortAutoPartitionState"), ("SNMP-REPEATER-MIB", "rptrInfoRptrType"), ("SNMP-REPEATER-MIB", "rptrGroupObjectID"), ("SNMP-REPEATER-MIB", "rptrInfoReset"), ("SNMP-REPEATER-MIB", "rptrInfoPartitionedPorts"), ("SNMP-REPEATER-MIB", "rptrGroupOperStatus"), ("SNMP-REPEATER-MIB", "rptrGroupIndex"), ("SNMP-REPEATER-MIB", "rptrPortAdminStatus"), ) )
if mibBuilder.loadTexts: snmpRptrGrpBasic.setDescription("Basic group for a system with one or more\nrepeater-units in multi-segment (post-RFC 1516)\nversion of the MIB module.")
snmpRptrGrpMonitor = ObjectGroup((1, 3, 6, 1, 2, 1, 22, 5, 1, 2, 6)).setObjects(*(("SNMP-REPEATER-MIB", "rptrMonitorPortCollisions"), ("SNMP-REPEATER-MIB", "rptrMonitorPortTotalErrors"), ("SNMP-REPEATER-MIB", "rptrMonitorPortDataRateMismatches"), ("SNMP-REPEATER-MIB", "rptrMonitorPortGroupIndex"), ("SNMP-REPEATER-MIB", "rptrMonitorPortVeryLongEvents"), ("SNMP-REPEATER-MIB", "rptrMonTotalFrames"), ("SNMP-REPEATER-MIB", "rptrMonitorPortIndex"), ("SNMP-REPEATER-MIB", "rptrMonitorPortReadableOctets"), ("SNMP-REPEATER-MIB", "rptrMonTotalErrors"), ("SNMP-REPEATER-MIB", "rptrMonitorPortReadableFrames"), ("SNMP-REPEATER-MIB", "rptrMonTotalOctets"), ("SNMP-REPEATER-MIB", "rptrMonitorPortFCSErrors"), ("SNMP-REPEATER-MIB", "rptrMonitorPortAlignmentErrors"), ("SNMP-REPEATER-MIB", "rptrMonTxCollisions"), ("SNMP-REPEATER-MIB", "rptrMonitorPortAutoPartitions"), ("SNMP-REPEATER-MIB", "rptrMonitorPortFrameTooLongs"), ("SNMP-REPEATER-MIB", "rptrMonitorPortRunts"), ("SNMP-REPEATER-MIB", "rptrMonitorPortShortEvents"), ("SNMP-REPEATER-MIB", "rptrMonitorPortLastChange"), ("SNMP-REPEATER-MIB", "rptrMonitorPortLateEvents"), ) )
if mibBuilder.loadTexts: snmpRptrGrpMonitor.setDescription("Monitor group for a system with one or more\nrepeater-units in multi-segment (post-RFC 1516)\nversion of the MIB module.")
snmpRptrGrpMonitor100 = ObjectGroup((1, 3, 6, 1, 2, 1, 22, 5, 1, 2, 7)).setObjects(*(("SNMP-REPEATER-MIB", "rptrMonitorPortSymbolErrors"), ("SNMP-REPEATER-MIB", "rptrMonitorPortIsolates"), ("SNMP-REPEATER-MIB", "rptrMonUpper32TotalOctets"), ("SNMP-REPEATER-MIB", "rptrMonitorPortUpper32Octets"), ) )
if mibBuilder.loadTexts: snmpRptrGrpMonitor100.setDescription("Monitor group for 100Mb/s ports and repeaters\nin a system with one or more repeater-units in\nmulti-segment (post-RFC 1516) version of the MIB\nmodule.  Systems which support Counter64 should\nalso implement snmpRptrGrpMonitor100w64.")
snmpRptrGrpMonitor100w64 = ObjectGroup((1, 3, 6, 1, 2, 1, 22, 5, 1, 2, 8)).setObjects(*(("SNMP-REPEATER-MIB", "rptrMonHCTotalOctets"), ("SNMP-REPEATER-MIB", "rptrMonitorPortHCReadableOctets"), ) )
if mibBuilder.loadTexts: snmpRptrGrpMonitor100w64.setDescription("Monitor group for 100Mb/s ports and repeaters in a\nsystem with one or more repeater-units and support\nfor Counter64.")
snmpRptrGrpAddrTrack = ObjectGroup((1, 3, 6, 1, 2, 1, 22, 5, 1, 2, 9)).setObjects(*(("SNMP-REPEATER-MIB", "rptrAddrTrackNewLastSrcAddress"), ("SNMP-REPEATER-MIB", "rptrAddrTrackCapacity"), ("SNMP-REPEATER-MIB", "rptrAddrTrackSourceAddrChanges"), ("SNMP-REPEATER-MIB", "rptrAddrTrackGroupIndex"), ("SNMP-REPEATER-MIB", "rptrAddrTrackPortIndex"), ) )
if mibBuilder.loadTexts: snmpRptrGrpAddrTrack.setDescription("Passive address tracking group for post-RFC 1516\nversion of the MIB module.")
snmpRptrGrpExtAddrTrack = ObjectGroup((1, 3, 6, 1, 2, 1, 22, 5, 1, 2, 10)).setObjects(*(("SNMP-REPEATER-MIB", "rptrExtAddrTrackMacIndex"), ("SNMP-REPEATER-MIB", "rptrExtAddrTrackSourceAddress"), ) )
if mibBuilder.loadTexts: snmpRptrGrpExtAddrTrack.setDescription("Extended passive address tracking group for\na system with one or more repeater-units in\npost-RFC 1516 version of the MIB module.")
snmpRptrGrpRptrAddrSearch = ObjectGroup((1, 3, 6, 1, 2, 1, 22, 5, 1, 2, 11)).setObjects(*(("SNMP-REPEATER-MIB", "rptrAddrSearchOwner"), ("SNMP-REPEATER-MIB", "rptrAddrSearchLock"), ("SNMP-REPEATER-MIB", "rptrAddrSearchGroup"), ("SNMP-REPEATER-MIB", "rptrAddrSearchAddress"), ("SNMP-REPEATER-MIB", "rptrAddrSearchState"), ("SNMP-REPEATER-MIB", "rptrAddrSearchStatus"), ("SNMP-REPEATER-MIB", "rptrAddrSearchPort"), ) )
if mibBuilder.loadTexts: snmpRptrGrpRptrAddrSearch.setDescription("Active MAC address search group and topology\nmapping support for repeaters.")
snmpRptrGrpTopNPort = ObjectGroup((1, 3, 6, 1, 2, 1, 22, 5, 1, 2, 12)).setObjects(*(("SNMP-REPEATER-MIB", "rptrTopNPortRequestedSize"), ("SNMP-REPEATER-MIB", "rptrTopNPortStartTime"), ("SNMP-REPEATER-MIB", "rptrTopNPortRate"), ("SNMP-REPEATER-MIB", "rptrTopNPortGroupIndex"), ("SNMP-REPEATER-MIB", "rptrTopNPortOwner"), ("SNMP-REPEATER-MIB", "rptrTopNPortGrantedSize"), ("SNMP-REPEATER-MIB", "rptrTopNPortRateBase"), ("SNMP-REPEATER-MIB", "rptrTopNPortTimeRemaining"), ("SNMP-REPEATER-MIB", "rptrTopNPortRepeaterId"), ("SNMP-REPEATER-MIB", "rptrTopNPortPortIndex"), ("SNMP-REPEATER-MIB", "rptrTopNPortRowStatus"), ("SNMP-REPEATER-MIB", "rptrTopNPortControlIndex"), ("SNMP-REPEATER-MIB", "rptrTopNPortDuration"), ("SNMP-REPEATER-MIB", "rptrTopNPortIndex"), ) )
if mibBuilder.loadTexts: snmpRptrGrpTopNPort.setDescription("Top `N' group for repeater ports.")

# Compliances

snmpRptrModComplRFC1368 = ModuleCompliance((1, 3, 6, 1, 2, 1, 22, 5, 1, 1, 1)).setObjects(*(("SNMP-REPEATER-MIB", "snmpRptrGrpMonitor1516"), ("SNMP-REPEATER-MIB", "snmpRptrGrpBasic1516"), ("SNMP-REPEATER-MIB", "snmpRptrGrpAddrTrack1368"), ) )
if mibBuilder.loadTexts: snmpRptrModComplRFC1368.setDescription("Compliance for RFC 1368.\n\nNOTE: this module compliance is OBSOLETE and\n      replaced by snmpRptrModComplRFC1516.")
snmpRptrModComplRFC1516 = ModuleCompliance((1, 3, 6, 1, 2, 1, 22, 5, 1, 1, 2)).setObjects(*(("SNMP-REPEATER-MIB", "snmpRptrGrpAddrTrack1516"), ("SNMP-REPEATER-MIB", "snmpRptrGrpMonitor1516"), ("SNMP-REPEATER-MIB", "snmpRptrGrpBasic1516"), ) )
if mibBuilder.loadTexts: snmpRptrModComplRFC1516.setDescription("********* THIS COMPLIANCE IS DEPRECATED **********\n\nCompliance for RFC 1516 and for backwards\ncompatibility with single-repeater,\n10Mb/s-only implementations.")
snmpRptrModCompl = ModuleCompliance((1, 3, 6, 1, 2, 1, 22, 5, 1, 1, 3)).setObjects(*(("SNMP-REPEATER-MIB", "snmpRptrGrpRptrAddrSearch"), ("SNMP-REPEATER-MIB", "snmpRptrGrpTopNPort"), ("SNMP-REPEATER-MIB", "snmpRptrGrpMonitor100"), ("SNMP-REPEATER-MIB", "snmpRptrGrpBasic"), ("SNMP-REPEATER-MIB", "snmpRptrGrpMonitor100w64"), ("SNMP-REPEATER-MIB", "snmpRptrGrpAddrTrack"), ("SNMP-REPEATER-MIB", "snmpRptrGrpExtAddrTrack"), ("SNMP-REPEATER-MIB", "snmpRptrGrpMonitor"), ) )
if mibBuilder.loadTexts: snmpRptrModCompl.setDescription("Compliance for the multi-segment version of the\nMIB module for a system with one or more\nrepeater-units.")

# Exports

# Module identity
mibBuilder.exportSymbols("SNMP-REPEATER-MIB", PYSNMP_MODULE_ID=snmpRptrMod)

# Types
mibBuilder.exportSymbols("SNMP-REPEATER-MIB", OptMacAddr=OptMacAddr)

# Objects
mibBuilder.exportSymbols("SNMP-REPEATER-MIB", snmpDot3RptrMgt=snmpDot3RptrMgt, rptrBasicPackage=rptrBasicPackage, rptrRptrInfo=rptrRptrInfo, rptrGroupCapacity=rptrGroupCapacity, rptrOperStatus=rptrOperStatus, rptrHealthText=rptrHealthText, rptrReset=rptrReset, rptrNonDisruptTest=rptrNonDisruptTest, rptrTotalPartitionedPorts=rptrTotalPartitionedPorts, rptrGroupInfo=rptrGroupInfo, rptrGroupTable=rptrGroupTable, rptrGroupEntry=rptrGroupEntry, rptrGroupIndex=rptrGroupIndex, rptrGroupDescr=rptrGroupDescr, rptrGroupObjectID=rptrGroupObjectID, rptrGroupOperStatus=rptrGroupOperStatus, rptrGroupLastOperStatusChange=rptrGroupLastOperStatusChange, rptrGroupPortCapacity=rptrGroupPortCapacity, rptrPortInfo=rptrPortInfo, rptrPortTable=rptrPortTable, rptrPortEntry=rptrPortEntry, rptrPortGroupIndex=rptrPortGroupIndex, rptrPortIndex=rptrPortIndex, rptrPortAdminStatus=rptrPortAdminStatus, rptrPortAutoPartitionState=rptrPortAutoPartitionState, rptrPortOperStatus=rptrPortOperStatus, rptrPortRptrId=rptrPortRptrId, rptrAllRptrInfo=rptrAllRptrInfo, rptrInfoTable=rptrInfoTable, rptrInfoEntry=rptrInfoEntry, rptrInfoId=rptrInfoId, rptrInfoRptrType=rptrInfoRptrType, rptrInfoOperStatus=rptrInfoOperStatus, rptrInfoReset=rptrInfoReset, rptrInfoPartitionedPorts=rptrInfoPartitionedPorts, rptrInfoLastChange=rptrInfoLastChange, rptrMonitorPackage=rptrMonitorPackage, rptrMonitorRptrInfo=rptrMonitorRptrInfo, rptrMonitorTransmitCollisions=rptrMonitorTransmitCollisions, rptrMonitorGroupInfo=rptrMonitorGroupInfo, rptrMonitorGroupTable=rptrMonitorGroupTable, rptrMonitorGroupEntry=rptrMonitorGroupEntry, rptrMonitorGroupIndex=rptrMonitorGroupIndex, rptrMonitorGroupTotalFrames=rptrMonitorGroupTotalFrames, rptrMonitorGroupTotalOctets=rptrMonitorGroupTotalOctets, rptrMonitorGroupTotalErrors=rptrMonitorGroupTotalErrors, rptrMonitorPortInfo=rptrMonitorPortInfo, rptrMonitorPortTable=rptrMonitorPortTable, rptrMonitorPortEntry=rptrMonitorPortEntry, rptrMonitorPortGroupIndex=rptrMonitorPortGroupIndex, rptrMonitorPortIndex=rptrMonitorPortIndex, rptrMonitorPortReadableFrames=rptrMonitorPortReadableFrames, rptrMonitorPortReadableOctets=rptrMonitorPortReadableOctets, rptrMonitorPortFCSErrors=rptrMonitorPortFCSErrors, rptrMonitorPortAlignmentErrors=rptrMonitorPortAlignmentErrors, rptrMonitorPortFrameTooLongs=rptrMonitorPortFrameTooLongs, rptrMonitorPortShortEvents=rptrMonitorPortShortEvents, rptrMonitorPortRunts=rptrMonitorPortRunts, rptrMonitorPortCollisions=rptrMonitorPortCollisions, rptrMonitorPortLateEvents=rptrMonitorPortLateEvents, rptrMonitorPortVeryLongEvents=rptrMonitorPortVeryLongEvents, rptrMonitorPortDataRateMismatches=rptrMonitorPortDataRateMismatches, rptrMonitorPortAutoPartitions=rptrMonitorPortAutoPartitions, rptrMonitorPortTotalErrors=rptrMonitorPortTotalErrors, rptrMonitorPortLastChange=rptrMonitorPortLastChange, rptrMonitor100PortTable=rptrMonitor100PortTable, rptrMonitor100PortEntry=rptrMonitor100PortEntry, rptrMonitorPortIsolates=rptrMonitorPortIsolates, rptrMonitorPortSymbolErrors=rptrMonitorPortSymbolErrors, rptrMonitorPortUpper32Octets=rptrMonitorPortUpper32Octets, rptrMonitorPortHCReadableOctets=rptrMonitorPortHCReadableOctets, rptrMonitorAllRptrInfo=rptrMonitorAllRptrInfo, rptrMonTable=rptrMonTable, rptrMonEntry=rptrMonEntry, rptrMonTxCollisions=rptrMonTxCollisions, rptrMonTotalFrames=rptrMonTotalFrames, rptrMonTotalErrors=rptrMonTotalErrors, rptrMonTotalOctets=rptrMonTotalOctets, rptrMon100Table=rptrMon100Table, rptrMon100Entry=rptrMon100Entry, rptrMonUpper32TotalOctets=rptrMonUpper32TotalOctets, rptrMonHCTotalOctets=rptrMonHCTotalOctets, rptrAddrTrackPackage=rptrAddrTrackPackage, rptrAddrTrackRptrInfo=rptrAddrTrackRptrInfo, rptrAddrSearchTable=rptrAddrSearchTable, rptrAddrSearchEntry=rptrAddrSearchEntry, rptrAddrSearchLock=rptrAddrSearchLock, rptrAddrSearchStatus=rptrAddrSearchStatus, rptrAddrSearchAddress=rptrAddrSearchAddress, rptrAddrSearchState=rptrAddrSearchState, rptrAddrSearchGroup=rptrAddrSearchGroup, rptrAddrSearchPort=rptrAddrSearchPort, rptrAddrSearchOwner=rptrAddrSearchOwner, rptrAddrTrackGroupInfo=rptrAddrTrackGroupInfo, rptrAddrTrackPortInfo=rptrAddrTrackPortInfo, rptrAddrTrackTable=rptrAddrTrackTable, rptrAddrTrackEntry=rptrAddrTrackEntry, rptrAddrTrackGroupIndex=rptrAddrTrackGroupIndex, rptrAddrTrackPortIndex=rptrAddrTrackPortIndex, rptrAddrTrackLastSourceAddress=rptrAddrTrackLastSourceAddress, rptrAddrTrackSourceAddrChanges=rptrAddrTrackSourceAddrChanges, rptrAddrTrackNewLastSrcAddress=rptrAddrTrackNewLastSrcAddress, rptrAddrTrackCapacity=rptrAddrTrackCapacity, rptrExtAddrTrackTable=rptrExtAddrTrackTable, rptrExtAddrTrackEntry=rptrExtAddrTrackEntry, rptrExtAddrTrackMacIndex=rptrExtAddrTrackMacIndex, rptrExtAddrTrackSourceAddress=rptrExtAddrTrackSourceAddress, rptrTopNPackage=rptrTopNPackage, rptrTopNRptrInfo=rptrTopNRptrInfo, rptrTopNGroupInfo=rptrTopNGroupInfo, rptrTopNPortInfo=rptrTopNPortInfo, rptrTopNPortControlTable=rptrTopNPortControlTable, rptrTopNPortControlEntry=rptrTopNPortControlEntry, rptrTopNPortControlIndex=rptrTopNPortControlIndex, rptrTopNPortRepeaterId=rptrTopNPortRepeaterId, rptrTopNPortRateBase=rptrTopNPortRateBase, rptrTopNPortTimeRemaining=rptrTopNPortTimeRemaining, rptrTopNPortDuration=rptrTopNPortDuration, rptrTopNPortRequestedSize=rptrTopNPortRequestedSize, rptrTopNPortGrantedSize=rptrTopNPortGrantedSize, rptrTopNPortStartTime=rptrTopNPortStartTime, rptrTopNPortOwner=rptrTopNPortOwner, rptrTopNPortRowStatus=rptrTopNPortRowStatus, rptrTopNPortTable=rptrTopNPortTable, rptrTopNPortEntry=rptrTopNPortEntry, rptrTopNPortIndex=rptrTopNPortIndex)
mibBuilder.exportSymbols("SNMP-REPEATER-MIB", rptrTopNPortGroupIndex=rptrTopNPortGroupIndex, rptrTopNPortPortIndex=rptrTopNPortPortIndex, rptrTopNPortRate=rptrTopNPortRate, snmpRptrMod=snmpRptrMod, snmpRptrModConf=snmpRptrModConf, snmpRptrModCompls=snmpRptrModCompls, snmpRptrModObjGrps=snmpRptrModObjGrps, snmpRptrModNotGrps=snmpRptrModNotGrps)

# Notifications
mibBuilder.exportSymbols("SNMP-REPEATER-MIB", rptrHealth=rptrHealth, rptrGroupChange=rptrGroupChange, rptrResetEvent=rptrResetEvent, rptrInfoHealth=rptrInfoHealth, rptrInfoResetEvent=rptrInfoResetEvent)

# Groups
mibBuilder.exportSymbols("SNMP-REPEATER-MIB", snmpRptrGrpBasic1516=snmpRptrGrpBasic1516, snmpRptrGrpMonitor1516=snmpRptrGrpMonitor1516, snmpRptrGrpAddrTrack1368=snmpRptrGrpAddrTrack1368, snmpRptrGrpAddrTrack1516=snmpRptrGrpAddrTrack1516, snmpRptrGrpBasic=snmpRptrGrpBasic, snmpRptrGrpMonitor=snmpRptrGrpMonitor, snmpRptrGrpMonitor100=snmpRptrGrpMonitor100, snmpRptrGrpMonitor100w64=snmpRptrGrpMonitor100w64, snmpRptrGrpAddrTrack=snmpRptrGrpAddrTrack, snmpRptrGrpExtAddrTrack=snmpRptrGrpExtAddrTrack, snmpRptrGrpRptrAddrSearch=snmpRptrGrpRptrAddrSearch, snmpRptrGrpTopNPort=snmpRptrGrpTopNPort)

# Compliances
mibBuilder.exportSymbols("SNMP-REPEATER-MIB", snmpRptrModComplRFC1368=snmpRptrModComplRFC1368, snmpRptrModComplRFC1516=snmpRptrModComplRFC1516, snmpRptrModCompl=snmpRptrModCompl)
