# PySNMP SMI module. Autogenerated from smidump -f python RMON2-MIB
# by libsmi2pysnmp-0.1.3 at Mon Apr  2 20:39:34 2012,
# Python version sys.version_info(major=2, minor=7, micro=2, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( ifIndex, ) = mibBuilder.importSymbols("IF-MIB", "ifIndex")
( OwnerString, channelEntry, etherStatsEntry, filter, filterEntry, history, historyControlEntry, hostControlEntry, hosts, matrix, matrixControlEntry, statistics, ) = mibBuilder.importSymbols("RMON-MIB", "OwnerString", "channelEntry", "etherStatsEntry", "filter", "filterEntry", "history", "historyControlEntry", "hostControlEntry", "hosts", "matrix", "matrixControlEntry", "statistics")
( ModuleCompliance, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup")
( Bits, Counter32, Gauge32, Integer32, Integer32, IpAddress, ModuleIdentity, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, TimeTicks, mib_2, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "Gauge32", "Integer32", "Integer32", "IpAddress", "ModuleIdentity", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "TimeTicks", "mib-2")
( DisplayString, RowStatus, TextualConvention, TimeStamp, ) = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "RowStatus", "TextualConvention", "TimeStamp")
( ringStationControlEntry, sourceRoutingStatsEntry, tokenRing, tokenRingMLStatsEntry, tokenRingPStatsEntry, ) = mibBuilder.importSymbols("TOKEN-RING-RMON-MIB", "ringStationControlEntry", "sourceRoutingStatsEntry", "tokenRing", "tokenRingMLStatsEntry", "tokenRingPStatsEntry")

# Types

class ControlString(OctetString):
    subtypeSpec = OctetString.subtypeSpec+ValueSizeConstraint(0,255)
    
class DataSource(ObjectIdentifier):
    pass

class LastCreateTime(TimeTicks):
    pass

class TimeFilter(TimeTicks):
    pass

class ZeroBasedCounter32(Gauge32):
    pass


# Objects

rmon = ModuleIdentity((1, 3, 6, 1, 2, 1, 16)).setRevisions(("2006-05-02 00:00","2002-07-08 00:00","1996-05-27 00:00",))
if mibBuilder.loadTexts: rmon.setOrganization("IETF RMON MIB Working Group")
if mibBuilder.loadTexts: rmon.setContactInfo("Author:\nSteve Waldbusser\nPhone:  +1-650-948-6500\nFax :   +1-650-745-0671\nEmail:  waldbusser@nextbeacon.com\n\nWorking Group Chair:\nAndy Bierman\nE-mail: ietf@andybierman.com\n\nWorking Group Mailing List: <rmonmib@ietf.org>\nTo subscribe send email to: <rmonmib-request@ietf.org>    ")
if mibBuilder.loadTexts: rmon.setDescription("The MIB module for managing remote monitoring\ndevice implementations.  This MIB module\nextends the architecture introduced in the original\nRMON MIB as specified in RFC 2819.\n\nCopyright (C) The Internet Society (2006).  This version of\nthis MIB module is part of RFC 4502;  see the RFC itself for\nfull legal notices.")
etherStats2Table = MibTable((1, 3, 6, 1, 2, 1, 16, 1, 4))
if mibBuilder.loadTexts: etherStats2Table.setDescription("Contains the RMON-2 augmentations to RMON-1.")
etherStats2Entry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 1, 4, 1))
if mibBuilder.loadTexts: etherStats2Entry.setDescription("Contains the RMON-2 augmentations to RMON-1.")
etherStatsDroppedFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 1, 4, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherStatsDroppedFrames.setDescription("The total number of frames that were received by the probe\nand therefore not accounted for in the *StatsDropEvents, but\nthat the probe chose not to count for this entry for\nwhatever reason.  Most often, this event occurs when the\nprobe is out of some resources and decides to shed load from\nthis collection.\n\nThis count does not include packets that were not counted\nbecause they had MAC-layer errors.\n\nNote that, unlike the dropEvents counter, this number is the\nexact number of frames dropped.")
etherStatsCreateTime = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 1, 4, 1, 2), LastCreateTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherStatsCreateTime.setDescription("The value of sysUpTime when this control entry was last\nactivated.  This can be used by the management station to\nensure that the table has not been deleted and recreated\nbetween polls.")
tokenRingMLStats2Table = MibTable((1, 3, 6, 1, 2, 1, 16, 1, 5))
if mibBuilder.loadTexts: tokenRingMLStats2Table.setDescription("Contains the RMON-2 augmentations to RMON-1.\n\nThis table has been deprecated, as it has not had enough\nindependent implementations to demonstrate interoperability\nto meet the requirements of a Draft Standard.")
tokenRingMLStats2Entry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 1, 5, 1))
if mibBuilder.loadTexts: tokenRingMLStats2Entry.setDescription("Contains the RMON-2 augmentations to RMON-1.")
tokenRingMLStatsDroppedFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 1, 5, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingMLStatsDroppedFrames.setDescription("The total number of frames that were received by the probe\nand therefore not accounted for in the *StatsDropEvents, but\nthat the probe chose not to count for this entry for\nwhatever reason.  Most often, this event occurs when the\nprobe is out of some resources and decides to shed load from\nthis collection.\n\nThis count does not include packets that were not counted\nbecause they had MAC-layer errors.\n\nNote that, unlike the dropEvents counter, this number is the\nexact number of frames dropped.")
tokenRingMLStatsCreateTime = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 1, 5, 1, 2), LastCreateTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingMLStatsCreateTime.setDescription("The value of sysUpTime when this control entry was last\nactivated.  This can be used by the management station to\nensure that the table has not been deleted and recreated\nbetween polls.")
tokenRingPStats2Table = MibTable((1, 3, 6, 1, 2, 1, 16, 1, 6))
if mibBuilder.loadTexts: tokenRingPStats2Table.setDescription("Contains the RMON-2 augmentations to RMON-1.\n\nThis table has been deprecated, as it has not had enough\nindependent implementations to demonstrate interoperability\nto meet the requirements of a Draft Standard.")
tokenRingPStats2Entry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 1, 6, 1))
if mibBuilder.loadTexts: tokenRingPStats2Entry.setDescription("Contains the RMON-2 augmentations to RMON-1.")
tokenRingPStatsDroppedFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 1, 6, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingPStatsDroppedFrames.setDescription("The total number of frames that were received by the probe\nand therefore not accounted for in the *StatsDropEvents, but\nthat the probe chose not to count for this entry for\nwhatever reason.  Most often, this event occurs when the\nprobe is out of some resources and decides to shed load from\nthis collection.\n\nThis count does not include packets that were not counted\nbecause they had MAC-layer errors.\n\nNote that, unlike the dropEvents counter, this number is the\nexact number of frames dropped.")
tokenRingPStatsCreateTime = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 1, 6, 1, 2), LastCreateTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingPStatsCreateTime.setDescription("The value of sysUpTime when this control entry was last\nactivated.  This can be used by the management station to\nensure that the table has not been deleted and recreated\nbetween polls.")
historyControl2Table = MibTable((1, 3, 6, 1, 2, 1, 16, 2, 5))
if mibBuilder.loadTexts: historyControl2Table.setDescription("Contains the RMON-2 augmentations to RMON-1.")
historyControl2Entry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 2, 5, 1))
if mibBuilder.loadTexts: historyControl2Entry.setDescription("Contains the RMON-2 augmentations to RMON-1.")
historyControlDroppedFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 2, 5, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: historyControlDroppedFrames.setDescription("The total number of frames that were received by the probe\nand therefore not accounted for in the *StatsDropEvents, but\nthat the probe chose not to count for this entry for\nwhatever reason.  Most often, this event occurs when the\nprobe is out of some resources and decides to shed load from\nthis collection.\n\nThis count does not include packets that were not counted\nbecause they had MAC-layer errors.\n\nNote that, unlike the dropEvents counter, this number is the\nexact number of frames dropped.")
hostControl2Table = MibTable((1, 3, 6, 1, 2, 1, 16, 4, 4))
if mibBuilder.loadTexts: hostControl2Table.setDescription("Contains the RMON-2 augmentations to RMON-1.")
hostControl2Entry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 4, 4, 1))
if mibBuilder.loadTexts: hostControl2Entry.setDescription("Contains the RMON-2 augmentations to RMON-1.")
hostControlDroppedFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 4, 4, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostControlDroppedFrames.setDescription("The total number of frames that were received by the probe\nand therefore not accounted for in the *StatsDropEvents, but\nthat the probe chose not to count for this entry for\nwhatever reason.  Most often, this event occurs when the\n\n\n\nprobe is out of some resources and decides to shed load from\nthis collection.\n\nThis count does not include packets that were not counted\nbecause they had MAC-layer errors.\n\nNote that, unlike the dropEvents counter, this number is the\nexact number of frames dropped.")
hostControlCreateTime = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 4, 4, 1, 2), LastCreateTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostControlCreateTime.setDescription("The value of sysUpTime when this control entry was last\nactivated.  This can be used by the management station to\nensure that the table has not been deleted and recreated\nbetween polls.")
matrixControl2Table = MibTable((1, 3, 6, 1, 2, 1, 16, 6, 4))
if mibBuilder.loadTexts: matrixControl2Table.setDescription("Contains the RMON-2 augmentations to RMON-1.")
matrixControl2Entry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 6, 4, 1))
if mibBuilder.loadTexts: matrixControl2Entry.setDescription("Contains the RMON-2 augmentations to RMON-1.")
matrixControlDroppedFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 6, 4, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: matrixControlDroppedFrames.setDescription("The total number of frames that were received by the probe\nand therefore not accounted for in the *StatsDropEvents, but\nthat the probe chose not to count for this entry for\nwhatever reason.  Most often, this event occurs when the\nprobe is out of some resources and decides to shed load from\nthis collection.\n\nThis count does not include packets that were not counted\nbecause they had MAC-layer errors.\n\nNote that, unlike the dropEvents counter, this number is the\nexact number of frames dropped.")
matrixControlCreateTime = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 6, 4, 1, 2), LastCreateTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: matrixControlCreateTime.setDescription("The value of sysUpTime when this control entry was last\nactivated.  This can be used by the management station to\nensure that the table has not been deleted and recreated\nbetween polls.")
channel2Table = MibTable((1, 3, 6, 1, 2, 1, 16, 7, 3))
if mibBuilder.loadTexts: channel2Table.setDescription("Contains the RMON-2 augmentations to RMON-1.")
channel2Entry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 7, 3, 1))
if mibBuilder.loadTexts: channel2Entry.setDescription("Contains the RMON-2 augmentations to RMON-1.")
channelDroppedFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 7, 3, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: channelDroppedFrames.setDescription("The total number of frames that were received by the probe\nand therefore not accounted for in the *StatsDropEvents, but\nthat the probe chose not to count for this entry for\nwhatever reason.  Most often, this event occurs when the\nprobe is out of some resources and decides to shed load from\nthis collection.\n\nThis count does not include packets that were not counted\nbecause they had MAC-layer errors.\n\nNote that, unlike the dropEvents counter, this number is the\nexact number of frames dropped.")
channelCreateTime = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 7, 3, 1, 2), LastCreateTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: channelCreateTime.setDescription("The value of sysUpTime when this control entry was last\nactivated.  This can be used by the management station to\nensure that the table has not been deleted and recreated\nbetween polls.")
filter2Table = MibTable((1, 3, 6, 1, 2, 1, 16, 7, 4))
if mibBuilder.loadTexts: filter2Table.setDescription("Provides a variable-length packet filter feature to the\nRMON-1 filter table.")
filter2Entry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 7, 4, 1))
if mibBuilder.loadTexts: filter2Entry.setDescription("Provides a variable-length packet filter feature to the\nRMON-1 filter table.")
filterProtocolDirDataLocalIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 7, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: filterProtocolDirDataLocalIndex.setDescription("When this object is set to a non-zero value, the filter that\nit is associated with performs the following operations on\nevery packet:\n\n1) If the packet doesn't match the protocol directory entry\n   identified by this object, discard the packet and exit\n   (i.e., discard the packet if it is not of the identified\n   protocol).\n\n\n\n2) If the associated filterProtocolDirLocalIndex is non-zero\n   and the packet doesn't match the protocol directory\n   entry identified by that object, discard the packet and\n   exit.\n3) If the packet matches, perform the regular filter\n   algorithm as if the beginning of this named protocol is\n   the beginning of the packet, potentially applying the\n   filterOffset value to move further into the packet.")
filterProtocolDirLocalIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 7, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: filterProtocolDirLocalIndex.setDescription("When this object is set to a non-zero value, the filter that\nit is associated with will discard the packet if the packet\ndoesn't match this protocol directory entry.")
ringStationControl2Table = MibTable((1, 3, 6, 1, 2, 1, 16, 10, 7))
if mibBuilder.loadTexts: ringStationControl2Table.setDescription("Contains the RMON-2 augmentations to RMON-1.\n\nThis table has been deprecated, as it has not had enough\nindependent implementations to demonstrate interoperability\nto meet the requirements of a Draft Standard.")
ringStationControl2Entry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 10, 7, 1))
if mibBuilder.loadTexts: ringStationControl2Entry.setDescription("Contains the RMON-2 augmentations to RMON-1.")
ringStationControlDroppedFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 10, 7, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ringStationControlDroppedFrames.setDescription("The total number of frames that were received by the probe\nand therefore not accounted for in the *StatsDropEvents, but\nthat the probe chose not to count for this entry for\nwhatever reason.  Most often, this event occurs when the\nprobe is out of some resources and decides to shed load from\nthis collection.\n\nThis count does not include packets that were not counted\nbecause they had MAC-layer errors.\n\nNote that, unlike the dropEvents counter, this number is the\nexact number of frames dropped.")
ringStationControlCreateTime = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 10, 7, 1, 2), LastCreateTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ringStationControlCreateTime.setDescription("The value of sysUpTime when this control entry was last\nactivated.  This can be used by the management station to\n\n\n\nensure that the table has not been deleted and recreated\nbetween polls.")
sourceRoutingStats2Table = MibTable((1, 3, 6, 1, 2, 1, 16, 10, 8))
if mibBuilder.loadTexts: sourceRoutingStats2Table.setDescription("Contains the RMON-2 augmentations to RMON-1.\n\nThis table has been deprecated, as it has not had enough\nindependent implementations to demonstrate interoperability\nto meet the requirements of a Draft Standard.")
sourceRoutingStats2Entry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 10, 8, 1))
if mibBuilder.loadTexts: sourceRoutingStats2Entry.setDescription("Contains the RMON-2 augmentations to RMON-1.")
sourceRoutingStatsDroppedFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 10, 8, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sourceRoutingStatsDroppedFrames.setDescription("The total number of frames that were received by the probe\nand therefore not accounted for in the *StatsDropEvents, but\nthat the probe chose not to count for this entry for\nwhatever reason.  Most often, this event occurs when the\nprobe is out of some resources and decides to shed load from\nthis collection.\n\nThis count does not include packets that were not counted\nbecause they had MAC-layer errors.\n\nNote that, unlike the dropEvents counter, this number is the\nexact number of frames dropped.")
sourceRoutingStatsCreateTime = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 10, 8, 1, 2), LastCreateTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sourceRoutingStatsCreateTime.setDescription("The value of sysUpTime when this control entry was last\nactivated.  This can be used by the management station to\nensure that the table has not been deleted and recreated\nbetween polls.")
protocolDir = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 11))
protocolDirLastChange = MibScalar((1, 3, 6, 1, 2, 1, 16, 11, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: protocolDirLastChange.setDescription("The value of sysUpTime at the time the protocol directory\nwas last modified, either through insertions or deletions,\nor through modifications of the\nprotocolDirAddressMapConfig, protocolDirHostConfig, or\nprotocolDirMatrixConfig.")
protocolDirTable = MibTable((1, 3, 6, 1, 2, 1, 16, 11, 2))
if mibBuilder.loadTexts: protocolDirTable.setDescription("This table lists the protocols that this agent has the\ncapability to decode and count.  There is one entry in this\ntable for each such protocol.  These protocols represent\ndifferent network-layer, transport-layer, and higher-layer\n\n\n\nprotocols.  The agent should boot up with this table\npreconfigured with those protocols that it knows about and\nwishes to monitor.  Implementations are strongly encouraged to\nsupport protocols higher than the network layer (at least for\nthe protocol distribution group), even for implementations\nthat don't support the application-layer groups.")
protocolDirEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 11, 2, 1)).setIndexNames((0, "RMON2-MIB", "protocolDirID"), (0, "RMON2-MIB", "protocolDirParameters"))
if mibBuilder.loadTexts: protocolDirEntry.setDescription("A conceptual row in the protocolDirTable.\n\nAn example of the indexing of this entry is\nprotocolDirLocalIndex.8.0.0.0.1.0.0.8.0.2.0.0, which is the\nencoding of a length of 8, followed by 8 subids encoding the\nprotocolDirID of 1.2048, followed by a length of 2 and the\n2 subids encoding zero-valued parameters.\n\nNote that some combinations of index values may result in an\nindex that exceeds 128 sub-identifiers in length, which exceeds\nthe maximum for the SNMP protocol.  Implementations should take\ncare to avoid such combinations.")
protocolDirID = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 11, 2, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 128))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: protocolDirID.setDescription("A unique identifier for a particular protocol.  Standard\nidentifiers will be defined in such a manner that they\n\n\n\ncan often be used as specifications for new protocols - i.e.,\na tree-structured assignment mechanism that matches the\nprotocol encapsulation 'tree' and that has algorithmic\nassignment mechanisms for certain subtrees.  See RFC 2074 for\nmore details.\n\nDespite the algorithmic mechanism, the probe will only place\nentries in here for those protocols it chooses to collect.  In\nother words, it need not populate this table with all\npossible ethernet protocol types, nor need it create them on\nthe fly when it sees them.  Whether it does these\nthings is a matter of product definition (cost/benefit,\nusability) and is up to the designer of the product.\n\nIf an entry is written to this table with a protocolDirID that\nthe agent doesn't understand, either directly or\nalgorithmically, the SET request will be rejected with an\ninconsistentName or badValue (for SNMPv1) error.")
protocolDirParameters = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 11, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: protocolDirParameters.setDescription("A set of parameters for the associated protocolDirID.\nSee the associated RMON2 Protocol Identifiers document\nfor a description of the possible parameters.  There\nwill be one octet in this string for each sub-identifier in\nthe protocolDirID, and the parameters will appear here in the\nsame order as the associated sub-identifiers appear in the\nprotocolDirID.\n\nEvery node in the protocolDirID tree has a different, optional\nset of parameters defined (that is, the definition of\nparameters for a node is optional).  The proper parameter\nvalue for each node is included in this string.  Note that the\ninclusion of a parameter value in this string for each node is\nnot optional.  What is optional is that a node may have no\nparameters defined, in which case the parameter field for that\nnode will be zero.")
protocolDirLocalIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 11, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: protocolDirLocalIndex.setDescription("The locally arbitrary but unique identifier associated\nwith this protocolDir entry.\n\nThe value for each supported protocol must remain constant at\nleast from one re-initialization of the entity's network\nmanagement system to the next re-initialization, except that\nif a protocol is deleted and re-created, it must be re-created\nwith a new value that has not been used since the last\nre-initialization.\n\nThe specific value is meaningful only within a given SNMP\nentity.  A protocolDirLocalIndex must not be re-used until the\nnext agent restart in the event that the protocol directory\nentry is deleted.")
protocolDirDescr = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 11, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: protocolDirDescr.setDescription("A textual description of the protocol encapsulation.\nA probe may choose to describe only a subset of the\nentire encapsulation (e.g., only the highest layer).\n\nThis object is intended for human consumption only.\n\nThis object may not be modified if the associated\nprotocolDirStatus object is equal to active(1).")
protocolDirType = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 11, 2, 1, 5), Bits().subtype(namedValues=NamedValues(("extensible", 0), ("addressRecognitionCapable", 1), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: protocolDirType.setDescription("This object describes 2 attributes of this protocol\ndirectory entry.\n\nThe presence or absence of the 'extensible' bit describes\nwhether this protocol directory entry can be extended\nby the user by creating protocol directory entries that are\nchildren of this protocol.\n\nAn example of an entry that will often allow extensibility is\n\n\n\n'ip.udp'.  The probe may automatically populate some children\nof this node, such as 'ip.udp.snmp' and 'ip.udp.dns'.\nA probe administrator or user may also populate additional\nchildren via remote SNMP requests that create entries in this\ntable.  When a child node is added for a protocol for which the\nprobe has no built-in support extending a parent node (for\nwhich the probe does have built-in support),\nthat child node is not extendable.  This is termed 'limited\nextensibility'.\n\nWhen a child node is added through this extensibility\nmechanism, the values of protocolDirLocalIndex and\nprotocolDirType shall be assigned by the agent.\n\nThe other objects in the entry will be assigned by the\nmanager who is creating the new entry.\n\nThis object also describes whether this agent can\nrecognize addresses for this protocol, should it be a\nnetwork-level protocol.  That is, while a probe may be able\nto recognize packets of a particular network-layer protocol\nand count them, it takes additional logic to be able to\nrecognize the addresses in this protocol and to populate\nnetwork-layer or application-layer tables with the addresses\nin this protocol.  If this bit is set, the agent will\nrecognize network-layer addresses for this protocol and\npopulate the network- and application-layer host and matrix\ntables with these protocols.\n\nNote that when an entry is created, the agent will supply\nvalues for the bits that match the capabilities of the agent\nwith respect to this protocol.  Note that since row creations\nusually exercise the limited extensibility feature, these\nbits will usually be set to zero.")
protocolDirAddressMapConfig = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 11, 2, 1, 6), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,3,)).subtype(namedValues=NamedValues(("notSupported", 1), ("supportedOff", 2), ("supportedOn", 3), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: protocolDirAddressMapConfig.setDescription("This object describes and configures the probe's support for\naddress mapping for this protocol.  When the probe creates\nentries in this table for all protocols that it understands,\n\n\n\nit will set the entry to notSupported(1) if it doesn't have\nthe capability to perform address mapping for the protocol or\nif this protocol is not a network-layer protocol.  When\nan entry is created in this table by a management operation as\npart of the limited extensibility feature, the probe must set\nthis value to notSupported(1), because limited extensibility\nof the protocolDirTable does not extend to interpreting\naddresses of the extended protocols.\n\nIf the value of this object is notSupported(1), the probe\nwill not perform address mapping for this protocol and\nshall not allow this object to be changed to any other value.\nIf the value of this object is supportedOn(3), the probe\nsupports address mapping for this protocol and is configured\nto perform address mapping for this protocol for all\naddressMappingControlEntries and all interfaces.\nIf the value of this object is supportedOff(2), the probe\nsupports address mapping for this protocol but is configured\nto not perform address mapping for this protocol for any\naddressMappingControlEntries and all interfaces.\nWhenever this value changes from supportedOn(3) to\nsupportedOff(2), the probe shall delete all related entries in\nthe addressMappingTable.")
protocolDirHostConfig = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 11, 2, 1, 7), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,3,)).subtype(namedValues=NamedValues(("notSupported", 1), ("supportedOff", 2), ("supportedOn", 3), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: protocolDirHostConfig.setDescription("This object describes and configures the probe's support for\nthe network-layer and application-layer host tables for this\nprotocol.  When the probe creates entries in this table for\nall protocols that it understands, it will set the entry to\nnotSupported(1) if it doesn't have the capability to track the\nnlHostTable for this protocol or if the alHostTable is\nimplemented but doesn't have the capability to track this\nprotocol.  Note that if the alHostTable is implemented, the\nprobe may only support a protocol if it is supported in both\nthe nlHostTable and the alHostTable.\n\nIf the associated protocolDirType object has the\naddressRecognitionCapable bit set, then this is a network-\nlayer protocol for which the probe recognizes addresses, and\n\n\n\nthus the probe will populate the nlHostTable and alHostTable\nwith addresses it discovers for this protocol.\n\nIf the value of this object is notSupported(1), the probe\nwill not track the nlHostTable or alHostTable for this\nprotocol and shall not allow this object to be changed to any\nother value.  If the value of this object is supportedOn(3),\nthe probe supports tracking of the nlHostTable and alHostTable\nfor this protocol and is configured to track both tables\nfor this protocol for all control entries and all interfaces.\nIf the value of this object is supportedOff(2), the probe\nsupports tracking of the nlHostTable and alHostTable for this\nprotocol but is configured to not track these tables\nfor any control entries or interfaces.\nWhenever this value changes from supportedOn(3) to\nsupportedOff(2), the probe shall delete all related entries in\nthe nlHostTable and alHostTable.\n\nNote that since each alHostEntry references 2 protocol\ndirectory entries, one for the network address and one for the\ntype of the highest protocol recognized, an entry will\nonly be created in that table if this value is supportedOn(3)\nfor both protocols.")
protocolDirMatrixConfig = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 11, 2, 1, 8), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,3,)).subtype(namedValues=NamedValues(("notSupported", 1), ("supportedOff", 2), ("supportedOn", 3), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: protocolDirMatrixConfig.setDescription("This object describes and configures the probe's support for\nthe network-layer and application-layer matrix tables for this\nprotocol.  When the probe creates entries in this table for\nall protocols that it understands, it will set the entry to\nnotSupported(1) if it doesn't have the capability to track the\nnlMatrixTables for this protocol or if the alMatrixTables are\nimplemented but don't have the capability to track this\nprotocol.  Note that if the alMatrix tables are implemented,\nthe probe may only support a protocol if it is supported in\nboth of the nlMatrixTables and both of the\nalMatrixTables.\n\nIf the associated protocolDirType object has the\naddressRecognitionCapable bit set, then this is a network-\n\n\n\nlayer protocol for which the probe recognizes addresses, and\nthus the probe will populate both of the nlMatrixTables and\nboth of the alMatrixTables with addresses it discovers for\nthis protocol.\n\nIf the value of this object is notSupported(1), the probe\nwill not track either of the nlMatrixTables or the\nalMatrixTables for this protocol and shall not allow this\nobject to be changed to any other value.  If the value of this\nobject is supportedOn(3), the probe supports tracking of both\nof the nlMatrixTables and (if implemented) both of the\nalMatrixTables for this protocol and is configured to track\nthese tables for this protocol for all control entries and all\ninterfaces.  If the value of this object is supportedOff(2),\nthe probe supports tracking of both of the nlMatrixTables and\n(if implemented) both of the alMatrixTables for this protocol\nbut is configured to not track these tables for this\nprotocol for any control entries or interfaces.\nWhenever this value changes from supportedOn(3) to\nsupportedOff(2), the probe shall delete all related entries in\nthe nlMatrixTables and the alMatrixTables.\n\nNote that since each alMatrixEntry references 2 protocol\ndirectory entries, one for the network address and one for the\ntype of the highest protocol recognized, an entry will\nonly be created in that table if this value is supportedOn(3)\nfor both protocols.")
protocolDirOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 11, 2, 1, 9), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: protocolDirOwner.setDescription("The entity that configured this entry and is\ntherefore using the resources assigned to it.")
protocolDirStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 11, 2, 1, 10), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: protocolDirStatus.setDescription("The status of this protocol directory entry.\n\nAn entry may not exist in the active state unless all\nobjects in the entry have an appropriate value.\n\n\n\n\nIf this object is not equal to active(1), all associated\nentries in the nlHostTable, nlMatrixSDTable, nlMatrixDSTable,\nalHostTable, alMatrixSDTable, and alMatrixDSTable shall be\ndeleted.")
protocolDist = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 12))
protocolDistControlTable = MibTable((1, 3, 6, 1, 2, 1, 16, 12, 1))
if mibBuilder.loadTexts: protocolDistControlTable.setDescription("Controls the setup of protocol type distribution statistics\ntables.\n\nImplementations are encouraged to add an entry per monitored\ninterface upon initialization so that a default collection\nof protocol statistics is available.\n\nRationale:\nThis table controls collection of very basic statistics\nfor any or all of the protocols detected on a given interface.\nAn NMS can use this table to quickly determine bandwidth\nallocation utilized by different protocols.\n\nA media-specific statistics collection could also\nbe configured (e.g., etherStats, trPStats) to easily obtain\ntotal frame, octet, and droppedEvents for the same\ninterface.")
protocolDistControlEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 12, 1, 1)).setIndexNames((0, "RMON2-MIB", "protocolDistControlIndex"))
if mibBuilder.loadTexts: protocolDistControlEntry.setDescription("A conceptual row in the protocolDistControlTable.\n\nAn example of the indexing of this entry is\nprotocolDistControlDroppedFrames.7")
protocolDistControlIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 12, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: protocolDistControlIndex.setDescription("A unique index for this protocolDistControlEntry.")
protocolDistControlDataSource = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 12, 1, 1, 2), DataSource()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: protocolDistControlDataSource.setDescription("The source of data for the this protocol distribution.\n\nThe statistics in this group reflect all packets\non the local network segment attached to the\nidentified interface.\n\nThis object may not be modified if the associated\nprotocolDistControlStatus object is equal to active(1).")
protocolDistControlDroppedFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 12, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: protocolDistControlDroppedFrames.setDescription("The total number of frames that were received by the probe\nand therefore not accounted for in the *StatsDropEvents, but\nthat the probe chose not to count for this entry for\nwhatever reason.  Most often, this event occurs when the probe\nis out of some resources and decides to shed load from this\ncollection.\n\nThis count does not include packets that were not counted\nbecause they had MAC-layer errors.\n\n\n\nNote that, unlike the dropEvents counter, this number is the\nexact number of frames dropped.")
protocolDistControlCreateTime = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 12, 1, 1, 4), LastCreateTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: protocolDistControlCreateTime.setDescription("The value of sysUpTime when this control entry was last\nactivated.  This can be used by the management station to\nensure that the table has not been deleted and recreated\nbetween polls.")
protocolDistControlOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 12, 1, 1, 5), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: protocolDistControlOwner.setDescription("The entity that configured this entry and is\ntherefore using the resources assigned to it.")
protocolDistControlStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 12, 1, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: protocolDistControlStatus.setDescription("The status of this row.\n\nAn entry may not exist in the active state unless all\nobjects in the entry have an appropriate value.\n\nIf this object is not equal to active(1), all associated\nentries in the protocolDistStatsTable shall be deleted.")
protocolDistStatsTable = MibTable((1, 3, 6, 1, 2, 1, 16, 12, 2))
if mibBuilder.loadTexts: protocolDistStatsTable.setDescription("An entry is made in this table for every protocol in the\nprotocolDirTable that has been seen in at least one packet.\nCounters are updated in this table for every protocol type\nthat is encountered when parsing a packet, but no counters are\n\n\n\nupdated for packets with MAC-layer errors.\n\nNote that if a protocolDirEntry is deleted, all associated\nentries in this table are removed.")
protocolDistStatsEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 12, 2, 1)).setIndexNames((0, "RMON2-MIB", "protocolDistControlIndex"), (0, "RMON2-MIB", "protocolDirLocalIndex"))
if mibBuilder.loadTexts: protocolDistStatsEntry.setDescription("A conceptual row in the protocolDistStatsTable.\n\nThe index is composed of the protocolDistControlIndex of the\nassociated protocolDistControlEntry, followed by the\nprotocolDirLocalIndex of the associated protocol that this\nentry represents.  In other words, the index identifies the\nprotocol distribution an entry is a part of and the\nparticular protocol that it represents.\n\nAn example of the indexing of this entry is\nprotocolDistStatsPkts.1.18")
protocolDistStatsPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 12, 2, 1, 1), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: protocolDistStatsPkts.setDescription("The number of packets of this protocol type received\nwithout errors.  Note that this is the number of\nlink-layer packets, so if a single network-layer packet\nis fragmented into several link-layer frames, this counter\nis incremented several times.")
protocolDistStatsOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 12, 2, 1, 2), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: protocolDistStatsOctets.setDescription("The number of octets in packets of this protocol type\n\n\n\nreceived since it was added to the protocolDistStatsTable\n(excluding framing bits, but including FCS octets), except for\nthose octets in packets that contained errors.\n\nNote that this doesn't count just those octets in the\nparticular protocol frames but includes the entire packet\nthat contained the protocol.")
addressMap = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 13))
addressMapInserts = MibScalar((1, 3, 6, 1, 2, 1, 16, 13, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: addressMapInserts.setDescription("The number of times an address mapping entry has been\ninserted into the addressMapTable.  If an entry is inserted,\nthen deleted, and then inserted, this counter will be\nincremented by 2.\n\nNote that the table size can be determined by subtracting\naddressMapDeletes from addressMapInserts.")
addressMapDeletes = MibScalar((1, 3, 6, 1, 2, 1, 16, 13, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: addressMapDeletes.setDescription("The number of times an address mapping entry has been\ndeleted from the addressMapTable (for any reason).  If\nan entry is deleted, then inserted, and then deleted, this\ncounter will be incremented by 2.\n\nNote that the table size can be determined by subtracting\naddressMapDeletes from addressMapInserts.")
addressMapMaxDesiredEntries = MibScalar((1, 3, 6, 1, 2, 1, 16, 13, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: addressMapMaxDesiredEntries.setDescription("The maximum number of entries that are desired in the\naddressMapTable.  The probe will not create more than\nthis number of entries in the table but may choose to create\nfewer entries in this table for any reason, including the lack\nof resources.\n\nIf this object is set to a value less than the current number\nof entries, enough entries are chosen in an\nimplementation-dependent manner and deleted so that the number\nof entries in the table equals the value of this object.\n\nIf this value is set to -1, the probe may create any number\nof entries in this table.\n\nThis object may be used to control how resources are allocated\non the probe for the various RMON functions.")
addressMapControlTable = MibTable((1, 3, 6, 1, 2, 1, 16, 13, 4))
if mibBuilder.loadTexts: addressMapControlTable.setDescription("A table to control the collection of mappings from network\nlayer address to physical address to interface.\n\nNote that this is not like the typical RMON\ncontrolTable and dataTable in which each entry creates\nits own data table.  Each entry in this table enables the\ndiscovery of addresses on a new interface and the placement\nof address mappings into the central addressMapTable.\n\nImplementations are encouraged to add an entry per monitored\ninterface upon initialization so that a default collection\nof address mappings is available.")
addressMapControlEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 13, 4, 1)).setIndexNames((0, "RMON2-MIB", "addressMapControlIndex"))
if mibBuilder.loadTexts: addressMapControlEntry.setDescription("A conceptual row in the addressMapControlTable.\n\nAn example of the indexing of this entry is\naddressMapControlDroppedFrames.1")
addressMapControlIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 13, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: addressMapControlIndex.setDescription("A unique index for this entry in the addressMapControlTable.")
addressMapControlDataSource = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 13, 4, 1, 2), DataSource()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: addressMapControlDataSource.setDescription("The source of data for this addressMapControlEntry.")
addressMapControlDroppedFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 13, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: addressMapControlDroppedFrames.setDescription("The total number of frames that were received by the probe\nand therefore not accounted for in the *StatsDropEvents, but\nthat the probe chose not to count for this entry for\nwhatever reason.  Most often, this event occurs when the probe\nis out of some resources and decides to shed load from this\ncollection.\n\nThis count does not include packets that were not counted\nbecause they had MAC-layer errors.\n\nNote that, unlike the dropEvents counter, this number is the\nexact number of frames dropped.")
addressMapControlOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 13, 4, 1, 4), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: addressMapControlOwner.setDescription("The entity that configured this entry and is\ntherefore using the resources assigned to it.")
addressMapControlStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 13, 4, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: addressMapControlStatus.setDescription("The status of this addressMap control entry.\n\nAn entry may not exist in the active state unless all\nobjects in the entry have an appropriate value.\n\nIf this object is not equal to active(1), all associated\nentries in the addressMapTable shall be deleted.")
addressMapTable = MibTable((1, 3, 6, 1, 2, 1, 16, 13, 5))
if mibBuilder.loadTexts: addressMapTable.setDescription("A table of mappings from network layer address to physical\naddress to interface.\n\nThe probe will add entries to this table based on the source\nMAC and network addresses seen in packets without MAC-level\nerrors.  The probe will populate this table for all protocols\nin the protocol directory table whose value of\nprotocolDirAddressMapConfig is equal to supportedOn(3), and\nwill delete any entries whose protocolDirEntry is deleted or\nhas a protocolDirAddressMapConfig value of supportedOff(2).")
addressMapEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 13, 5, 1)).setIndexNames((0, "RMON2-MIB", "addressMapTimeMark"), (0, "RMON2-MIB", "protocolDirLocalIndex"), (0, "RMON2-MIB", "addressMapNetworkAddress"), (0, "RMON2-MIB", "addressMapSource"))
if mibBuilder.loadTexts: addressMapEntry.setDescription("A conceptual row in the addressMapTable.\n\nThe protocolDirLocalIndex in the index identifies the network\nlayer protocol of the addressMapNetworkAddress.\n\n\n\n\nAn example of the indexing of this entry is\naddressMapSource.783495.18.4.128.2.6.6.11.1.3.6.1.2.1.2.2.1.1.1.\n\nNote that some combinations of index values may result in an\nindex that exceeds 128 sub-identifiers in length, which exceeds\nthe maximum for the SNMP protocol.  Implementations should take\ncare to avoid such combinations.")
addressMapTimeMark = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 13, 5, 1, 1), TimeFilter()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: addressMapTimeMark.setDescription("A TimeFilter for this entry.  See the TimeFilter textual\nconvention to see how this works.")
addressMapNetworkAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 13, 5, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: addressMapNetworkAddress.setDescription("The network address for this relation.\n\nThis is represented as an octet string with\nspecific semantics and length as identified\nby the protocolDirLocalIndex component of the\nindex.\n\nFor example, if the protocolDirLocalIndex indicates an\nencapsulation of ip, this object is encoded as a length\noctet of 4, followed by the 4 octets of the IP address,\nin network byte order.")
addressMapSource = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 13, 5, 1, 3), ObjectIdentifier()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: addressMapSource.setDescription("The interface or port on which the associated network\naddress was most recently seen.\n\nIf this address mapping was discovered on an interface, this\nobject shall identify the instance of the ifIndex\nobject, defined in [RFC2863], for the desired interface.\nFor example, if an entry were to receive data from\ninterface #1, this object would be set to ifIndex.1.\n\nIf this address mapping was discovered on a port, this\nobject shall identify the instance of the rptrGroupPortIndex\nobject, defined in [RFC2108], for the desired port.\nFor example, if an entry were to receive data from\ngroup #1, port #1, this object would be set to\nrptrGroupPortIndex.1.1.\n\nNote that while the dataSource associated with this entry\nmay only point to index objects, this object may at times\npoint to repeater port objects.  This situation occurs when\nthe dataSource points to an interface that is a locally\nattached repeater and the agent has additional information\nabout the source port of traffic seen on that repeater.")
addressMapPhysicalAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 13, 5, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: addressMapPhysicalAddress.setDescription("The last source physical address on which the associated\nnetwork address was seen.  If the protocol of the associated\nnetwork address was encapsulated inside of a network-level or\nhigher protocol, this will be the address of the next-lower\nprotocol with the addressRecognitionCapable bit enabled and\nwill be formatted as specified for that protocol.")
addressMapLastChange = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 13, 5, 1, 5), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: addressMapLastChange.setDescription("The value of sysUpTime at the time this entry was last\ncreated or the values of the physical address changed.\n\n\n\n\nThis can be used to help detect duplicate address problems, in\nwhich case this object will be updated frequently.")
nlHost = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 14))
hlHostControlTable = MibTable((1, 3, 6, 1, 2, 1, 16, 14, 1))
if mibBuilder.loadTexts: hlHostControlTable.setDescription("A list of higher-layer (i.e., non-MAC) host table control\nentries.\n\nThese entries will enable the collection of the network- and\napplication-level host tables indexed by network addresses.\nBoth the network- and application-level host tables are\ncontrolled by this table so that they will both be created\nand deleted at the same time, further increasing the ease with\nwhich they can be implemented as a single datastore.  (Note that\nif an implementation stores application-layer host records in\nmemory, it can derive network-layer host records from them.)\n\nEntries in the nlHostTable will be created on behalf of each\nentry in this table.  Additionally, if this probe implements\nthe alHostTable, entries in the alHostTable will be created on\nbehalf of each entry in this table.\n\nImplementations are encouraged to add an entry per monitored\ninterface upon initialization so that a default collection\nof host statistics is available.")
hlHostControlEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 14, 1, 1)).setIndexNames((0, "RMON2-MIB", "hlHostControlIndex"))
if mibBuilder.loadTexts: hlHostControlEntry.setDescription("A conceptual row in the hlHostControlTable.\n\nAn example of the indexing of this entry is\n\n\n\nhlHostControlNlDroppedFrames.1")
hlHostControlIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 14, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: hlHostControlIndex.setDescription("An index that uniquely identifies an entry in the\nhlHostControlTable.  Each such entry defines\na function that discovers hosts on a particular\ninterface and places statistics about them in the\nnlHostTable, and optionally in the alHostTable, on\nbehalf of this hlHostControlEntry.")
hlHostControlDataSource = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 14, 1, 1, 2), DataSource()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hlHostControlDataSource.setDescription("The source of data for the associated host tables.\n\nThe statistics in this group reflect all packets\non the local network segment attached to the\nidentified interface.\n\nThis object may not be modified if the associated\nhlHostControlStatus object is equal to active(1).")
hlHostControlNlDroppedFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 14, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hlHostControlNlDroppedFrames.setDescription("The total number of frames that were received by the probe\nand therefore not accounted for in the *StatsDropEvents, but\nthat the probe chose not to count for the associated\nnlHost entries for whatever reason.  Most often, this event\noccurs when the probe is out of some resources and decides to\nshed load from this collection.\n\nThis count does not include packets that were not counted\nbecause they had MAC-layer errors.\n\nNote that if the nlHostTable is inactive because no protocols\nare enabled in the protocol directory, this value should be 0.\n\nNote that, unlike the dropEvents counter, this number is the\nexact number of frames dropped.")
hlHostControlNlInserts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 14, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hlHostControlNlInserts.setDescription("The number of times an nlHost entry has been\ninserted into the nlHost table.  If an entry is inserted, then\ndeleted, and then inserted, this counter will be incremented\nby 2.\n\nTo allow for efficient implementation strategies, agents may\ndelay updating this object for short periods of time.  For\nexample, an implementation strategy may allow internal\ndata structures to differ from those visible via SNMP for\nshort periods of time.  This counter may reflect the internal\ndata structures for those short periods of time.\n\nNote that the table size can be determined by subtracting\nhlHostControlNlDeletes from hlHostControlNlInserts.")
hlHostControlNlDeletes = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 14, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hlHostControlNlDeletes.setDescription("The number of times an nlHost entry has been\n\n\n\ndeleted from the nlHost table (for any reason).  If an entry\nis deleted, then inserted, and then deleted, this counter will\nbe incremented by 2.\n\nTo allow for efficient implementation strategies, agents may\ndelay updating this object for short periods of time.  For\nexample, an implementation strategy may allow internal\ndata structures to differ from those visible via SNMP for\nshort periods of time.  This counter may reflect the internal\ndata structures for those short periods of time.\n\nNote that the table size can be determined by subtracting\nhlHostControlNlDeletes from hlHostControlNlInserts.")
hlHostControlNlMaxDesiredEntries = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 14, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hlHostControlNlMaxDesiredEntries.setDescription("The maximum number of entries that are desired in the\nnlHostTable on behalf of this control entry.  The probe will\nnot create more than this number of associated entries in the\ntable but may choose to create fewer entries in this table\nfor any reason, including the lack of resources.\n\nIf this object is set to a value less than the current number\nof entries, enough entries are chosen in an\nimplementation-dependent manner and deleted so that the number\nof entries in the table equals the value of this object.\n\nIf this value is set to -1, the probe may create any number\nof entries in this table.  If the associated\nhlHostControlStatus object is equal to 'active', this\nobject may not be modified.\n\nThis object may be used to control how resources are allocated\non the probe for the various RMON functions.")
hlHostControlAlDroppedFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 14, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hlHostControlAlDroppedFrames.setDescription("The total number of frames that were received by the probe\nand therefore not accounted for in the *StatsDropEvents, but\nthat the probe chose not to count for the associated\n\n\n\nalHost entries for whatever reason.  Most often, this event\noccurs when the probe is out of some resources and decides to\nshed load from this collection.\n\nThis count does not include packets that were not counted\nbecause they had MAC-layer errors.\n\nNote that if the alHostTable is not implemented or is inactive\nbecause no protocols are enabled in the protocol directory,\nthis value should be 0.\n\nNote that, unlike the dropEvents counter, this number is the\nexact number of frames dropped.")
hlHostControlAlInserts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 14, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hlHostControlAlInserts.setDescription("The number of times an alHost entry has been\ninserted into the alHost table.  If an entry is inserted, then\ndeleted, and then inserted, this counter will be incremented\nby 2.\n\nTo allow for efficient implementation strategies, agents may\ndelay updating this object for short periods of time.  For\nexample, an implementation strategy may allow internal\ndata structures to differ from those visible via SNMP for\nshort periods of time.  This counter may reflect the internal\ndata structures for those short periods of time.\n\nNote that the table size can be determined by subtracting\nhlHostControlAlDeletes from hlHostControlAlInserts.")
hlHostControlAlDeletes = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 14, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hlHostControlAlDeletes.setDescription("The number of times an alHost entry has been\ndeleted from the alHost table (for any reason).  If an entry\nis deleted, then inserted, and then deleted, this counter will\nbe incremented by 2.\n\nTo allow for efficient implementation strategies, agents may\ndelay updating this object for short periods of time.  For\n\n\n\nexample, an implementation strategy may allow internal\ndata structures to differ from those visible via SNMP for\nshort periods of time.  This counter may reflect the internal\ndata structures for those short periods of time.\n\nNote that the table size can be determined by subtracting\nhlHostControlAlDeletes from hlHostControlAlInserts.")
hlHostControlAlMaxDesiredEntries = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 14, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hlHostControlAlMaxDesiredEntries.setDescription("The maximum number of entries that are desired in the alHost\ntable on behalf of this control entry.  The probe will not\ncreate more than this number of associated entries in the\ntable but may choose to create fewer entries in this table\nfor any reason, including the lack of resources.\n\nIf this object is set to a value less than the current number\nof entries, enough entries are chosen in an\nimplementation-dependent manner and deleted so that the number\nof entries in the table equals the value of this object.\n\nIf this value is set to -1, the probe may create any number\nof entries in this table.  If the associated\nhlHostControlStatus object is equal to 'active', this\nobject may not be modified.\n\nThis object may be used to control how resources are allocated\non the probe for the various RMON functions.")
hlHostControlOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 14, 1, 1, 11), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hlHostControlOwner.setDescription("The entity that configured this entry and is\ntherefore using the resources assigned to it.")
hlHostControlStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 14, 1, 1, 12), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hlHostControlStatus.setDescription("The status of this hlHostControlEntry.\n\nAn entry may not exist in the active state unless all\nobjects in the entry have an appropriate value.\n\nIf this object is not equal to active(1), all associated\nentries in the nlHostTable and alHostTable shall be deleted.")
nlHostTable = MibTable((1, 3, 6, 1, 2, 1, 16, 14, 2))
if mibBuilder.loadTexts: nlHostTable.setDescription("A collection of statistics for a particular network layer\naddress that has been discovered on an interface of this\ndevice.\n\nThe probe will populate this table for all network layer\nprotocols in the protocol directory table whose value of\nprotocolDirHostConfig is equal to supportedOn(3), and\nwill delete any entries whose protocolDirEntry is deleted or\nhas a protocolDirHostConfig value of supportedOff(2).\n\nThe probe will add to this table all addresses seen\nas the source or destination address in all packets with no\nMAC errors, and will increment octet and packet counts in the\ntable for all packets with no MAC errors.")
nlHostEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 14, 2, 1)).setIndexNames((0, "RMON2-MIB", "hlHostControlIndex"), (0, "RMON2-MIB", "nlHostTimeMark"), (0, "RMON2-MIB", "protocolDirLocalIndex"), (0, "RMON2-MIB", "nlHostAddress"))
if mibBuilder.loadTexts: nlHostEntry.setDescription("A conceptual row in the nlHostTable.\n\nThe hlHostControlIndex value in the index identifies the\nhlHostControlEntry on whose behalf this entry was created.\nThe protocolDirLocalIndex value in the index identifies the\nnetwork layer protocol of the nlHostAddress.\n\nAn example of the indexing of this entry is\nnlHostOutPkts.1.783495.18.4.128.2.6.6.\n\nNote that some combinations of index values may result in an\nindex that exceeds 128 sub-identifiers in length, which exceeds\nthe maximum for the SNMP protocol.  Implementations should take\n\n\n\ncare to avoid such combinations.")
nlHostTimeMark = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 14, 2, 1, 1), TimeFilter()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: nlHostTimeMark.setDescription("A TimeFilter for this entry.  See the TimeFilter textual\nconvention to see how this works.")
nlHostAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 14, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: nlHostAddress.setDescription("The network address for this nlHostEntry.\n\nThis is represented as an octet string with\nspecific semantics and length as identified\nby the protocolDirLocalIndex component of the index.\n\nFor example, if the protocolDirLocalIndex indicates an\nencapsulation of IP, this object is encoded as a length\noctet of 4, followed by the 4 octets of the IP address,\nin network byte order.")
nlHostInPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 14, 2, 1, 3), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlHostInPkts.setDescription("The number of packets without errors transmitted to\n\n\n\nthis address since it was added to the nlHostTable.  Note that\nthis is the number of link-layer packets, so if a single\nnetwork-layer packet is fragmented into several link-layer\nframes, this counter is incremented several times.")
nlHostOutPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 14, 2, 1, 4), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlHostOutPkts.setDescription("The number of packets without errors transmitted by\nthis address since it was added to the nlHostTable.  Note that\nthis is the number of link-layer packets, so if a single\nnetwork-layer packet is fragmented into several link-layer\nframes, this counter is incremented several times.")
nlHostInOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 14, 2, 1, 5), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlHostInOctets.setDescription("The number of octets transmitted to this address\nsince it was added to the nlHostTable (excluding\nframing bits, but including FCS octets), excluding\noctets in packets that contained errors.\n\nNote that this doesn't count just those octets in the particular\nprotocol frames but includes the entire packet that contained\nthe protocol.")
nlHostOutOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 14, 2, 1, 6), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlHostOutOctets.setDescription("The number of octets transmitted by this address\nsince it was added to the nlHostTable (excluding\nframing bits, but including FCS octets), excluding\noctets in packets that contained errors.\n\nNote that this doesn't count just those octets in the particular\nprotocol frames but includes the entire packet that contained\nthe protocol.")
nlHostOutMacNonUnicastPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 14, 2, 1, 7), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlHostOutMacNonUnicastPkts.setDescription("The number of packets without errors transmitted by this\naddress that were directed to any MAC broadcast addresses\nor to any MAC multicast addresses since this host was\nadded to the nlHostTable.  Note that this is the number of\nlink-layer packets, so if a single network-layer packet is\nfragmented into several link-layer frames, this counter is\nincremented several times.")
nlHostCreateTime = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 14, 2, 1, 8), LastCreateTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlHostCreateTime.setDescription("The value of sysUpTime when this entry was last activated.\nThis can be used by the management station to ensure that the\nentry has not been deleted and recreated between polls.")
nlMatrix = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 15))
hlMatrixControlTable = MibTable((1, 3, 6, 1, 2, 1, 16, 15, 1))
if mibBuilder.loadTexts: hlMatrixControlTable.setDescription("A list of higher-layer (i.e., non-MAC) matrix control entries.\n\nThese entries will enable the collection of the network- and\napplication-level matrix tables containing conversation\nstatistics indexed by pairs of network addresses.\nBoth the network- and application-level matrix tables are\ncontrolled by this table so that they will both be created\nand deleted at the same time, further increasing the ease with\nwhich they can be implemented as a single datastore.  (Note that\nif an implementation stores application-layer matrix records\n\n\n\nin memory, it can derive network-layer matrix records from\nthem.)\n\nEntries in the nlMatrixSDTable and nlMatrixDSTable will be\ncreated on behalf of each entry in this table.  Additionally,\nif this probe implements the alMatrix tables, entries in the\nalMatrix tables will be created on behalf of each entry in\nthis table.")
hlMatrixControlEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 15, 1, 1)).setIndexNames((0, "RMON2-MIB", "hlMatrixControlIndex"))
if mibBuilder.loadTexts: hlMatrixControlEntry.setDescription("A conceptual row in the hlMatrixControlTable.\n\nAn example of indexing of this entry is\nhlMatrixControlNlDroppedFrames.1")
hlMatrixControlIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: hlMatrixControlIndex.setDescription("An index that uniquely identifies an entry in the\nhlMatrixControlTable.  Each such entry defines\na function that discovers conversations on a particular\ninterface and places statistics about them in the\nnlMatrixSDTable and the nlMatrixDSTable, and optionally the\nalMatrixSDTable and alMatrixDSTable, on behalf of this\n\n\n\nhlMatrixControlEntry.")
hlMatrixControlDataSource = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 1, 1, 2), DataSource()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hlMatrixControlDataSource.setDescription("The source of the data for the associated matrix tables.\n\nThe statistics in this group reflect all packets\non the local network segment attached to the\nidentified interface.\n\nThis object may not be modified if the associated\nhlMatrixControlStatus object is equal to active(1).")
hlMatrixControlNlDroppedFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hlMatrixControlNlDroppedFrames.setDescription("The total number of frames that were received by the probe\nand therefore not accounted for in the *StatsDropEvents, but\nthat the probe chose not to count for this entry for\nwhatever reason.  Most often, this event occurs when the probe\nis out of some resources and decides to shed load from this\ncollection.\n\nThis count does not include packets that were not counted\nbecause they had MAC-layer errors.\n\nNote that if the nlMatrixTables are inactive because no\nprotocols are enabled in the protocol directory, this value\nshould be 0.\n\nNote that, unlike the dropEvents counter, this number is the\nexact number of frames dropped.")
hlMatrixControlNlInserts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hlMatrixControlNlInserts.setDescription("The number of times an nlMatrix entry has been\ninserted into the nlMatrix tables.  If an entry is inserted,\n\n\n\nthen deleted, and then inserted, this counter will be\nincremented by 2.  The addition of a conversation into both\nthe nlMatrixSDTable and nlMatrixDSTable shall be counted as\ntwo insertions (even though every addition into one table must\nbe accompanied by an insertion into the other).\n\nTo allow for efficient implementation strategies, agents may\ndelay updating this object for short periods of time.  For\nexample, an implementation strategy may allow internal\ndata structures to differ from those visible via SNMP for\nshort periods of time.  This counter may reflect the internal\ndata structures for those short periods of time.\n\nNote that the sum of then nlMatrixSDTable and nlMatrixDSTable\nsizes can be determined by subtracting\nhlMatrixControlNlDeletes from hlMatrixControlNlInserts.")
hlMatrixControlNlDeletes = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hlMatrixControlNlDeletes.setDescription("The number of times an nlMatrix entry has been\ndeleted from the nlMatrix tables (for any reason).  If an\nentry is deleted, then inserted, and then deleted, this\ncounter will be incremented by 2.  The deletion of a\nconversation from both the nlMatrixSDTable and nlMatrixDSTable\nshall be counted as two deletions (even though every deletion\nfrom one table must be accompanied by a deletion from the\nother).\n\nTo allow for efficient implementation strategies, agents may\ndelay updating this object for short periods of time.  For\nexample, an implementation strategy may allow internal\ndata structures to differ from those visible via SNMP for\nshort periods of time.  This counter may reflect the internal\ndata structures for those short periods of time.\n\nNote that the table size can be determined by subtracting\nhlMatrixControlNlDeletes from hlMatrixControlNlInserts.")
hlMatrixControlNlMaxDesiredEntries = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hlMatrixControlNlMaxDesiredEntries.setDescription("The maximum number of entries that are desired in the\nnlMatrix tables on behalf of this control entry.  The probe\nwill not create more than this number of associated entries in\nthe table but may choose to create fewer entries in this\ntable for any reason, including the lack of resources.\n\nIf this object is set to a value less than the current number\nof entries, enough entries are chosen in an\nimplementation-dependent manner and deleted so that the number\nof entries in the table equals the value of this object.\n\nIf this value is set to -1, the probe may create any number\nof entries in this table.  If the associated\nhlMatrixControlStatus object is equal to 'active', this\nobject may not be modified.\n\nThis object may be used to control how resources are allocated\non the probe for the various RMON functions.")
hlMatrixControlAlDroppedFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hlMatrixControlAlDroppedFrames.setDescription("The total number of frames that were received by the probe\nand therefore not accounted for in the *StatsDropEvents, but\nthat the probe chose not to count for this entry for\nwhatever reason.  Most often, this event occurs when the probe\nis out of some resources and decides to shed load from this\ncollection.\n\nThis count does not include packets that were not counted\nbecause they had MAC-layer errors.\n\nNote that if the alMatrixTables are not implemented or are\ninactive because no protocols are enabled in the protocol\ndirectory, this value should be 0.\n\nNote that, unlike the dropEvents counter, this number is the\nexact number of frames dropped.")
hlMatrixControlAlInserts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hlMatrixControlAlInserts.setDescription("The number of times an alMatrix entry has been\ninserted into the alMatrix tables.  If an entry is inserted,\nthen deleted, and then inserted, this counter will be\nincremented by 2.  The addition of a conversation into both\nthe alMatrixSDTable and alMatrixDSTable shall be counted as\ntwo insertions (even though every addition into one table must\nbe accompanied by an insertion into the other).\n\nTo allow for efficient implementation strategies, agents may\ndelay updating this object for short periods of time.  For\nexample, an implementation strategy may allow internal\ndata structures to differ from those visible via SNMP for\nshort periods of time.  This counter may reflect the internal\ndata structures for those short periods of time.\n\nNote that the table size can be determined by subtracting\nhlMatrixControlAlDeletes from hlMatrixControlAlInserts.")
hlMatrixControlAlDeletes = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hlMatrixControlAlDeletes.setDescription("The number of times an alMatrix entry has been\ndeleted from the alMatrix tables.  If an entry is deleted,\nthen inserted, and then deleted, this counter will be\nincremented by 2.  The deletion of a conversation from both\nthe alMatrixSDTable and alMatrixDSTable shall be counted as\ntwo deletions (even though every deletion from one table must\nbe accompanied by a deletion from the other).\n\nTo allow for efficient implementation strategies, agents may\ndelay updating this object for short periods of time.  For\nexample, an implementation strategy may allow internal\ndata structures to differ from those visible via SNMP for\nshort periods of time.  This counter may reflect the internal\ndata structures for those short periods of time.\n\nNote that the table size can be determined by subtracting\nhlMatrixControlAlDeletes from hlMatrixControlAlInserts.")
hlMatrixControlAlMaxDesiredEntries = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hlMatrixControlAlMaxDesiredEntries.setDescription("The maximum number of entries that are desired in the\nalMatrix tables on behalf of this control entry.  The probe\nwill not create more than this number of associated entries in\nthe table but may choose to create fewer entries in this\ntable for any reason, including the lack of resources.\n\nIf this object is set to a value less than the current number\nof entries, enough entries are chosen in an\nimplementation-dependent manner and deleted so that the number\nof entries in the table equals the value of this object.\n\nIf this value is set to -1, the probe may create any number\nof entries in this table.  If the associated\nhlMatrixControlStatus object is equal to 'active', this\nobject may not be modified.\n\nThis object may be used to control how resources are allocated\non the probe for the various RMON functions.")
hlMatrixControlOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 1, 1, 11), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hlMatrixControlOwner.setDescription("The entity that configured this entry and is\ntherefore using the resources assigned to it.")
hlMatrixControlStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 1, 1, 12), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hlMatrixControlStatus.setDescription("The status of this hlMatrixControlEntry.\n\nAn entry may not exist in the active state unless all\nobjects in the entry have an appropriate value.\n\nIf this object is not equal to active(1), all\nassociated entries in the nlMatrixSDTable,\nnlMatrixDSTable, alMatrixSDTable, and alMatrixDSTable\nshall be deleted by the agent.")
nlMatrixSDTable = MibTable((1, 3, 6, 1, 2, 1, 16, 15, 2))
if mibBuilder.loadTexts: nlMatrixSDTable.setDescription("A list of traffic matrix entries that collect statistics for\nconversations between two network-level addresses.  This table\nis indexed first by the source address and then by the\ndestination address to make it convenient to collect all\nconversations from a particular address.\n\nThe probe will populate this table for all network layer\nprotocols in the protocol directory table whose value of\nprotocolDirMatrixConfig is equal to supportedOn(3), and\nwill delete any entries whose protocolDirEntry is deleted or\nhas a protocolDirMatrixConfig value of supportedOff(2).\n\nThe probe will add to this table all pairs of addresses\nseen in all packets with no MAC errors and will increment\noctet and packet counts in the table for all packets with no\nMAC errors.\n\nFurther, this table will only contain entries that have a\ncorresponding entry in the nlMatrixDSTable with the same\nsource address and destination address.")
nlMatrixSDEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 15, 2, 1)).setIndexNames((0, "RMON2-MIB", "hlMatrixControlIndex"), (0, "RMON2-MIB", "nlMatrixSDTimeMark"), (0, "RMON2-MIB", "protocolDirLocalIndex"), (0, "RMON2-MIB", "nlMatrixSDSourceAddress"), (0, "RMON2-MIB", "nlMatrixSDDestAddress"))
if mibBuilder.loadTexts: nlMatrixSDEntry.setDescription("A conceptual row in the nlMatrixSDTable.\n\nThe hlMatrixControlIndex value in the index identifies the\nhlMatrixControlEntry on whose behalf this entry was created.\nThe protocolDirLocalIndex value in the index identifies the\nnetwork-layer protocol of the nlMatrixSDSourceAddress and\nnlMatrixSDDestAddress.\n\nAn example of the indexing of this table is\nnlMatrixSDPkts.1.783495.18.4.128.2.6.6.4.128.2.6.7.\n\nNote that some combinations of index values may result in an\nindex that exceeds 128 sub-identifiers in length, which exceeds\nthe maximum for the SNMP protocol.  Implementations should take\ncare to avoid such combinations.")
nlMatrixSDTimeMark = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 2, 1, 1), TimeFilter()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: nlMatrixSDTimeMark.setDescription("A TimeFilter for this entry.  See the TimeFilter textual\nconvention to see how this works.")
nlMatrixSDSourceAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: nlMatrixSDSourceAddress.setDescription("The network source address for this nlMatrixSDEntry.\n\nThis is represented as an octet string with\nspecific semantics and length as identified\nby the protocolDirLocalIndex component of the index.\n\nFor example, if the protocolDirLocalIndex indicates an\nencapsulation of IP, this object is encoded as a length\noctet of 4, followed by the 4 octets of the IP address,\nin network byte order.")
nlMatrixSDDestAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: nlMatrixSDDestAddress.setDescription("The network destination address for this\nnlMatrixSDEntry.\n\nThis is represented as an octet string with\nspecific semantics and length as identified\nby the protocolDirLocalIndex component of the index.\n\nFor example, if the protocolDirLocalIndex indicates an\n\n\n\nencapsulation of IP, this object is encoded as a length\noctet of 4, followed by the 4 octets of the IP address,\nin network byte order.")
nlMatrixSDPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 2, 1, 4), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixSDPkts.setDescription("The number of packets without errors transmitted from the\nsource address to the destination address since this entry was\nadded to the nlMatrixSDTable.  Note that this is the number of\nlink-layer packets, so if a single network-layer packet is\nfragmented into several link-layer frames, this counter is\nincremented several times.")
nlMatrixSDOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 2, 1, 5), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixSDOctets.setDescription("The number of octets transmitted from the source address to\nthe destination address since this entry was added to the\nnlMatrixSDTable (excluding framing bits, but\nincluding FCS octets), excluding octets in packets that\ncontained errors.\n\nNote that this doesn't count just those octets in the particular\nprotocol frames but includes the entire packet that contained\nthe protocol.")
nlMatrixSDCreateTime = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 2, 1, 6), LastCreateTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixSDCreateTime.setDescription("The value of sysUpTime when this entry was last activated.\nThis can be used by the management station to ensure that the\nentry has not been deleted and recreated between polls.")
nlMatrixDSTable = MibTable((1, 3, 6, 1, 2, 1, 16, 15, 3))
if mibBuilder.loadTexts: nlMatrixDSTable.setDescription("A list of traffic matrix entries that collect statistics for\nconversations between two network-level addresses.  This table\nis indexed first by the destination address and then by the\nsource address to make it convenient to collect all\nconversations to a particular address.\n\nThe probe will populate this table for all network layer\nprotocols in the protocol directory table whose value of\nprotocolDirMatrixConfig is equal to supportedOn(3), and\nwill delete any entries whose protocolDirEntry is deleted or\nhas a protocolDirMatrixConfig value of supportedOff(2).\n\nThe probe will add to this table all pairs of addresses\nseen in all packets with no MAC errors and will increment\noctet and packet counts in the table for all packets with no\nMAC errors.\n\nFurther, this table will only contain entries that have a\ncorresponding entry in the nlMatrixSDTable with the same\nsource address and destination address.")
nlMatrixDSEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 15, 3, 1)).setIndexNames((0, "RMON2-MIB", "hlMatrixControlIndex"), (0, "RMON2-MIB", "nlMatrixDSTimeMark"), (0, "RMON2-MIB", "protocolDirLocalIndex"), (0, "RMON2-MIB", "nlMatrixDSDestAddress"), (0, "RMON2-MIB", "nlMatrixDSSourceAddress"))
if mibBuilder.loadTexts: nlMatrixDSEntry.setDescription("A conceptual row in the nlMatrixDSTable.\n\nThe hlMatrixControlIndex value in the index identifies the\nhlMatrixControlEntry on whose behalf this entry was created.\nThe protocolDirLocalIndex value in the index identifies the\nnetwork-layer protocol of the nlMatrixDSSourceAddress and\nnlMatrixDSDestAddress.\n\nAn example of the indexing of this table is\nnlMatrixDSPkts.1.783495.18.4.128.2.6.7.4.128.2.6.6.\n\nNote that some combinations of index values may result in an\nindex that exceeds 128 sub-identifiers in length, which exceeds\nthe maximum for the SNMP protocol.  Implementations should take\ncare to avoid such combinations.")
nlMatrixDSTimeMark = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 3, 1, 1), TimeFilter()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: nlMatrixDSTimeMark.setDescription("A TimeFilter for this entry.  See the TimeFilter textual\nconvention to see how this works.")
nlMatrixDSSourceAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 3, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: nlMatrixDSSourceAddress.setDescription("The network source address for this nlMatrixDSEntry.\n\nThis is represented as an octet string with\nspecific semantics and length as identified\nby the protocolDirLocalIndex component of the index.\n\nFor example, if the protocolDirLocalIndex indicates an\nencapsulation of IP, this object is encoded as a length\noctet of 4, followed by the 4 octets of the IP address,\nin network byte order.")
nlMatrixDSDestAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 3, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: nlMatrixDSDestAddress.setDescription("The network destination address for this\nnlMatrixDSEntry.\n\nThis is represented as an octet string with\nspecific semantics and length as identified\n\n\n\nby the protocolDirLocalIndex component of the index.\n\nFor example, if the protocolDirLocalIndex indicates an\nencapsulation of IP, this object is encoded as a length\noctet of 4, followed by the 4 octets of the IP address,\nin network byte order.")
nlMatrixDSPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 3, 1, 4), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixDSPkts.setDescription("The number of packets without errors transmitted from the\nsource address to the destination address since this entry was\nadded to the nlMatrixDSTable.  Note that this is the number of\nlink-layer packets, so if a single network-layer packet is\nfragmented into several link-layer frames, this counter is\nincremented several times.")
nlMatrixDSOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 3, 1, 5), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixDSOctets.setDescription("The number of octets transmitted from the source address\nto the destination address since this entry was added to the\nnlMatrixDSTable (excluding framing bits, but\nincluding FCS octets), excluding octets in packets that\ncontained errors.\n\nNote that this doesn't count just those octets in the particular\nprotocol frames but includes the entire packet that contained\nthe protocol.")
nlMatrixDSCreateTime = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 3, 1, 6), LastCreateTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixDSCreateTime.setDescription("The value of sysUpTime when this entry was last activated.\nThis can be used by the management station to ensure that the\nentry has not been deleted and recreated between polls.")
nlMatrixTopNControlTable = MibTable((1, 3, 6, 1, 2, 1, 16, 15, 4))
if mibBuilder.loadTexts: nlMatrixTopNControlTable.setDescription("A set of parameters that control the creation of a\nreport of the top N matrix entries according to\na selected metric.")
nlMatrixTopNControlEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 15, 4, 1)).setIndexNames((0, "RMON2-MIB", "nlMatrixTopNControlIndex"))
if mibBuilder.loadTexts: nlMatrixTopNControlEntry.setDescription("A conceptual row in the nlMatrixTopNControlTable.\n\nAn example of the indexing of this table is\nnlMatrixTopNControlDuration.3")
nlMatrixTopNControlIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: nlMatrixTopNControlIndex.setDescription("An index that uniquely identifies an entry\nin the nlMatrixTopNControlTable.  Each such\nentry defines one topN report prepared for\none interface.")
nlMatrixTopNControlMatrixIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nlMatrixTopNControlMatrixIndex.setDescription("The nlMatrix[SD/DS] table for which a topN report will be\nprepared on behalf of this entry.  The nlMatrix[SD/DS] table\nis identified by the value of the hlMatrixControlIndex\nfor that table - that value is used here to identify the\nparticular table.\n\nThis object may not be modified if the associated\nnlMatrixTopNControlStatus object is equal to active(1).")
nlMatrixTopNControlRateBase = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 4, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(3,2,1,4,)).subtype(namedValues=NamedValues(("nlMatrixTopNPkts", 1), ("nlMatrixTopNOctets", 2), ("nlMatrixTopNHighCapacityPkts", 3), ("nlMatrixTopNHighCapacityOctets", 4), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nlMatrixTopNControlRateBase.setDescription("The variable for each nlMatrix[SD/DS] entry that the\nnlMatrixTopNEntries are sorted by, as well as a control\nfor the table that the results will be reported in.\n\nThis object may not be modified if the associated\nnlMatrixTopNControlStatus object is equal to active(1).\n\nIf this value is less than or equal to 2, when the report\nis prepared, entries are created in the nlMatrixTopNTable\nassociated with this object.\nIf this value is greater than or equal to 3, when the report\nis prepared, entries are created in the\nnlMatrixTopNHighCapacityTable associated with this object.")
nlMatrixTopNControlTimeRemaining = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(1800)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nlMatrixTopNControlTimeRemaining.setDescription("The number of seconds left in the report currently\nbeing collected.  When this object is modified by\nthe management station, a new collection is started,\npossibly aborting a currently running report.  The\nnew value is used as the requested duration of this\n\n\n\nreport and is immediately loaded into the associated\nnlMatrixTopNControlDuration object.\n\nWhen the report finishes, the probe will automatically\nstart another collection with the same initial value\nof nlMatrixTopNControlTimeRemaining.  Thus, the management\nstation may simply read the resulting reports repeatedly,\nchecking the startTime and duration each time to ensure that a\nreport was not missed or that the report parameters were not\nchanged.\n\nWhile the value of this object is non-zero, it decrements\nby one per second until it reaches zero.  At the time\nthat this object decrements to zero, the report is made\naccessible in the nlMatrixTopNTable, overwriting any report\nthat may be there.\n\nWhen this object is modified by the management station, any\nassociated entries in the nlMatrixTopNTable shall be deleted.\n\n(Note that this is a different algorithm than the one used\nin the hostTopNTable).")
nlMatrixTopNControlGeneratedReports = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixTopNControlGeneratedReports.setDescription("The number of reports that have been generated by this entry.")
nlMatrixTopNControlDuration = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 4, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixTopNControlDuration.setDescription("The number of seconds that this report has collected\nduring the last sampling interval.\n\nWhen the associated nlMatrixTopNControlTimeRemaining object is\nset, this object shall be set by the probe to the\nsame value and shall not be modified until the next\ntime the nlMatrixTopNControlTimeRemaining is set.\n\nThis value shall be zero if no reports have been\nrequested for this nlMatrixTopNControlEntry.")
nlMatrixTopNControlRequestedSize = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(150)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nlMatrixTopNControlRequestedSize.setDescription("The maximum number of matrix entries requested for this report.\n\nWhen this object is created or modified, the probe\nshould set nlMatrixTopNControlGrantedSize as closely to this\nobject as possible for the particular probe\nimplementation and available resources.")
nlMatrixTopNControlGrantedSize = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 4, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixTopNControlGrantedSize.setDescription("The maximum number of matrix entries in this report.\n\nWhen the associated nlMatrixTopNControlRequestedSize object is\ncreated or modified, the probe should set this\nobject as closely to the requested value as\npossible for the particular implementation and\navailable resources.  The probe must not lower this\nvalue except as a side-effect of a set to the associated\nnlMatrixTopNControlRequestedSize object.\n\nIf the value of nlMatrixTopNControlRateBase is equal to\nnlMatrixTopNPkts, when the next topN report is generated,\nmatrix entries with the highest value of nlMatrixTopNPktRate\nshall be placed in this table in decreasing order of this rate\nuntil there is no more room or until there are no more\nmatrix entries.\n\nIf the value of nlMatrixTopNControlRateBase is equal to\nnlMatrixTopNOctets, when the next topN report is generated,\nmatrix entries with the highest value of nlMatrixTopNOctetRate\nshall be placed in this table in decreasing order of this rate\nuntil there is no more room or until there are no more\nmatrix entries.\n\nIt is an implementation-specific matter how entries with the\nsame value of nlMatrixTopNPktRate or nlMatrixTopNOctetRate are\nsorted.  It is also an implementation-specific matter as to\n\n\n\nwhether zero-valued entries are available.")
nlMatrixTopNControlStartTime = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 4, 1, 9), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixTopNControlStartTime.setDescription("The value of sysUpTime when this topN report was\nlast started.  In other words, this is the time that\nthe associated nlMatrixTopNControlTimeRemaining object was\nmodified to start the requested report or the time\nthe report was last automatically (re)started.\n\nThis object may be used by the management station to\ndetermine whether a report was missed.")
nlMatrixTopNControlOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 4, 1, 10), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nlMatrixTopNControlOwner.setDescription("The entity that configured this entry and is\ntherefore using the resources assigned to it.")
nlMatrixTopNControlStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 4, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nlMatrixTopNControlStatus.setDescription("The status of this nlMatrixTopNControlEntry.\n\nAn entry may not exist in the active state unless all\nobjects in the entry have an appropriate value.\n\nIf this object is not equal to active(1), all\nassociated entries in the nlMatrixTopNTable shall be deleted\nby the agent.")
nlMatrixTopNTable = MibTable((1, 3, 6, 1, 2, 1, 16, 15, 5))
if mibBuilder.loadTexts: nlMatrixTopNTable.setDescription("A set of statistics for those network-layer matrix entries\n\n\n\nthat have counted the highest number of octets or packets.")
nlMatrixTopNEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 15, 5, 1)).setIndexNames((0, "RMON2-MIB", "nlMatrixTopNControlIndex"), (0, "RMON2-MIB", "nlMatrixTopNIndex"))
if mibBuilder.loadTexts: nlMatrixTopNEntry.setDescription("A conceptual row in the nlMatrixTopNTable.\n\nThe nlMatrixTopNControlIndex value in the index identifies the\nnlMatrixTopNControlEntry on whose behalf this entry was\ncreated.\n\nAn example of the indexing of this table is\nnlMatrixTopNPktRate.3.10")
nlMatrixTopNIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: nlMatrixTopNIndex.setDescription("An index that uniquely identifies an entry in\nthe nlMatrixTopNTable among those in the same report.\nThis index is between 1 and N, where N is the\nnumber of entries in this report.\n\nIf the value of nlMatrixTopNControlRateBase is equal to\nnlMatrixTopNPkts, increasing values of nlMatrixTopNIndex shall\nbe assigned to entries with decreasing values of\nnlMatrixTopNPktRate until index N is assigned or there are no\nmore nlMatrixTopNEntries.\n\nIf the value of nlMatrixTopNControlRateBase is equal to\nnlMatrixTopNOctets, increasing values of nlMatrixTopNIndex\n\n\n\nshall be assigned to entries with decreasing values of\nnlMatrixTopNOctetRate until index N is assigned or there are\nno more nlMatrixTopNEntries.")
nlMatrixTopNProtocolDirLocalIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixTopNProtocolDirLocalIndex.setDescription("The protocolDirLocalIndex of the network-layer protocol of\nthis entry's network address.")
nlMatrixTopNSourceAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 5, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixTopNSourceAddress.setDescription("The network-layer address of the source host in this\nconversation.\n\nThis is represented as an octet string with\nspecific semantics and length as identified\nby the associated nlMatrixTopNProtocolDirLocalIndex.\n\nFor example, if the protocolDirLocalIndex indicates an\nencapsulation of IP, this object is encoded as a length\noctet of 4, followed by the 4 octets of the IP address,\nin network byte order.")
nlMatrixTopNDestAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 5, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixTopNDestAddress.setDescription("The network-layer address of the destination host in this\nconversation.\n\nThis is represented as an octet string with\nspecific semantics and length as identified\nby the associated nlMatrixTopNProtocolDirLocalIndex.\n\nFor example, if the nlMatrixTopNProtocolDirLocalIndex\nindicates an encapsulation of IP, this object is encoded as a\nlength octet of 4, followed by the 4 octets of the IP address,\nin network byte order.")
nlMatrixTopNPktRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 5, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixTopNPktRate.setDescription("The number of packets seen from the source host\nto the destination host during this sampling interval, counted\nusing the rules for counting the nlMatrixSDPkts object.\nIf the value of nlMatrixTopNControlRateBase is\nnlMatrixTopNPkts, this variable will be used to sort this\nreport.")
nlMatrixTopNReversePktRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 5, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixTopNReversePktRate.setDescription("The number of packets seen from the destination host to the\nsource host during this sampling interval, counted\nusing the rules for counting the nlMatrixSDPkts object.  (Note\nthat the corresponding nlMatrixSDPkts object selected is the\none whose source address is equal to nlMatrixTopNDestAddress\nand whose destination address is equal to\nnlMatrixTopNSourceAddress.)\n\nNote that if the value of nlMatrixTopNControlRateBase is equal\nto nlMatrixTopNPkts, the sort of topN entries is based\nentirely on nlMatrixTopNPktRate, and not on the value of this\nobject.")
nlMatrixTopNOctetRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 5, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixTopNOctetRate.setDescription("The number of octets seen from the source host\nto the destination host during this sampling interval, counted\nusing the rules for counting the nlMatrixSDOctets object.  If\nthe value of nlMatrixTopNControlRateBase is\nnlMatrixTopNOctets, this variable will be used to sort this\nreport.")
nlMatrixTopNReverseOctetRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 15, 5, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlMatrixTopNReverseOctetRate.setDescription("The number of octets seen from the destination host to the\nsource host during this sampling interval, counted\nusing the rules for counting the nlMatrixDSOctets object.  (Note\nthat the corresponding nlMatrixSDOctets object selected is the\none whose source address is equal to nlMatrixTopNDestAddress\nand whose destination address is equal to\nnlMatrixTopNSourceAddress.)\n\nNote that if the value of nlMatrixTopNControlRateBase is equal\nto nlMatrixTopNOctets, the sort of topN entries is based\nentirely on nlMatrixTopNOctetRate, and not on the value of\nthis object.")
alHost = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 16))
alHostTable = MibTable((1, 3, 6, 1, 2, 1, 16, 16, 1))
if mibBuilder.loadTexts: alHostTable.setDescription("A collection of statistics for a particular protocol from a\nparticular network address that has been discovered on an\ninterface of this device.\n\nThe probe will populate this table for all protocols in the\nprotocol directory table whose value of\nprotocolDirHostConfig is equal to supportedOn(3), and\nwill delete any entries whose protocolDirEntry is deleted or\nhas a protocolDirHostConfig value of supportedOff(2).\n\n\n\nThe probe will add to this table all addresses\nseen as the source or destination address in all packets with\nno MAC errors and will increment octet and packet counts in\nthe table for all packets with no MAC errors.  Further,\nentries will only be added to this table if their address\nexists in the nlHostTable and will be deleted from this table\nif their address is deleted from the nlHostTable.")
alHostEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 16, 1, 1)).setIndexNames((0, "RMON2-MIB", "hlHostControlIndex"), (0, "RMON2-MIB", "alHostTimeMark"), (0, "RMON2-MIB", "protocolDirLocalIndex"), (0, "RMON2-MIB", "nlHostAddress"), (0, "RMON2-MIB", "protocolDirLocalIndex"))
if mibBuilder.loadTexts: alHostEntry.setDescription("A conceptual row in the alHostTable.\n\nThe hlHostControlIndex value in the index identifies the\nhlHostControlEntry on whose behalf this entry was created.\nThe first protocolDirLocalIndex value in the index identifies\nthe network-layer protocol of the address.\nThe nlHostAddress value in the index identifies the network-\nlayer address of this entry.\nThe second protocolDirLocalIndex value in the index identifies\nthe protocol that is counted by this entry.\n\nAn example of the indexing in this entry is\nalHostOutPkts.1.783495.18.4.128.2.6.6.34.\n\nNote that some combinations of index values may result in an\nindex that exceeds 128 sub-identifiers in length, which exceeds\nthe maximum for the SNMP protocol.  Implementations should take\ncare to avoid such combinations.")
alHostTimeMark = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 16, 1, 1, 1), TimeFilter()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: alHostTimeMark.setDescription("A TimeFilter for this entry.  See the TimeFilter textual\nconvention to see how this works.")
alHostInPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 16, 1, 1, 2), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alHostInPkts.setDescription("The number of packets of this protocol type without errors\ntransmitted to this address since it was added to the\nalHostTable.  Note that this is the number of link-layer\npackets, so if a single network-layer packet is fragmented\ninto several link-layer frames, this counter is incremented\nseveral times.")
alHostOutPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 16, 1, 1, 3), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alHostOutPkts.setDescription("The number of packets of this protocol type without errors\ntransmitted by this address since it was added to the\nalHostTable.  Note that this is the number of link-layer\npackets, so if a single network-layer packet is fragmented\ninto several link-layer frames, this counter is incremented\nseveral times.")
alHostInOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 16, 1, 1, 4), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alHostInOctets.setDescription("The number of octets transmitted to this address\nof this protocol type since it was added to the\nalHostTable (excluding framing bits, but including\nFCS octets), excluding octets in packets that\ncontained errors.\n\nNote that this doesn't count just those octets in the particular\nprotocol frames but includes the entire packet that contained\nthe protocol.")
alHostOutOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 16, 1, 1, 5), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alHostOutOctets.setDescription("The number of octets transmitted by this address\nof this protocol type since it was added to the\nalHostTable (excluding framing bits, but including\nFCS octets), excluding octets in packets that\ncontained errors.\n\nNote that this doesn't count just those octets in the particular\nprotocol frames but includes the entire packet that contained\nthe protocol.")
alHostCreateTime = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 16, 1, 1, 6), LastCreateTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alHostCreateTime.setDescription("The value of sysUpTime when this entry was last activated.\nThis can be used by the management station to ensure that the\nentry has not been deleted and recreated between polls.")
alMatrix = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 17))
alMatrixSDTable = MibTable((1, 3, 6, 1, 2, 1, 16, 17, 1))
if mibBuilder.loadTexts: alMatrixSDTable.setDescription("A list of application traffic matrix entries that collect\nstatistics for conversations of a particular protocol between\ntwo network-level addresses.  This table is indexed first by\nthe source address and then by the destination address to make\nit convenient to collect all statistics from a particular\naddress.\n\nThe probe will populate this table for all protocols in the\nprotocol directory table whose value of\n\n\n\nprotocolDirMatrixConfig is equal to supportedOn(3), and\nwill delete any entries whose protocolDirEntry is deleted or\nhas a protocolDirMatrixConfig value of supportedOff(2).\n\nThe probe will add to this table all pairs of addresses for\nall protocols seen in all packets with no MAC errors and will\nincrement octet and packet counts in the table for all packets\nwith no MAC errors.  Further, entries will only be added to\nthis table if their address pair exists in the nlMatrixSDTable\nand will be deleted from this table if the address pair is\ndeleted from the nlMatrixSDTable.")
alMatrixSDEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 17, 1, 1)).setIndexNames((0, "RMON2-MIB", "hlMatrixControlIndex"), (0, "RMON2-MIB", "alMatrixSDTimeMark"), (0, "RMON2-MIB", "protocolDirLocalIndex"), (0, "RMON2-MIB", "nlMatrixSDSourceAddress"), (0, "RMON2-MIB", "nlMatrixSDDestAddress"), (0, "RMON2-MIB", "protocolDirLocalIndex"))
if mibBuilder.loadTexts: alMatrixSDEntry.setDescription("A conceptual row in the alMatrixSDTable.\n\nThe hlMatrixControlIndex value in the index identifies the\nhlMatrixControlEntry on whose behalf this entry was created.\nThe first protocolDirLocalIndex value in the index identifies\nthe network-layer protocol of the nlMatrixSDSourceAddress and\nnlMatrixSDDestAddress.\nThe nlMatrixSDSourceAddress value in the index identifies the\nnetwork-layer address of the source host in this conversation.\nThe nlMatrixSDDestAddress value in the index identifies the\nnetwork-layer address of the destination host in this\nconversation.\nThe second protocolDirLocalIndex value in the index identifies\nthe protocol that is counted by this entry.\n\nAn example of the indexing of this entry is\nalMatrixSDPkts.1.783495.18.4.128.2.6.6.4.128.2.6.7.34.\n\nNote that some combinations of index values may result in an\nindex that exceeds 128 sub-identifiers in length, which exceeds\nthe maximum for the SNMP protocol.  Implementations should take\ncare to avoid such combinations.")
alMatrixSDTimeMark = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 1, 1, 1), TimeFilter()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: alMatrixSDTimeMark.setDescription("A TimeFilter for this entry.  See the TimeFilter textual\nconvention to see how this works.")
alMatrixSDPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 1, 1, 2), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixSDPkts.setDescription("The number of packets of this protocol type without errors\ntransmitted from the source address to the destination address\nsince this entry was added to the alMatrixSDTable.  Note that\nthis is the number of link-layer packets, so if a single\nnetwork-layer packet is fragmented into several link-layer\nframes, this counter is incremented several times.")
alMatrixSDOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 1, 1, 3), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixSDOctets.setDescription("The number of octets in packets of this protocol type\ntransmitted from the source address to the destination address\nsince this entry was added to the alMatrixSDTable (excluding\nframing bits, but including FCS octets), excluding octets\nin packets that contained errors.\n\nNote that this doesn't count just those octets in the particular\nprotocol frames but includes the entire packet that contained\nthe protocol.")
alMatrixSDCreateTime = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 1, 1, 4), LastCreateTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixSDCreateTime.setDescription("The value of sysUpTime when this entry was last activated.\nThis can be used by the management station to ensure that the\nentry has not been deleted and recreated between polls.")
alMatrixDSTable = MibTable((1, 3, 6, 1, 2, 1, 16, 17, 2))
if mibBuilder.loadTexts: alMatrixDSTable.setDescription("A list of application traffic matrix entries that collect\nstatistics for conversations of a particular protocol between\ntwo network-level addresses.  This table is indexed first by\nthe destination address and then by the source address to make\nit convenient to collect all statistics to a particular\naddress.\n\nThe probe will populate this table for all protocols in the\nprotocol directory table whose value of\nprotocolDirMatrixConfig is equal to supportedOn(3), and\nwill delete any entries whose protocolDirEntry is deleted or\nhas a protocolDirMatrixConfig value of supportedOff(2).\n\nThe probe will add to this table all pairs of addresses for\nall protocols seen in all packets with no MAC errors and will\nincrement octet and packet counts in the table for all packets\nwith no MAC errors.  Further, entries will only be added to\nthis table if their address pair exists in the nlMatrixDSTable\nand will be deleted from this table if the address pair is\ndeleted from the nlMatrixDSTable.")
alMatrixDSEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 17, 2, 1)).setIndexNames((0, "RMON2-MIB", "hlMatrixControlIndex"), (0, "RMON2-MIB", "alMatrixDSTimeMark"), (0, "RMON2-MIB", "protocolDirLocalIndex"), (0, "RMON2-MIB", "nlMatrixDSDestAddress"), (0, "RMON2-MIB", "nlMatrixDSSourceAddress"), (0, "RMON2-MIB", "protocolDirLocalIndex"))
if mibBuilder.loadTexts: alMatrixDSEntry.setDescription("A conceptual row in the alMatrixDSTable.\n\nThe hlMatrixControlIndex value in the index identifies the\nhlMatrixControlEntry on whose behalf this entry was created.\nThe first protocolDirLocalIndex value in the index identifies\nthe network-layer protocol of the alMatrixDSSourceAddress and\nalMatrixDSDestAddress.\nThe nlMatrixDSDestAddress value in the index identifies the\nnetwork-layer address of the destination host in this\n\n\n\nconversation.\nThe nlMatrixDSSourceAddress value in the index identifies the\nnetwork-layer address of the source host in this conversation.\nThe second protocolDirLocalIndex value in the index identifies\nthe protocol that is counted by this entry.\n\nAn example of the indexing of this entry is\nalMatrixDSPkts.1.783495.18.4.128.2.6.7.4.128.2.6.6.34.\n\nNote that some combinations of index values may result in an\nindex that exceeds 128 sub-identifiers in length, which exceeds\nthe maximum for the SNMP protocol.  Implementations should take\ncare to avoid such combinations.")
alMatrixDSTimeMark = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 2, 1, 1), TimeFilter()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: alMatrixDSTimeMark.setDescription("A TimeFilter for this entry.  See the TimeFilter textual\nconvention to see how this works.")
alMatrixDSPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 2, 1, 2), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixDSPkts.setDescription("The number of packets of this protocol type without errors\ntransmitted from the source address to the destination address\nsince this entry was added to the alMatrixDSTable.  Note that\nthis is the number of link-layer packets, so if a single\nnetwork-layer packet is fragmented into several link-layer\nframes, this counter is incremented several times.")
alMatrixDSOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 2, 1, 3), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixDSOctets.setDescription("The number of octets in packets of this protocol type\ntransmitted from the source address to the destination address\nsince this entry was added to the alMatrixDSTable (excluding\nframing bits, but including FCS octets), excluding octets\nin packets that contained errors.\n\nNote that this doesn't count just those octets in the particular\nprotocol frames but includes the entire packet that contained\nthe protocol.")
alMatrixDSCreateTime = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 2, 1, 4), LastCreateTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixDSCreateTime.setDescription("The value of sysUpTime when this entry was last activated.\nThis can be used by the management station to ensure that the\nentry has not been deleted and recreated between polls.")
alMatrixTopNControlTable = MibTable((1, 3, 6, 1, 2, 1, 16, 17, 3))
if mibBuilder.loadTexts: alMatrixTopNControlTable.setDescription("A set of parameters that control the creation of a\nreport of the top N matrix entries according to\na selected metric.")
alMatrixTopNControlEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 17, 3, 1)).setIndexNames((0, "RMON2-MIB", "alMatrixTopNControlIndex"))
if mibBuilder.loadTexts: alMatrixTopNControlEntry.setDescription("A conceptual row in the alMatrixTopNControlTable.\n\nAn example of the indexing of this table is\nalMatrixTopNControlDuration.3")
alMatrixTopNControlIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: alMatrixTopNControlIndex.setDescription("An index that uniquely identifies an entry\nin the alMatrixTopNControlTable.  Each such\nentry defines one topN report prepared for\none interface.")
alMatrixTopNControlMatrixIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: alMatrixTopNControlMatrixIndex.setDescription("The alMatrix[SD/DS] table for which a topN report will be\nprepared on behalf of this entry.  The alMatrix[SD/DS] table\nis identified by the value of the hlMatrixControlIndex\nfor that table - that value is used here to identify the\nparticular table.\n\nThis object may not be modified if the associated\nalMatrixTopNControlStatus object is equal to active(1).")
alMatrixTopNControlRateBase = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 3, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(6,1,4,7,3,8,2,5,)).subtype(namedValues=NamedValues(("alMatrixTopNTerminalsPkts", 1), ("alMatrixTopNTerminalsOctets", 2), ("alMatrixTopNAllPkts", 3), ("alMatrixTopNAllOctets", 4), ("alMatrixTopNTerminalsHighCapacityPkts", 5), ("alMatrixTopNTerminalsHighCapacityOctets", 6), ("alMatrixTopNAllHighCapacityPkts", 7), ("alMatrixTopNAllHighCapacityOctets", 8), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: alMatrixTopNControlRateBase.setDescription("This object controls which alMatrix[SD/DS] entry that the\nalMatrixTopNEntries are sorted by, which view of the matrix\ntable that will be used, as well as which table the results\nwill be reported in.\n\nThe values alMatrixTopNTerminalsPkts,\nalMatrixTopNTerminalsOctets,\nalMatrixTopNTerminalsHighCapacityPkts, and\nalMatrixTopNTerminalsHighCapacityOctets cause collection\nonly from protocols that have no child protocols that are\ncounted.  The values alMatrixTopNAllPkts,\nalMatrixTopNAllOctets, alMatrixTopNAllHighCapacityPkts, and\nalMatrixTopNAllHighCapacityOctets cause collection from all\nalMatrix entries.\n\nThis object may not be modified if the associated\nalMatrixTopNControlStatus object is equal to active(1).")
alMatrixTopNControlTimeRemaining = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(1800)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: alMatrixTopNControlTimeRemaining.setDescription("The number of seconds left in the report currently\nbeing collected.  When this object is modified by\nthe management station, a new collection is started,\npossibly aborting a currently running report.  The\nnew value is used as the requested duration of this\nreport and is immediately loaded into the associated\nalMatrixTopNControlDuration object.\n\nWhen the report finishes, the probe will automatically\nstart another collection with the same initial value\nof alMatrixTopNControlTimeRemaining.  Thus, the management\nstation may simply read the resulting reports repeatedly,\nchecking the startTime and duration each time to ensure that a\nreport was not missed or that the report parameters were not\nchanged.\n\nWhile the value of this object is non-zero, it decrements\nby one per second until it reaches zero.  At the time\n\n\n\nthat this object decrements to zero, the report is made\naccessible in the alMatrixTopNTable, overwriting any report\nthat may be there.\n\nWhen this object is modified by the management station, any\nassociated entries in the alMatrixTopNTable shall be deleted.\n\n(Note that this is a different algorithm than the one used\nin the hostTopNTable).")
alMatrixTopNControlGeneratedReports = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixTopNControlGeneratedReports.setDescription("The number of reports that have been generated by this entry.")
alMatrixTopNControlDuration = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 3, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixTopNControlDuration.setDescription("The number of seconds that this report has collected\nduring the last sampling interval.\n\nWhen the associated alMatrixTopNControlTimeRemaining object\nis set, this object shall be set by the probe to the\nsame value and shall not be modified until the next\ntime the alMatrixTopNControlTimeRemaining is set.\n\nThis value shall be zero if no reports have been\nrequested for this alMatrixTopNControlEntry.")
alMatrixTopNControlRequestedSize = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(150)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: alMatrixTopNControlRequestedSize.setDescription("The maximum number of matrix entries requested for this report.\n\nWhen this object is created or modified, the probe\nshould set alMatrixTopNControlGrantedSize as closely to this\nobject as possible for the particular probe\nimplementation and available resources.")
alMatrixTopNControlGrantedSize = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixTopNControlGrantedSize.setDescription("The maximum number of matrix entries in this report.\n\nWhen the associated alMatrixTopNControlRequestedSize object\nis created or modified, the probe should set this\nobject as closely to the requested value as\npossible for the particular implementation and\navailable resources. The probe must not lower this\nvalue except as a side-effect of a set to the associated\nalMatrixTopNControlRequestedSize object.\n\nIf the value of alMatrixTopNControlRateBase is equal to\nalMatrixTopNTerminalsPkts or alMatrixTopNAllPkts, when the\nnext topN report is generated, matrix entries with the highest\nvalue of alMatrixTopNPktRate shall be placed in this table in\ndecreasing order of this rate until there is no more room or\nuntil there are no more matrix entries.\n\nIf the value of alMatrixTopNControlRateBase is equal to\nalMatrixTopNTerminalsOctets or alMatrixTopNAllOctets, when the\nnext topN report is generated, matrix entries with the highest\nvalue of alMatrixTopNOctetRate shall be placed in this table\nin decreasing order of this rate until there is no more room\nor until there are no more matrix entries.\n\nIt is an implementation-specific matter how entries with the\nsame value of alMatrixTopNPktRate or alMatrixTopNOctetRate are\nsorted.  It is also an implementation-specific matter as to\nwhether zero-valued entries are available.")
alMatrixTopNControlStartTime = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 3, 1, 9), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixTopNControlStartTime.setDescription("The value of sysUpTime when this topN report was\nlast started.  In other words, this is the time that\nthe associated alMatrixTopNControlTimeRemaining object\nwas modified to start the requested report or the time\nthe report was last automatically (re)started.\n\n\n\nThis object may be used by the management station to\ndetermine whether a report was missed.")
alMatrixTopNControlOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 3, 1, 10), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: alMatrixTopNControlOwner.setDescription("The entity that configured this entry and is\ntherefore using the resources assigned to it.")
alMatrixTopNControlStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 3, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: alMatrixTopNControlStatus.setDescription("The status of this alMatrixTopNControlEntry.\n\nAn entry may not exist in the active state unless all\nobjects in the entry have an appropriate value.\n\nIf this object is not equal to active(1), all\nassociated entries in the alMatrixTopNTable shall be\ndeleted by the agent.")
alMatrixTopNTable = MibTable((1, 3, 6, 1, 2, 1, 16, 17, 4))
if mibBuilder.loadTexts: alMatrixTopNTable.setDescription("A set of statistics for those application-layer matrix\nentries that have counted the highest number of octets or\npackets.")
alMatrixTopNEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 17, 4, 1)).setIndexNames((0, "RMON2-MIB", "alMatrixTopNControlIndex"), (0, "RMON2-MIB", "alMatrixTopNIndex"))
if mibBuilder.loadTexts: alMatrixTopNEntry.setDescription("A conceptual row in the alMatrixTopNTable.\n\nThe alMatrixTopNControlIndex value in the index identifies\nthe alMatrixTopNControlEntry on whose behalf this entry was\ncreated.\n\n\n\nAn example of the indexing of this table is\nalMatrixTopNPktRate.3.10")
alMatrixTopNIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: alMatrixTopNIndex.setDescription("An index that uniquely identifies an entry in\nthe alMatrixTopNTable among those in the same report.\n\nThis index is between 1 and N, where N is the\nnumber of entries in this report.\n\nIf the value of alMatrixTopNControlRateBase is equal to\nalMatrixTopNTerminalsPkts or alMatrixTopNAllPkts, increasing\nvalues of alMatrixTopNIndex shall be assigned to entries with\ndecreasing values of alMatrixTopNPktRate until index N is\nassigned or there are no more alMatrixTopNEntries.\n\nIf the value of alMatrixTopNControlRateBase is equal to\nalMatrixTopNTerminalsOctets or alMatrixTopNAllOctets,\nincreasing values of alMatrixTopNIndex shall be assigned to\nentries with decreasing values of alMatrixTopNOctetRate until\nindex N is assigned or there are no more alMatrixTopNEntries.")
alMatrixTopNProtocolDirLocalIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixTopNProtocolDirLocalIndex.setDescription("The protocolDirLocalIndex of the network-layer protocol of\nthis entry's network address.")
alMatrixTopNSourceAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 4, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixTopNSourceAddress.setDescription("The network-layer address of the source host in this\nconversation.\n\nThis is represented as an octet string with\nspecific semantics and length as identified\nby the associated alMatrixTopNProtocolDirLocalIndex.\n\nFor example, if the alMatrixTopNProtocolDirLocalIndex\nindicates an encapsulation of IP, this object is encoded as a\nlength octet of 4, followed by the 4 octets of the IP address,\nin network byte order.")
alMatrixTopNDestAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 4, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixTopNDestAddress.setDescription("The network-layer address of the destination host in this\nconversation.\n\nThis is represented as an octet string with\nspecific semantics and length as identified\nby the associated alMatrixTopNProtocolDirLocalIndex.\n\nFor example, if the alMatrixTopNProtocolDirLocalIndex\nindicates an encapsulation of IP, this object is encoded as a\nlength octet of 4, followed by the 4 octets of the IP address,\nin network byte order.")
alMatrixTopNAppProtocolDirLocalIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixTopNAppProtocolDirLocalIndex.setDescription("The type of the protocol counted by this matrix entry.")
alMatrixTopNPktRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 4, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixTopNPktRate.setDescription("The number of packets seen of this protocol from the source\nhost to the destination host during this sampling interval,\ncounted using the rules for counting the alMatrixSDPkts\nobject.\n\nIf the value of alMatrixTopNControlRateBase is\nalMatrixTopNTerminalsPkts or alMatrixTopNAllPkts, this\nvariable will be used to sort this report.")
alMatrixTopNReversePktRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 4, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixTopNReversePktRate.setDescription("The number of packets seen of this protocol from the\ndestination host to the source host during this sampling\ninterval, counted using the rules for counting the\nalMatrixDSPkts object.  (Note that the corresponding\nalMatrixSDPkts object selected is the one whose source address\nis equal to alMatrixTopNDestAddress and whose destination\naddress is equal to alMatrixTopNSourceAddress.)\n\nNote that if the value of alMatrixTopNControlRateBase is equal\nto alMatrixTopNTerminalsPkts or alMatrixTopNAllPkts, the sort\nof topN entries is based entirely on alMatrixTopNPktRate, and\nnot on the value of this object.")
alMatrixTopNOctetRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 4, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixTopNOctetRate.setDescription("The number of octets seen of this protocol from the source\nhost to the destination host during this sampling interval,\ncounted using the rules for counting the alMatrixSDOctets\nobject.\n\nIf the value of alMatrixTopNControlRateBase is\nalMatrixTopNTerminalsOctets or alMatrixTopNAllOctets, this\nvariable will be used to sort this report.")
alMatrixTopNReverseOctetRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 17, 4, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alMatrixTopNReverseOctetRate.setDescription("The number of octets seen of this protocol from the\ndestination host to the source host during this sampling\ninterval, counted using the rules for counting the\nalMatrixDSOctets object.  (Note that the corresponding\nalMatrixSDOctets object selected is the one whose source\naddress is equal to alMatrixTopNDestAddress and whose\ndestination address is equal to alMatrixTopNSourceAddress.)\n\nNote that if the value of alMatrixTopNControlRateBase is equal\nto alMatrixTopNTerminalsOctets or alMatrixTopNAllOctets, the\nsort of topN entries is based entirely on\nalMatrixTopNOctetRate, and not on the value of this object.")
usrHistory = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 18))
usrHistoryControlTable = MibTable((1, 3, 6, 1, 2, 1, 16, 18, 1))
if mibBuilder.loadTexts: usrHistoryControlTable.setDescription("A list of data-collection configuration entries.")
usrHistoryControlEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 18, 1, 1)).setIndexNames((0, "RMON2-MIB", "usrHistoryControlIndex"))
if mibBuilder.loadTexts: usrHistoryControlEntry.setDescription("A list of parameters that set up a group of user-defined\nMIB objects to be sampled periodically (called a\nbucket-group).\n\nFor example, an instance of usrHistoryControlInterval\nmight be named usrHistoryControlInterval.1")
usrHistoryControlIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 18, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: usrHistoryControlIndex.setDescription("An index that uniquely identifies an entry in the\nusrHistoryControlTable.  Each such entry defines a\nset of samples at a particular interval for a specified\nset of MIB instances available from the managed system.")
usrHistoryControlObjects = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 18, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: usrHistoryControlObjects.setDescription("The number of MIB objects to be collected\nin the portion of usrHistoryTable associated with this\nusrHistoryControlEntry.\n\nThis object may not be modified if the associated instance\nof usrHistoryControlStatus is equal to active(1).")
usrHistoryControlBucketsRequested = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 18, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(50)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: usrHistoryControlBucketsRequested.setDescription("The requested number of discrete time intervals\nover which data is to be saved in the part of the\nusrHistoryTable associated with this usrHistoryControlEntry.\n\nWhen this object is created or modified, the probe\nshould set usrHistoryControlBucketsGranted as closely to\nthis object as possible for the particular probe\nimplementation and available resources.")
usrHistoryControlBucketsGranted = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 18, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: usrHistoryControlBucketsGranted.setDescription("The number of discrete sampling intervals\nover which data shall be saved in the part of\nthe usrHistoryTable associated with this\nusrHistoryControlEntry.\n\nWhen the associated usrHistoryControlBucketsRequested\nobject is created or modified, the probe should set\nthis object as closely to the requested value as\npossible for the particular probe implementation and\navailable resources.  The probe must not lower this\nvalue except as a result of a modification to the associated\nusrHistoryControlBucketsRequested object.\n\nThe associated usrHistoryControlBucketsRequested object\nshould be set before or at the same time as this object\nto allow the probe to accurately estimate the resources\nrequired for this usrHistoryControlEntry.\n\nThere will be times when the actual number of buckets\nassociated with this entry is less than the value of\nthis object.  In this case, at the end of each sampling\ninterval, a new bucket will be added to the usrHistoryTable.\n\nWhen the number of buckets reaches the value of this object\nand a new bucket is to be added to the usrHistoryTable,\nthe oldest bucket associated with this usrHistoryControlEntry\nshall be deleted by the agent so that the new bucket can be\nadded.\n\nWhen the value of this object changes to a value less than\nthe current value, entries are deleted from the\nusrHistoryTable associated with this usrHistoryControlEntry.\nEnough of the oldest of these entries shall be deleted by the\nagent so that their number remains less than or equal to the\nnew value of this object.\n\nWhen the value of this object changes to a value greater\nthan the current value, the number of associated usrHistory\nentries may be allowed to grow.")
usrHistoryControlInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 18, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)).clone(1800)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: usrHistoryControlInterval.setDescription("The interval in seconds over which the data is\nsampled for each bucket in the part of the usrHistory\ntable associated with this usrHistoryControlEntry.\n\nBecause the counters in a bucket may overflow at their\nmaximum value with no indication, a prudent manager will\ntake into account the possibility of overflow in any of\nthe associated counters.  It is important to consider the\nminimum time in which any counter could overflow on a\nparticular media type and to set the usrHistoryControlInterval\nobject to a value less than this interval.\n\nThis object may not be modified if the associated\nusrHistoryControlStatus object is equal to active(1).")
usrHistoryControlOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 18, 1, 1, 6), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: usrHistoryControlOwner.setDescription("The entity that configured this entry and is\ntherefore using the resources assigned to it.")
usrHistoryControlStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 18, 1, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: usrHistoryControlStatus.setDescription("The status of this variable history control entry.\n\nAn entry may not exist in the active state unless all\nobjects in the entry have an appropriate value.\n\nIf this object is not equal to active(1), all associated\nentries in the usrHistoryTable shall be deleted.")
usrHistoryObjectTable = MibTable((1, 3, 6, 1, 2, 1, 16, 18, 2))
if mibBuilder.loadTexts: usrHistoryObjectTable.setDescription("A list of data-collection configuration entries.")
usrHistoryObjectEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 18, 2, 1)).setIndexNames((0, "RMON2-MIB", "usrHistoryControlIndex"), (0, "RMON2-MIB", "usrHistoryObjectIndex"))
if mibBuilder.loadTexts: usrHistoryObjectEntry.setDescription("A list of MIB instances to be sampled periodically.\n\nEntries in this table are created when an associated\nusrHistoryControlObjects object is created.\n\nThe usrHistoryControlIndex value in the index is\nthat of the associated usrHistoryControlEntry.\n\nFor example, an instance of usrHistoryObjectVariable might be\nusrHistoryObjectVariable.1.3")
usrHistoryObjectIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 18, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: usrHistoryObjectIndex.setDescription("An index used to uniquely identify an entry in the\nusrHistoryObject table.  Each such entry defines a\nMIB instance to be collected periodically.")
usrHistoryObjectVariable = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 18, 2, 1, 2), ObjectIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: usrHistoryObjectVariable.setDescription("The object identifier of the particular variable to be\n\n\n\nsampled.\n\nOnly variables that resolve to an ASN.1 primitive type of\nInteger32 (Integer32, Counter, Gauge, or TimeTicks) may be\nsampled.\n\nBecause SNMP access control is articulated entirely in terms\nof the contents of MIB views, no access control mechanism\nexists that can restrict the value of this object to identify\nonly those objects that exist in a particular MIB view.\nBecause there is thus no acceptable means of restricting the\nread access that could be obtained through the user history\nmechanism, the probe must only grant write access to this\nobject in those views that have read access to all objects on\nthe probe.  See USM [RFC3414] and VACM [RFC3415] for more\ninformation.\n\nDuring a set operation, if the supplied variable name is not\navailable in the selected MIB view, a badValue error must be\nreturned.\n\nThis object may not be modified if the associated\nusrHistoryControlStatus object is equal to active(1).")
usrHistoryObjectSampleType = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 18, 2, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("absoluteValue", 1), ("deltaValue", 2), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: usrHistoryObjectSampleType.setDescription("The method of sampling the selected variable for storage in\nthe usrHistoryTable.\n\nIf the value of this object is absoluteValue(1), the value of\nthe selected variable will be copied directly into the history\nbucket.\n\nIf the value of this object is deltaValue(2), the value of the\nselected variable at the last sample will be subtracted from\nthe current value, and the difference will be stored in the\nhistory bucket.  If the associated usrHistoryObjectVariable\ninstance could not be obtained at the previous sample\ninterval, then a delta sample is not possible, and the value\nof the associated usrHistoryValStatus object for this interval\nwill be valueNotAvailable(1).\n\n\n\nThis object may not be modified if the associated\nusrHistoryControlStatus object is equal to active(1).")
usrHistoryTable = MibTable((1, 3, 6, 1, 2, 1, 16, 18, 3))
if mibBuilder.loadTexts: usrHistoryTable.setDescription("A list of user-defined history entries.")
usrHistoryEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 18, 3, 1)).setIndexNames((0, "RMON2-MIB", "usrHistoryControlIndex"), (0, "RMON2-MIB", "usrHistorySampleIndex"), (0, "RMON2-MIB", "usrHistoryObjectIndex"))
if mibBuilder.loadTexts: usrHistoryEntry.setDescription("A historical sample of user-defined variables.  This sample\nis associated with the usrHistoryControlEntry that set up the\nparameters for a regular collection of these samples.\n\nThe usrHistoryControlIndex value in the index identifies the\nusrHistoryControlEntry on whose behalf this entry was created.\nThe usrHistoryObjectIndex value in the index identifies the\nusrHistoryObjectEntry on whose behalf this entry was created.\n\nFor example, an instance of usrHistoryAbsValue, which represents\nthe 14th sample of a variable collected as specified by\nusrHistoryControlEntry.1 and usrHistoryObjectEntry.1.5,\nwould be named usrHistoryAbsValue.1.14.5")
usrHistorySampleIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 18, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: usrHistorySampleIndex.setDescription("An index that uniquely identifies the particular sample this\nentry represents among all samples associated with the same\nusrHistoryControlEntry.  This index starts at 1 and increases\nby one as each new sample is taken.")
usrHistoryIntervalStart = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 18, 3, 1, 2), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: usrHistoryIntervalStart.setDescription("The value of sysUpTime at the start of the interval over\nwhich this sample was measured.  If the probe keeps track of\nthe time of day, it should start the first sample of the\nhistory at a time such that when the next hour of the day\nbegins, a sample is started at that instant.\n\nNote that following this rule may require that the probe delay\ncollecting the first sample of the history, as each sample\nmust be of the same interval.  Also note that the sample that\nis currently being collected is not accessible in this table\nuntil the end of its interval.")
usrHistoryIntervalEnd = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 18, 3, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: usrHistoryIntervalEnd.setDescription("The value of sysUpTime at the end of the interval over which\nthis sample was measured.")
usrHistoryAbsValue = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 18, 3, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: usrHistoryAbsValue.setDescription("The absolute value (i.e., unsigned value) of the\nuser-specified statistic during the last sampling period.  The\nvalue during the current sampling period is not made available\nuntil the period is completed.\n\nTo obtain the true value for this sampling interval, the\nassociated instance of usrHistoryValStatus must be checked,\nand usrHistoryAbsValue adjusted as necessary.\n\n\n\n\nIf the MIB instance could not be accessed during the sampling\ninterval, then this object will have a value of zero, and the\nassociated instance of usrHistoryValStatus will be set to\n'valueNotAvailable(1)'.\n\nThe access control check prescribed in the definition of\nusrHistoryObjectVariable SHOULD be checked for each sampling\ninterval.  If this check determines that access should not be\nallowed, then this object will have a value of zero, and the\nassociated instance of usrHistoryValStatus will be set to\n'valueNotAvailable(1)'.")
usrHistoryValStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 18, 3, 1, 5), Integer().subtype(subtypeSpec=SingleValueConstraint(2,3,1,)).subtype(namedValues=NamedValues(("valueNotAvailable", 1), ("valuePositive", 2), ("valueNegative", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: usrHistoryValStatus.setDescription("This object indicates the validity and sign of the data in\nthe associated instance of usrHistoryAbsValue.\n\nIf the MIB instance could not be accessed during the sampling\ninterval, then 'valueNotAvailable(1)' will be returned.\n\nIf the sample is valid and the actual value of the sample is\ngreater than or equal to zero, then 'valuePositive(2)' is\nreturned.\n\nIf the sample is valid and the actual value of the sample is\nless than zero, 'valueNegative(3)' will be returned.  The\nassociated instance of usrHistoryAbsValue should be multiplied\nby -1 to obtain the true sample value.")
probeConfig = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 19))
probeCapabilities = MibScalar((1, 3, 6, 1, 2, 1, 16, 19, 1), Bits().subtype(namedValues=NamedValues(("etherStats", 0), ("historyControl", 1), ("tokenRingMLStats", 10), ("tokenRingPStats", 11), ("tokenRingMLHistory", 12), ("tokenRingPHistory", 13), ("ringStation", 14), ("ringStationOrder", 15), ("ringStationConfig", 16), ("sourceRouting", 17), ("protocolDirectory", 18), ("protocolDistribution", 19), ("etherHistory", 2), ("addressMapping", 20), ("nlHost", 21), ("nlMatrix", 22), ("alHost", 23), ("alMatrix", 24), ("usrHistory", 25), ("probeConfig", 26), ("alarm", 3), ("hosts", 4), ("hostTopN", 5), ("matrix", 6), ("filter", 7), ("capture", 8), ("event", 9), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: probeCapabilities.setDescription("An indication of the RMON MIB groups supported\non at least one interface by this probe.")
probeSoftwareRev = MibScalar((1, 3, 6, 1, 2, 1, 16, 19, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: probeSoftwareRev.setDescription("The software revision of this device.  This string will have\na zero length if the revision is unknown.")
probeHardwareRev = MibScalar((1, 3, 6, 1, 2, 1, 16, 19, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: probeHardwareRev.setDescription("The hardware revision of this device.  This string will have\na zero length if the revision is unknown.")
probeDateTime = MibScalar((1, 3, 6, 1, 2, 1, 16, 19, 4), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0,0),ValueSizeConstraint(8,8),ValueSizeConstraint(11,11),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: probeDateTime.setDescription("Probe's current date and time.\n\nfield  octets  contents                  range\n-----  ------  --------                  -----\n  1      1-2   year                      0..65536\n  2       3    month                     1..12\n  3       4    day                       1..31\n  4       5    hour                      0..23\n  5       6    minutes                   0..59\n  6       7    seconds                   0..60\n                (use 60 for leap-second)\n  7       8    deci-seconds              0..9\n  8       9    direction from UTC        '+' / '-'\n  9      10    hours from UTC            0..11\n 10      11    minutes from UTC          0..59\n\nFor example, Tuesday May 26, 1992 at 1:30:15 PM\nEDT would be displayed as:\n\n            1992-5-26,13:30:15.0,-4:0\n\nNote that if only local time is known, then\ntime zone information (fields 8-10) is not\npresent, and that if no time information is known, the\nnull string is returned.")
probeResetControl = MibScalar((1, 3, 6, 1, 2, 1, 16, 19, 5), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,3,)).subtype(namedValues=NamedValues(("running", 1), ("warmBoot", 2), ("coldBoot", 3), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: probeResetControl.setDescription("Setting this object to warmBoot(2) causes the device to\nrestart the application software with current configuration\nparameters saved in non-volatile memory.  Setting this\nobject to coldBoot(3) causes the device to reinitialize\nconfiguration parameters in non-volatile memory to default\nvalues and to restart the application software.  When the device\nis running normally, this variable has a value of\nrunning(1).")
probeDownloadFile = MibScalar((1, 3, 6, 1, 2, 1, 16, 19, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: probeDownloadFile.setDescription("The file name to be downloaded from the TFTP server when a\ndownload is next requested via this MIB.  This value is set to\nthe zero-length string when no file name has been specified.\n\nThis object has been deprecated, as it has not had enough\nindependent implementations to demonstrate interoperability to\nmeet the requirements of a Draft Standard.")
probeDownloadTFTPServer = MibScalar((1, 3, 6, 1, 2, 1, 16, 19, 7), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: probeDownloadTFTPServer.setDescription("The IP address of the TFTP server that contains the boot\nimage to load when a download is next requested via this MIB.\nThis value is set to '0.0.0.0' when no IP address has been\n\n\n\nspecified.\n\nThis object has been deprecated, as it has not had enough\nindependent implementations to demonstrate interoperability to\nmeet the requirements of a Draft Standard.")
probeDownloadAction = MibScalar((1, 3, 6, 1, 2, 1, 16, 19, 8), Integer().subtype(subtypeSpec=SingleValueConstraint(2,3,1,)).subtype(namedValues=NamedValues(("notDownloading", 1), ("downloadToPROM", 2), ("downloadToRAM", 3), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: probeDownloadAction.setDescription("When this object is set to downloadToRAM(3) or\ndownloadToPROM(2), the device will discontinue its\nnormal operation and begin download of the image specified\nby probeDownloadFile from the server specified by\nprobeDownloadTFTPServer using the TFTP protocol.  If\ndownloadToRAM(3) is specified, the new image is copied\nto RAM only (the old image remains unaltered in the flash\nEPROM).  If downloadToPROM(2) is specified,\nthe new image is written to the flash EPROM\nmemory after its checksum has been verified to be correct.\nWhen the download process is completed, the device will\nwarm boot to restart the newly loaded application.\nWhen the device is not downloading, this object will have\na value of notDownloading(1).\n\nThis object has been deprecated, as it has not had enough\nindependent implementations to demonstrate interoperability to\nmeet the requirements of a Draft Standard.")
probeDownloadStatus = MibScalar((1, 3, 6, 1, 2, 1, 16, 19, 9), Integer().subtype(subtypeSpec=SingleValueConstraint(4,3,2,8,6,5,1,7,)).subtype(namedValues=NamedValues(("downloadSuccess", 1), ("downloadStatusUnknown", 2), ("downloadGeneralError", 3), ("downloadNoResponseFromServer", 4), ("downloadChecksumError", 5), ("downloadIncompatibleImage", 6), ("downloadTftpFileNotFound", 7), ("downloadTftpAccessViolation", 8), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: probeDownloadStatus.setDescription("The status of the last download procedure, if any.  This\nobject will have a value of downloadStatusUnknown(2) if no\ndownload process has been performed.\n\nThis object has been deprecated, as it has not had enough\nindependent implementations to demonstrate interoperability to\nmeet the requirements of a Draft Standard.")
serialConfigTable = MibTable((1, 3, 6, 1, 2, 1, 16, 19, 10))
if mibBuilder.loadTexts: serialConfigTable.setDescription("A table of serial interface configuration entries.  This data\nwill be stored in non-volatile memory and preserved across\nprobe resets or power loss.\n\nThis table has been deprecated, as it has not had enough\nindependent implementations to demonstrate interoperability to\nmeet the requirements of a Draft Standard.")
serialConfigEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 19, 10, 1)).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: serialConfigEntry.setDescription("A set of configuration parameters for a particular\nserial interface on this device.  If the device has no serial\ninterfaces, this table is empty.\n\nThe index is composed of the ifIndex assigned to this serial\nline interface.")
serialMode = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 19, 10, 1, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("direct", 1), ("modem", 2), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: serialMode.setDescription("The type of incoming connection to be expected on this\nserial interface.")
serialProtocol = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 19, 10, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(3,1,2,)).subtype(namedValues=NamedValues(("other", 1), ("slip", 2), ("ppp", 3), )).clone(2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: serialProtocol.setDescription("The type of data link encapsulation to be used on this\nserial interface.")
serialTimeout = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 19, 10, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(300)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: serialTimeout.setDescription("This timeout value is used when the Management Station has\ninitiated the conversation over the serial link.  This variable\nrepresents the number of seconds of inactivity allowed before\nterminating the connection on this serial interface.  Use the\nserialDialoutTimeout in the case where the probe has initiated\nthe connection for the purpose of sending a trap.")
serialModemInitString = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 19, 10, 1, 4), ControlString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: serialModemInitString.setDescription("A control string that controls how a modem attached to this\nserial interface should be initialized.  The initialization\nis performed once during startup and again after each\nconnection is terminated if the associated serialMode has the\nvalue of modem(2).\n\nA control string that is appropriate for a wide variety of\nmodems is: '^s^MATE0Q0V1X4 S0=1 S2=43^M'.")
serialModemHangUpString = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 19, 10, 1, 5), ControlString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: serialModemHangUpString.setDescription("A control string that specifies how to disconnect a modem\nconnection on this serial interface.  This object is only\nmeaningful if the associated serialMode has the value\nof modem(2).\n\nA control string that is appropriate for a wide variety of\nmodems is: '^d2^s+++^d2^sATH0^M^d2'.")
serialModemConnectResp = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 19, 10, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: serialModemConnectResp.setDescription("An ASCII string containing substrings that describe the\nexpected modem connection response code and associated bps\nrate.  The substrings are delimited by the first character\nin the string, for example:\n   /CONNECT/300/CONNECT 1200/1200/CONNECT 2400/2400/\n   CONNECT 4800/4800/CONNECT 9600/9600\nwill be interpreted as:\n    response code    bps rate\n    CONNECT            300\n    CONNECT 1200      1200\n    CONNECT 2400      2400\n    CONNECT 4800      4800\n    CONNECT 9600      9600\nThe agent will use the information in this string to adjust\nthe bps rate of this serial interface once a modem connection\nis established.\n\nA value that is appropriate for a wide variety of modems is:\n\n\n\n'/CONNECT/300/CONNECT 1200/1200/CONNECT 2400/2400/\n CONNECT 4800/4800/CONNECT 9600/9600/CONNECT 14400/14400/\nCONNECT 19200/19200/CONNECT 38400/38400/'.")
serialModemNoConnectResp = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 19, 10, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: serialModemNoConnectResp.setDescription("An ASCII string containing response codes that may be\ngenerated by a modem to report the reason why a connection\nattempt has failed.  The response codes are delimited by\nthe first character in the string, for example:\n   /NO CARRIER/BUSY/NO DIALTONE/NO ANSWER/ERROR/\n\nIf one of these response codes is received via this serial\ninterface while attempting to make a modem connection,\nthe agent will issue the hang up command as specified by\nserialModemHangUpString.\n\nA value that is appropriate for a wide variety of modems is:\n'/NO CARRIER/BUSY/NO DIALTONE/NO ANSWER/ERROR/'.")
serialDialoutTimeout = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 19, 10, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(20)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: serialDialoutTimeout.setDescription("This timeout value is used when the probe initiates the\nserial connection with the intention of contacting a\nmanagement station.  This variable represents the number\nof seconds of inactivity allowed before terminating the\nconnection on this serial interface.")
serialStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 19, 10, 1, 9), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: serialStatus.setDescription("The status of this serialConfigEntry.\n\nAn entry may not exist in the active state unless all\nobjects in the entry have an appropriate value.")
netConfigTable = MibTable((1, 3, 6, 1, 2, 1, 16, 19, 11))
if mibBuilder.loadTexts: netConfigTable.setDescription("A table of netConfigEntries.\n\nThis table has been deprecated, as it has not had enough\nindependent implementations to demonstrate interoperability to\nmeet the requirements of a Draft Standard.")
netConfigEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 19, 11, 1)).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: netConfigEntry.setDescription("A set of configuration parameters for a particular\nnetwork interface on this device.  If the device has no network\ninterface, this table is empty.\n\nThe index is composed of the ifIndex assigned to the\ncorresponding interface.")
netConfigIPAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 19, 11, 1, 1), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: netConfigIPAddress.setDescription("The IP address of this Net interface.  The default value\nfor this object is 0.0.0.0.  If either the netConfigIPAddress\nor netConfigSubnetMask is 0.0.0.0, then when the device\nboots, it may use BOOTP to try to figure out what these\nvalues should be.  If BOOTP fails before the device\ncan talk on the network, this value must be configured\n(e.g., through a terminal attached to the device).  If BOOTP is\nused, care should be taken to not send BOOTP broadcasts too\nfrequently and to eventually send them very infrequently if no\nreplies are received.")
netConfigSubnetMask = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 19, 11, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: netConfigSubnetMask.setDescription("The subnet mask of this Net interface.  The default value\nfor this object is 0.0.0.0.  If either the netConfigIPAddress\nor netConfigSubnetMask is 0.0.0.0, then when the device\nboots, it may use BOOTP to try to figure out what these\nvalues should be.  If BOOTP fails before the device\ncan talk on the network, this value must be configured\n(e.g., through a terminal attached to the device).  If BOOTP is\nused, care should be taken to not send BOOTP broadcasts too\nfrequently and to eventually send them very infrequently if no\nreplies are received.")
netConfigStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 19, 11, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: netConfigStatus.setDescription("The status of this netConfigEntry.\n\nAn entry may not exist in the active state unless all\nobjects in the entry have an appropriate value.")
netDefaultGateway = MibScalar((1, 3, 6, 1, 2, 1, 16, 19, 12), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netDefaultGateway.setDescription("The IP Address of the default gateway.  If this value is\nundefined or unknown, it shall have the value 0.0.0.0.")
trapDestTable = MibTable((1, 3, 6, 1, 2, 1, 16, 19, 13))
if mibBuilder.loadTexts: trapDestTable.setDescription("A list of trap destination entries.")
trapDestEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 19, 13, 1)).setIndexNames((0, "RMON2-MIB", "trapDestIndex"))
if mibBuilder.loadTexts: trapDestEntry.setDescription("This entry includes a destination IP address to which\ntraps are sent for this community.")
trapDestIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 19, 13, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: trapDestIndex.setDescription("A value that uniquely identifies this trapDestEntry.")
trapDestCommunity = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 19, 13, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: trapDestCommunity.setDescription("A community to which this destination address belongs.\nThis entry is associated with any eventEntries in the RMON\nMIB whose value of eventCommunity is equal to the value of\nthis object.  Every time an associated event entry sends a\ntrap due to an event, that trap will be sent to each\n\n\n\naddress in the trapDestTable with a trapDestCommunity equal\nto eventCommunity, as long as no access control mechanism\nprecludes it (e.g., VACM).\n\nThis object may not be modified if the associated\ntrapDestStatus object is equal to active(1).")
trapDestProtocol = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 19, 13, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("ip", 1), ("ipx", 2), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: trapDestProtocol.setDescription("The protocol with which this trap is to be sent.")
trapDestAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 19, 13, 1, 4), OctetString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: trapDestAddress.setDescription("The destination address for traps on behalf of this entry.\n\nIf the associated trapDestProtocol object is equal to ip(1),\nthe encoding of this object is the same as the snmpUDPAddress\ntextual convention in RFC 3417, 'Transport Mappings for the\n Simple Network Management Protocol (SNMP)' [RFC3417]:\n  -- for a SnmpUDPAddress of length 6:\n  --\n  -- octets   contents        encoding\n  --  1-4     IP-address      network-byte order\n  --  5-6     UDP-port        network-byte order\n\nIf the associated trapDestProtocol object is equal to ipx(2),\nthe encoding of this object is the same as the snmpIPXAddress\ntextual convention in RFC 3417, 'Transport Mappings for the\n Simple Network Management Protocol (SNMP)' [RFC3417]:\n  -- for a SnmpIPXAddress of length 12:\n  --\n  -- octets   contents            encoding\n  --  1-4     network-number      network-byte order\n  --  5-10    physical-address    network-byte order\n  -- 11-12    socket-number       network-byte order\n\nThis object may not be modified if the associated\n\n\n\ntrapDestStatus object is equal to active(1).")
trapDestOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 19, 13, 1, 5), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: trapDestOwner.setDescription("The entity that configured this entry and is\ntherefore using the resources assigned to it.")
trapDestStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 19, 13, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: trapDestStatus.setDescription("The status of this trap destination entry.\n\nAn entry may not exist in the active state unless all\nobjects in the entry have an appropriate value.")
serialConnectionTable = MibTable((1, 3, 6, 1, 2, 1, 16, 19, 14))
if mibBuilder.loadTexts: serialConnectionTable.setDescription("A list of serialConnectionEntries.\n\nThis table has been deprecated, as it has not had enough\nindependent implementations to demonstrate interoperability\nto meet the requirements of a Draft Standard.")
serialConnectionEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 19, 14, 1)).setIndexNames((0, "RMON2-MIB", "serialConnectIndex"))
if mibBuilder.loadTexts: serialConnectionEntry.setDescription("Configuration for a SLIP link over a serial line.")
serialConnectIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 19, 14, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: serialConnectIndex.setDescription("A value that uniquely identifies this serialConnection\nentry.")
serialConnectDestIpAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 19, 14, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: serialConnectDestIpAddress.setDescription("The IP Address that can be reached at the other end of this\nserial connection.\n\nThis object may not be modified if the associated\nserialConnectStatus object is equal to active(1).")
serialConnectType = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 19, 14, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(4,3,2,1,)).subtype(namedValues=NamedValues(("direct", 1), ("modem", 2), ("switch", 3), ("modemSwitch", 4), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: serialConnectType.setDescription("The type of outgoing connection to be made.  If this object\nhas the value direct(1), then a direct serial connection\nis assumed.  If this object has the value modem(2),\nthen serialConnectDialString will be used to make a modem\nconnection.  If this object has the value switch(3),\nthen serialConnectSwitchConnectSeq will be used to establish\nthe connection over a serial data switch, and\nserialConnectSwitchDisconnectSeq will be used to terminate\nthe connection.  If this object has the value\nmodem-switch(4), then a modem connection will be made first,\nfollowed by the switch connection.\n\nThis object may not be modified if the associated\nserialConnectStatus object is equal to active(1).")
serialConnectDialString = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 19, 14, 1, 4), ControlString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: serialConnectDialString.setDescription("A control string that specifies how to dial the phone\nnumber in order to establish a modem connection.  The\nstring should include the dialing prefix and suffix.  For\nexample: '^s^MATD9,888-1234^M' will instruct the Probe\nto send a carriage return, followed by the dialing prefix\n'ATD', the phone number '9,888-1234', and a carriage\nreturn as the dialing suffix.\n\nThis object may not be modified if the associated\nserialConnectStatus object is equal to active(1).")
serialConnectSwitchConnectSeq = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 19, 14, 1, 5), ControlString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: serialConnectSwitchConnectSeq.setDescription("A control string that specifies how to establish a\ndata switch connection.\n\nThis object may not be modified if the associated\nserialConnectStatus object is equal to active(1).")
serialConnectSwitchDisconnectSeq = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 19, 14, 1, 6), ControlString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: serialConnectSwitchDisconnectSeq.setDescription("A control string that specifies how to terminate a\ndata switch connection.\n\nThis object may not be modified if the associated\nserialConnectStatus object is equal to active(1).")
serialConnectSwitchResetSeq = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 19, 14, 1, 7), ControlString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: serialConnectSwitchResetSeq.setDescription("A control string that specifies how to reset a data\nswitch in the event of a timeout.\n\nThis object may not be modified if the associated\nserialConnectStatus object is equal to active(1).")
serialConnectOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 19, 14, 1, 8), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: serialConnectOwner.setDescription("The entity that configured this entry and is\ntherefore using the resources assigned to it.")
serialConnectStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 19, 14, 1, 9), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: serialConnectStatus.setDescription("The status of this serialConnectionEntry.\n\nIf the manager attempts to set this object to active(1) when\nthe serialConnectType is set to modem(2) or modem-switch(4)\nand the serialConnectDialString is a zero-length string or\ncannot be correctly parsed as a ConnectString, the set\nrequest will be rejected with badValue(3).\n\nIf the manager attempts to set this object to active(1) when\nthe serialConnectType is set to switch(3) or modem-switch(4)\nand the serialConnectSwitchConnectSeq,\nthe serialConnectSwitchDisconnectSeq, or\n\n\n\nthe serialConnectSwitchResetSeq is a zero-length string\nor cannot be correctly parsed as a ConnectString, the set\nrequest will be rejected with badValue(3).\n\nAn entry may not exist in the active state unless all\nobjects in the entry have an appropriate value.")
rmonConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 20))
rmon2MIBCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 20, 1))
rmon2MIBGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 20, 2))

# Augmentions
sourceRoutingStatsEntry, = mibBuilder.importSymbols("TOKEN-RING-RMON-MIB", "sourceRoutingStatsEntry")
sourceRoutingStatsEntry.registerAugmentions(("RMON2-MIB", "sourceRoutingStats2Entry"))
sourceRoutingStats2Entry.setIndexNames(*sourceRoutingStatsEntry.getIndexNames())
historyControlEntry, = mibBuilder.importSymbols("RMON-MIB", "historyControlEntry")
historyControlEntry.registerAugmentions(("RMON2-MIB", "historyControl2Entry"))
historyControl2Entry.setIndexNames(*historyControlEntry.getIndexNames())
ringStationControlEntry, = mibBuilder.importSymbols("TOKEN-RING-RMON-MIB", "ringStationControlEntry")
ringStationControlEntry.registerAugmentions(("RMON2-MIB", "ringStationControl2Entry"))
ringStationControl2Entry.setIndexNames(*ringStationControlEntry.getIndexNames())
filterEntry, = mibBuilder.importSymbols("RMON-MIB", "filterEntry")
filterEntry.registerAugmentions(("RMON2-MIB", "filter2Entry"))
filter2Entry.setIndexNames(*filterEntry.getIndexNames())
matrixControlEntry, = mibBuilder.importSymbols("RMON-MIB", "matrixControlEntry")
matrixControlEntry.registerAugmentions(("RMON2-MIB", "matrixControl2Entry"))
matrixControl2Entry.setIndexNames(*matrixControlEntry.getIndexNames())
hostControlEntry, = mibBuilder.importSymbols("RMON-MIB", "hostControlEntry")
hostControlEntry.registerAugmentions(("RMON2-MIB", "hostControl2Entry"))
hostControl2Entry.setIndexNames(*hostControlEntry.getIndexNames())
tokenRingMLStatsEntry, = mibBuilder.importSymbols("TOKEN-RING-RMON-MIB", "tokenRingMLStatsEntry")
tokenRingMLStatsEntry.registerAugmentions(("RMON2-MIB", "tokenRingMLStats2Entry"))
tokenRingMLStats2Entry.setIndexNames(*tokenRingMLStatsEntry.getIndexNames())
tokenRingPStatsEntry, = mibBuilder.importSymbols("TOKEN-RING-RMON-MIB", "tokenRingPStatsEntry")
tokenRingPStatsEntry.registerAugmentions(("RMON2-MIB", "tokenRingPStats2Entry"))
tokenRingPStats2Entry.setIndexNames(*tokenRingPStatsEntry.getIndexNames())
etherStatsEntry, = mibBuilder.importSymbols("RMON-MIB", "etherStatsEntry")
etherStatsEntry.registerAugmentions(("RMON2-MIB", "etherStats2Entry"))
etherStats2Entry.setIndexNames(*etherStatsEntry.getIndexNames())
channelEntry, = mibBuilder.importSymbols("RMON-MIB", "channelEntry")
channelEntry.registerAugmentions(("RMON2-MIB", "channel2Entry"))
channel2Entry.setIndexNames(*channelEntry.getIndexNames())

# Groups

protocolDirectoryGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 2, 1)).setObjects(*(("RMON2-MIB", "protocolDirLastChange"), ("RMON2-MIB", "protocolDirDescr"), ("RMON2-MIB", "protocolDirStatus"), ("RMON2-MIB", "protocolDirAddressMapConfig"), ("RMON2-MIB", "protocolDirHostConfig"), ("RMON2-MIB", "protocolDirOwner"), ("RMON2-MIB", "protocolDirMatrixConfig"), ("RMON2-MIB", "protocolDirType"), ("RMON2-MIB", "protocolDirLocalIndex"), ) )
if mibBuilder.loadTexts: protocolDirectoryGroup.setDescription("Lists the inventory of protocols the probe has the\ncapability of monitoring and allows the addition, deletion,\nand configuration of entries in this list.")
protocolDistributionGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 2, 2)).setObjects(*(("RMON2-MIB", "protocolDistControlDroppedFrames"), ("RMON2-MIB", "protocolDistControlCreateTime"), ("RMON2-MIB", "protocolDistControlStatus"), ("RMON2-MIB", "protocolDistControlDataSource"), ("RMON2-MIB", "protocolDistStatsOctets"), ("RMON2-MIB", "protocolDistStatsPkts"), ("RMON2-MIB", "protocolDistControlOwner"), ) )
if mibBuilder.loadTexts: protocolDistributionGroup.setDescription("Collects the relative amounts of octets and packets for the\ndifferent protocols detected on a network segment.")
addressMapGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 2, 3)).setObjects(*(("RMON2-MIB", "addressMapControlDroppedFrames"), ("RMON2-MIB", "addressMapDeletes"), ("RMON2-MIB", "addressMapInserts"), ("RMON2-MIB", "addressMapControlStatus"), ("RMON2-MIB", "addressMapControlDataSource"), ("RMON2-MIB", "addressMapPhysicalAddress"), ("RMON2-MIB", "addressMapControlOwner"), ("RMON2-MIB", "addressMapMaxDesiredEntries"), ("RMON2-MIB", "addressMapLastChange"), ) )
if mibBuilder.loadTexts: addressMapGroup.setDescription("Lists MAC address to network address bindings discovered by\nthe probe and what interface they were last seen on.")
nlHostGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 2, 4)).setObjects(*(("RMON2-MIB", "hlHostControlOwner"), ("RMON2-MIB", "hlHostControlNlMaxDesiredEntries"), ("RMON2-MIB", "hlHostControlNlDeletes"), ("RMON2-MIB", "hlHostControlStatus"), ("RMON2-MIB", "hlHostControlNlDroppedFrames"), ("RMON2-MIB", "nlHostOutOctets"), ("RMON2-MIB", "hlHostControlNlInserts"), ("RMON2-MIB", "nlHostCreateTime"), ("RMON2-MIB", "hlHostControlDataSource"), ("RMON2-MIB", "nlHostInOctets"), ("RMON2-MIB", "nlHostOutPkts"), ("RMON2-MIB", "hlHostControlAlDroppedFrames"), ("RMON2-MIB", "nlHostOutMacNonUnicastPkts"), ("RMON2-MIB", "nlHostInPkts"), ("RMON2-MIB", "hlHostControlAlInserts"), ("RMON2-MIB", "hlHostControlAlDeletes"), ("RMON2-MIB", "hlHostControlAlMaxDesiredEntries"), ) )
if mibBuilder.loadTexts: nlHostGroup.setDescription("Counts the amount of traffic sent from and to each network\naddress discovered by the probe.  Note that while the\nhlHostControlTable also has objects that control an optional\nalHostTable, implementation of the alHostTable is not\nrequired to fully implement this group.")
nlMatrixGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 2, 5)).setObjects(*(("RMON2-MIB", "nlMatrixDSPkts"), ("RMON2-MIB", "hlMatrixControlNlMaxDesiredEntries"), ("RMON2-MIB", "nlMatrixTopNControlDuration"), ("RMON2-MIB", "nlMatrixTopNControlOwner"), ("RMON2-MIB", "nlMatrixTopNControlMatrixIndex"), ("RMON2-MIB", "nlMatrixTopNControlStatus"), ("RMON2-MIB", "nlMatrixTopNControlRequestedSize"), ("RMON2-MIB", "nlMatrixSDCreateTime"), ("RMON2-MIB", "hlMatrixControlNlDeletes"), ("RMON2-MIB", "hlMatrixControlAlMaxDesiredEntries"), ("RMON2-MIB", "nlMatrixTopNControlStartTime"), ("RMON2-MIB", "hlMatrixControlDataSource"), ("RMON2-MIB", "hlMatrixControlAlDroppedFrames"), ("RMON2-MIB", "hlMatrixControlNlInserts"), ("RMON2-MIB", "hlMatrixControlAlDeletes"), ("RMON2-MIB", "hlMatrixControlNlDroppedFrames"), ("RMON2-MIB", "hlMatrixControlOwner"), ("RMON2-MIB", "nlMatrixTopNControlTimeRemaining"), ("RMON2-MIB", "nlMatrixTopNControlGrantedSize"), ("RMON2-MIB", "nlMatrixSDPkts"), ("RMON2-MIB", "nlMatrixTopNDestAddress"), ("RMON2-MIB", "nlMatrixDSCreateTime"), ("RMON2-MIB", "nlMatrixDSOctets"), ("RMON2-MIB", "nlMatrixTopNReverseOctetRate"), ("RMON2-MIB", "nlMatrixSDOctets"), ("RMON2-MIB", "hlMatrixControlAlInserts"), ("RMON2-MIB", "nlMatrixTopNProtocolDirLocalIndex"), ("RMON2-MIB", "nlMatrixTopNOctetRate"), ("RMON2-MIB", "nlMatrixTopNReversePktRate"), ("RMON2-MIB", "nlMatrixTopNControlGeneratedReports"), ("RMON2-MIB", "nlMatrixTopNControlRateBase"), ("RMON2-MIB", "nlMatrixTopNSourceAddress"), ("RMON2-MIB", "nlMatrixTopNPktRate"), ("RMON2-MIB", "hlMatrixControlStatus"), ) )
if mibBuilder.loadTexts: nlMatrixGroup.setDescription("Counts the amount of traffic sent between each pair of\nnetwork addresses discovered by the probe.  Note that while\nthe hlMatrixControlTable also has objects that control\noptional alMatrixTables, implementation of the\nalMatrixTables is not required to fully implement this\ngroup.")
alHostGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 2, 6)).setObjects(*(("RMON2-MIB", "alHostOutOctets"), ("RMON2-MIB", "alHostCreateTime"), ("RMON2-MIB", "alHostOutPkts"), ("RMON2-MIB", "alHostInPkts"), ("RMON2-MIB", "alHostInOctets"), ) )
if mibBuilder.loadTexts: alHostGroup.setDescription("Counts the amount of traffic, by protocol, sent from and to\neach network address discovered by the probe.  Implementation\nof this group requires implementation of the Network-Layer\nHost Group.")
alMatrixGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 2, 7)).setObjects(*(("RMON2-MIB", "alMatrixDSPkts"), ("RMON2-MIB", "alMatrixTopNDestAddress"), ("RMON2-MIB", "alMatrixTopNControlGrantedSize"), ("RMON2-MIB", "alMatrixTopNReversePktRate"), ("RMON2-MIB", "alMatrixDSCreateTime"), ("RMON2-MIB", "alMatrixTopNControlStatus"), ("RMON2-MIB", "alMatrixDSOctets"), ("RMON2-MIB", "alMatrixTopNAppProtocolDirLocalIndex"), ("RMON2-MIB", "alMatrixTopNControlRequestedSize"), ("RMON2-MIB", "alMatrixSDOctets"), ("RMON2-MIB", "alMatrixTopNSourceAddress"), ("RMON2-MIB", "alMatrixTopNControlRateBase"), ("RMON2-MIB", "alMatrixSDPkts"), ("RMON2-MIB", "alMatrixTopNControlOwner"), ("RMON2-MIB", "alMatrixTopNControlDuration"), ("RMON2-MIB", "alMatrixTopNControlMatrixIndex"), ("RMON2-MIB", "alMatrixTopNControlStartTime"), ("RMON2-MIB", "alMatrixTopNReverseOctetRate"), ("RMON2-MIB", "alMatrixSDCreateTime"), ("RMON2-MIB", "alMatrixTopNOctetRate"), ("RMON2-MIB", "alMatrixTopNControlGeneratedReports"), ("RMON2-MIB", "alMatrixTopNPktRate"), ("RMON2-MIB", "alMatrixTopNProtocolDirLocalIndex"), ("RMON2-MIB", "alMatrixTopNControlTimeRemaining"), ) )
if mibBuilder.loadTexts: alMatrixGroup.setDescription("Counts the amount of traffic, by protocol, sent between each\npair of network addresses discovered by the\nprobe.  Implementation of this group requires implementation\nof the Network-Layer Matrix Group.")
usrHistoryGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 2, 8)).setObjects(*(("RMON2-MIB", "usrHistoryObjectVariable"), ("RMON2-MIB", "usrHistoryIntervalStart"), ("RMON2-MIB", "usrHistoryControlInterval"), ("RMON2-MIB", "usrHistoryControlStatus"), ("RMON2-MIB", "usrHistoryAbsValue"), ("RMON2-MIB", "usrHistoryControlBucketsRequested"), ("RMON2-MIB", "usrHistoryObjectSampleType"), ("RMON2-MIB", "usrHistoryControlBucketsGranted"), ("RMON2-MIB", "usrHistoryControlObjects"), ("RMON2-MIB", "usrHistoryValStatus"), ("RMON2-MIB", "usrHistoryIntervalEnd"), ("RMON2-MIB", "usrHistoryControlOwner"), ) )
if mibBuilder.loadTexts: usrHistoryGroup.setDescription("The usrHistoryGroup provides user-defined collection of\nhistorical information from MIB objects on the probe.")
probeInformationGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 2, 9)).setObjects(*(("RMON2-MIB", "probeDateTime"), ("RMON2-MIB", "probeSoftwareRev"), ("RMON2-MIB", "probeCapabilities"), ("RMON2-MIB", "probeHardwareRev"), ) )
if mibBuilder.loadTexts: probeInformationGroup.setDescription("This group describes various operating parameters of the\nprobe and controls the local time of the probe.")
probeConfigurationGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 2, 10)).setObjects(*(("RMON2-MIB", "serialStatus"), ("RMON2-MIB", "trapDestCommunity"), ("RMON2-MIB", "netConfigStatus"), ("RMON2-MIB", "serialModemConnectResp"), ("RMON2-MIB", "serialConnectSwitchResetSeq"), ("RMON2-MIB", "serialConnectSwitchDisconnectSeq"), ("RMON2-MIB", "netDefaultGateway"), ("RMON2-MIB", "trapDestAddress"), ("RMON2-MIB", "serialDialoutTimeout"), ("RMON2-MIB", "serialModemInitString"), ("RMON2-MIB", "probeResetControl"), ("RMON2-MIB", "serialMode"), ("RMON2-MIB", "serialConnectStatus"), ("RMON2-MIB", "serialProtocol"), ("RMON2-MIB", "trapDestProtocol"), ("RMON2-MIB", "netConfigIPAddress"), ("RMON2-MIB", "serialConnectOwner"), ("RMON2-MIB", "serialTimeout"), ("RMON2-MIB", "serialModemNoConnectResp"), ("RMON2-MIB", "probeDownloadStatus"), ("RMON2-MIB", "serialModemHangUpString"), ("RMON2-MIB", "trapDestStatus"), ("RMON2-MIB", "probeDownloadAction"), ("RMON2-MIB", "probeDownloadFile"), ("RMON2-MIB", "netConfigSubnetMask"), ("RMON2-MIB", "serialConnectDialString"), ("RMON2-MIB", "serialConnectSwitchConnectSeq"), ("RMON2-MIB", "serialConnectDestIpAddress"), ("RMON2-MIB", "trapDestOwner"), ("RMON2-MIB", "probeDownloadTFTPServer"), ("RMON2-MIB", "serialConnectType"), ) )
if mibBuilder.loadTexts: probeConfigurationGroup.setDescription("This group controls the configuration of various operating\nparameters of the probe.  This group is not referenced by any\nMODULE-COMPLIANCE macro because it is 'grandfathered' from\nmore recent MIB review rules that would require it.")
rmon1EnhancementGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 2, 11)).setObjects(*(("RMON2-MIB", "matrixControlDroppedFrames"), ("RMON2-MIB", "filterProtocolDirDataLocalIndex"), ("RMON2-MIB", "matrixControlCreateTime"), ("RMON2-MIB", "channelDroppedFrames"), ("RMON2-MIB", "historyControlDroppedFrames"), ("RMON2-MIB", "channelCreateTime"), ("RMON2-MIB", "hostControlDroppedFrames"), ("RMON2-MIB", "filterProtocolDirLocalIndex"), ("RMON2-MIB", "hostControlCreateTime"), ) )
if mibBuilder.loadTexts: rmon1EnhancementGroup.setDescription("This group adds some enhancements to RMON-1 that help\nmanagement stations.")
rmon1EthernetEnhancementGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 2, 12)).setObjects(*(("RMON2-MIB", "etherStatsDroppedFrames"), ("RMON2-MIB", "etherStatsCreateTime"), ) )
if mibBuilder.loadTexts: rmon1EthernetEnhancementGroup.setDescription("This group adds some enhancements to RMON-1 that help\nmanagement stations.")
rmon1TokenRingEnhancementGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 2, 13)).setObjects(*(("RMON2-MIB", "ringStationControlDroppedFrames"), ("RMON2-MIB", "sourceRoutingStatsDroppedFrames"), ("RMON2-MIB", "tokenRingPStatsDroppedFrames"), ("RMON2-MIB", "tokenRingMLStatsCreateTime"), ("RMON2-MIB", "tokenRingMLStatsDroppedFrames"), ("RMON2-MIB", "ringStationControlCreateTime"), ("RMON2-MIB", "tokenRingPStatsCreateTime"), ("RMON2-MIB", "sourceRoutingStatsCreateTime"), ) )
if mibBuilder.loadTexts: rmon1TokenRingEnhancementGroup.setDescription("This group adds some enhancements to RMON-1 that help\nmanagement stations.  This group is not referenced by any\nMODULE-COMPLIANCE macro because it is 'grandfathered' from\nmore recent MIB review rules that would require it.")

# Compliances

rmon2MIBCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 16, 20, 1, 1)).setObjects(*(("RMON2-MIB", "probeInformationGroup"), ("RMON2-MIB", "rmon1EthernetEnhancementGroup"), ("RMON2-MIB", "protocolDirectoryGroup"), ("RMON2-MIB", "rmon1EnhancementGroup"), ("RMON2-MIB", "usrHistoryGroup"), ("RMON2-MIB", "protocolDistributionGroup"), ("RMON2-MIB", "addressMapGroup"), ("RMON2-MIB", "nlHostGroup"), ("RMON2-MIB", "nlMatrixGroup"), ) )
if mibBuilder.loadTexts: rmon2MIBCompliance.setDescription("Describes the requirements for conformance to\nthe RMON2 MIB")
rmon2MIBApplicationLayerCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 16, 20, 1, 2)).setObjects(*(("RMON2-MIB", "alMatrixGroup"), ("RMON2-MIB", "rmon1EthernetEnhancementGroup"), ("RMON2-MIB", "nlMatrixGroup"), ("RMON2-MIB", "usrHistoryGroup"), ("RMON2-MIB", "probeInformationGroup"), ("RMON2-MIB", "alHostGroup"), ("RMON2-MIB", "protocolDirectoryGroup"), ("RMON2-MIB", "rmon1EnhancementGroup"), ("RMON2-MIB", "addressMapGroup"), ("RMON2-MIB", "protocolDistributionGroup"), ("RMON2-MIB", "nlHostGroup"), ) )
if mibBuilder.loadTexts: rmon2MIBApplicationLayerCompliance.setDescription("Describes the requirements for conformance to\nthe RMON2 MIB with Application-Layer Enhancements.")

# Exports

# Module identity
mibBuilder.exportSymbols("RMON2-MIB", PYSNMP_MODULE_ID=rmon)

# Types
mibBuilder.exportSymbols("RMON2-MIB", ControlString=ControlString, DataSource=DataSource, LastCreateTime=LastCreateTime, TimeFilter=TimeFilter, ZeroBasedCounter32=ZeroBasedCounter32)

# Objects
mibBuilder.exportSymbols("RMON2-MIB", rmon=rmon, etherStats2Table=etherStats2Table, etherStats2Entry=etherStats2Entry, etherStatsDroppedFrames=etherStatsDroppedFrames, etherStatsCreateTime=etherStatsCreateTime, tokenRingMLStats2Table=tokenRingMLStats2Table, tokenRingMLStats2Entry=tokenRingMLStats2Entry, tokenRingMLStatsDroppedFrames=tokenRingMLStatsDroppedFrames, tokenRingMLStatsCreateTime=tokenRingMLStatsCreateTime, tokenRingPStats2Table=tokenRingPStats2Table, tokenRingPStats2Entry=tokenRingPStats2Entry, tokenRingPStatsDroppedFrames=tokenRingPStatsDroppedFrames, tokenRingPStatsCreateTime=tokenRingPStatsCreateTime, historyControl2Table=historyControl2Table, historyControl2Entry=historyControl2Entry, historyControlDroppedFrames=historyControlDroppedFrames, hostControl2Table=hostControl2Table, hostControl2Entry=hostControl2Entry, hostControlDroppedFrames=hostControlDroppedFrames, hostControlCreateTime=hostControlCreateTime, matrixControl2Table=matrixControl2Table, matrixControl2Entry=matrixControl2Entry, matrixControlDroppedFrames=matrixControlDroppedFrames, matrixControlCreateTime=matrixControlCreateTime, channel2Table=channel2Table, channel2Entry=channel2Entry, channelDroppedFrames=channelDroppedFrames, channelCreateTime=channelCreateTime, filter2Table=filter2Table, filter2Entry=filter2Entry, filterProtocolDirDataLocalIndex=filterProtocolDirDataLocalIndex, filterProtocolDirLocalIndex=filterProtocolDirLocalIndex, ringStationControl2Table=ringStationControl2Table, ringStationControl2Entry=ringStationControl2Entry, ringStationControlDroppedFrames=ringStationControlDroppedFrames, ringStationControlCreateTime=ringStationControlCreateTime, sourceRoutingStats2Table=sourceRoutingStats2Table, sourceRoutingStats2Entry=sourceRoutingStats2Entry, sourceRoutingStatsDroppedFrames=sourceRoutingStatsDroppedFrames, sourceRoutingStatsCreateTime=sourceRoutingStatsCreateTime, protocolDir=protocolDir, protocolDirLastChange=protocolDirLastChange, protocolDirTable=protocolDirTable, protocolDirEntry=protocolDirEntry, protocolDirID=protocolDirID, protocolDirParameters=protocolDirParameters, protocolDirLocalIndex=protocolDirLocalIndex, protocolDirDescr=protocolDirDescr, protocolDirType=protocolDirType, protocolDirAddressMapConfig=protocolDirAddressMapConfig, protocolDirHostConfig=protocolDirHostConfig, protocolDirMatrixConfig=protocolDirMatrixConfig, protocolDirOwner=protocolDirOwner, protocolDirStatus=protocolDirStatus, protocolDist=protocolDist, protocolDistControlTable=protocolDistControlTable, protocolDistControlEntry=protocolDistControlEntry, protocolDistControlIndex=protocolDistControlIndex, protocolDistControlDataSource=protocolDistControlDataSource, protocolDistControlDroppedFrames=protocolDistControlDroppedFrames, protocolDistControlCreateTime=protocolDistControlCreateTime, protocolDistControlOwner=protocolDistControlOwner, protocolDistControlStatus=protocolDistControlStatus, protocolDistStatsTable=protocolDistStatsTable, protocolDistStatsEntry=protocolDistStatsEntry, protocolDistStatsPkts=protocolDistStatsPkts, protocolDistStatsOctets=protocolDistStatsOctets, addressMap=addressMap, addressMapInserts=addressMapInserts, addressMapDeletes=addressMapDeletes, addressMapMaxDesiredEntries=addressMapMaxDesiredEntries, addressMapControlTable=addressMapControlTable, addressMapControlEntry=addressMapControlEntry, addressMapControlIndex=addressMapControlIndex, addressMapControlDataSource=addressMapControlDataSource, addressMapControlDroppedFrames=addressMapControlDroppedFrames, addressMapControlOwner=addressMapControlOwner, addressMapControlStatus=addressMapControlStatus, addressMapTable=addressMapTable, addressMapEntry=addressMapEntry, addressMapTimeMark=addressMapTimeMark, addressMapNetworkAddress=addressMapNetworkAddress, addressMapSource=addressMapSource, addressMapPhysicalAddress=addressMapPhysicalAddress, addressMapLastChange=addressMapLastChange, nlHost=nlHost, hlHostControlTable=hlHostControlTable, hlHostControlEntry=hlHostControlEntry, hlHostControlIndex=hlHostControlIndex, hlHostControlDataSource=hlHostControlDataSource, hlHostControlNlDroppedFrames=hlHostControlNlDroppedFrames, hlHostControlNlInserts=hlHostControlNlInserts, hlHostControlNlDeletes=hlHostControlNlDeletes, hlHostControlNlMaxDesiredEntries=hlHostControlNlMaxDesiredEntries, hlHostControlAlDroppedFrames=hlHostControlAlDroppedFrames, hlHostControlAlInserts=hlHostControlAlInserts, hlHostControlAlDeletes=hlHostControlAlDeletes, hlHostControlAlMaxDesiredEntries=hlHostControlAlMaxDesiredEntries, hlHostControlOwner=hlHostControlOwner, hlHostControlStatus=hlHostControlStatus, nlHostTable=nlHostTable, nlHostEntry=nlHostEntry, nlHostTimeMark=nlHostTimeMark, nlHostAddress=nlHostAddress, nlHostInPkts=nlHostInPkts, nlHostOutPkts=nlHostOutPkts, nlHostInOctets=nlHostInOctets, nlHostOutOctets=nlHostOutOctets, nlHostOutMacNonUnicastPkts=nlHostOutMacNonUnicastPkts, nlHostCreateTime=nlHostCreateTime, nlMatrix=nlMatrix, hlMatrixControlTable=hlMatrixControlTable, hlMatrixControlEntry=hlMatrixControlEntry, hlMatrixControlIndex=hlMatrixControlIndex, hlMatrixControlDataSource=hlMatrixControlDataSource, hlMatrixControlNlDroppedFrames=hlMatrixControlNlDroppedFrames, hlMatrixControlNlInserts=hlMatrixControlNlInserts, hlMatrixControlNlDeletes=hlMatrixControlNlDeletes, hlMatrixControlNlMaxDesiredEntries=hlMatrixControlNlMaxDesiredEntries, hlMatrixControlAlDroppedFrames=hlMatrixControlAlDroppedFrames, hlMatrixControlAlInserts=hlMatrixControlAlInserts, hlMatrixControlAlDeletes=hlMatrixControlAlDeletes, hlMatrixControlAlMaxDesiredEntries=hlMatrixControlAlMaxDesiredEntries, hlMatrixControlOwner=hlMatrixControlOwner, hlMatrixControlStatus=hlMatrixControlStatus, nlMatrixSDTable=nlMatrixSDTable)
mibBuilder.exportSymbols("RMON2-MIB", nlMatrixSDEntry=nlMatrixSDEntry, nlMatrixSDTimeMark=nlMatrixSDTimeMark, nlMatrixSDSourceAddress=nlMatrixSDSourceAddress, nlMatrixSDDestAddress=nlMatrixSDDestAddress, nlMatrixSDPkts=nlMatrixSDPkts, nlMatrixSDOctets=nlMatrixSDOctets, nlMatrixSDCreateTime=nlMatrixSDCreateTime, nlMatrixDSTable=nlMatrixDSTable, nlMatrixDSEntry=nlMatrixDSEntry, nlMatrixDSTimeMark=nlMatrixDSTimeMark, nlMatrixDSSourceAddress=nlMatrixDSSourceAddress, nlMatrixDSDestAddress=nlMatrixDSDestAddress, nlMatrixDSPkts=nlMatrixDSPkts, nlMatrixDSOctets=nlMatrixDSOctets, nlMatrixDSCreateTime=nlMatrixDSCreateTime, nlMatrixTopNControlTable=nlMatrixTopNControlTable, nlMatrixTopNControlEntry=nlMatrixTopNControlEntry, nlMatrixTopNControlIndex=nlMatrixTopNControlIndex, nlMatrixTopNControlMatrixIndex=nlMatrixTopNControlMatrixIndex, nlMatrixTopNControlRateBase=nlMatrixTopNControlRateBase, nlMatrixTopNControlTimeRemaining=nlMatrixTopNControlTimeRemaining, nlMatrixTopNControlGeneratedReports=nlMatrixTopNControlGeneratedReports, nlMatrixTopNControlDuration=nlMatrixTopNControlDuration, nlMatrixTopNControlRequestedSize=nlMatrixTopNControlRequestedSize, nlMatrixTopNControlGrantedSize=nlMatrixTopNControlGrantedSize, nlMatrixTopNControlStartTime=nlMatrixTopNControlStartTime, nlMatrixTopNControlOwner=nlMatrixTopNControlOwner, nlMatrixTopNControlStatus=nlMatrixTopNControlStatus, nlMatrixTopNTable=nlMatrixTopNTable, nlMatrixTopNEntry=nlMatrixTopNEntry, nlMatrixTopNIndex=nlMatrixTopNIndex, nlMatrixTopNProtocolDirLocalIndex=nlMatrixTopNProtocolDirLocalIndex, nlMatrixTopNSourceAddress=nlMatrixTopNSourceAddress, nlMatrixTopNDestAddress=nlMatrixTopNDestAddress, nlMatrixTopNPktRate=nlMatrixTopNPktRate, nlMatrixTopNReversePktRate=nlMatrixTopNReversePktRate, nlMatrixTopNOctetRate=nlMatrixTopNOctetRate, nlMatrixTopNReverseOctetRate=nlMatrixTopNReverseOctetRate, alHost=alHost, alHostTable=alHostTable, alHostEntry=alHostEntry, alHostTimeMark=alHostTimeMark, alHostInPkts=alHostInPkts, alHostOutPkts=alHostOutPkts, alHostInOctets=alHostInOctets, alHostOutOctets=alHostOutOctets, alHostCreateTime=alHostCreateTime, alMatrix=alMatrix, alMatrixSDTable=alMatrixSDTable, alMatrixSDEntry=alMatrixSDEntry, alMatrixSDTimeMark=alMatrixSDTimeMark, alMatrixSDPkts=alMatrixSDPkts, alMatrixSDOctets=alMatrixSDOctets, alMatrixSDCreateTime=alMatrixSDCreateTime, alMatrixDSTable=alMatrixDSTable, alMatrixDSEntry=alMatrixDSEntry, alMatrixDSTimeMark=alMatrixDSTimeMark, alMatrixDSPkts=alMatrixDSPkts, alMatrixDSOctets=alMatrixDSOctets, alMatrixDSCreateTime=alMatrixDSCreateTime, alMatrixTopNControlTable=alMatrixTopNControlTable, alMatrixTopNControlEntry=alMatrixTopNControlEntry, alMatrixTopNControlIndex=alMatrixTopNControlIndex, alMatrixTopNControlMatrixIndex=alMatrixTopNControlMatrixIndex, alMatrixTopNControlRateBase=alMatrixTopNControlRateBase, alMatrixTopNControlTimeRemaining=alMatrixTopNControlTimeRemaining, alMatrixTopNControlGeneratedReports=alMatrixTopNControlGeneratedReports, alMatrixTopNControlDuration=alMatrixTopNControlDuration, alMatrixTopNControlRequestedSize=alMatrixTopNControlRequestedSize, alMatrixTopNControlGrantedSize=alMatrixTopNControlGrantedSize, alMatrixTopNControlStartTime=alMatrixTopNControlStartTime, alMatrixTopNControlOwner=alMatrixTopNControlOwner, alMatrixTopNControlStatus=alMatrixTopNControlStatus, alMatrixTopNTable=alMatrixTopNTable, alMatrixTopNEntry=alMatrixTopNEntry, alMatrixTopNIndex=alMatrixTopNIndex, alMatrixTopNProtocolDirLocalIndex=alMatrixTopNProtocolDirLocalIndex, alMatrixTopNSourceAddress=alMatrixTopNSourceAddress, alMatrixTopNDestAddress=alMatrixTopNDestAddress, alMatrixTopNAppProtocolDirLocalIndex=alMatrixTopNAppProtocolDirLocalIndex, alMatrixTopNPktRate=alMatrixTopNPktRate, alMatrixTopNReversePktRate=alMatrixTopNReversePktRate, alMatrixTopNOctetRate=alMatrixTopNOctetRate, alMatrixTopNReverseOctetRate=alMatrixTopNReverseOctetRate, usrHistory=usrHistory, usrHistoryControlTable=usrHistoryControlTable, usrHistoryControlEntry=usrHistoryControlEntry, usrHistoryControlIndex=usrHistoryControlIndex, usrHistoryControlObjects=usrHistoryControlObjects, usrHistoryControlBucketsRequested=usrHistoryControlBucketsRequested, usrHistoryControlBucketsGranted=usrHistoryControlBucketsGranted, usrHistoryControlInterval=usrHistoryControlInterval, usrHistoryControlOwner=usrHistoryControlOwner, usrHistoryControlStatus=usrHistoryControlStatus, usrHistoryObjectTable=usrHistoryObjectTable, usrHistoryObjectEntry=usrHistoryObjectEntry, usrHistoryObjectIndex=usrHistoryObjectIndex, usrHistoryObjectVariable=usrHistoryObjectVariable, usrHistoryObjectSampleType=usrHistoryObjectSampleType, usrHistoryTable=usrHistoryTable, usrHistoryEntry=usrHistoryEntry, usrHistorySampleIndex=usrHistorySampleIndex, usrHistoryIntervalStart=usrHistoryIntervalStart, usrHistoryIntervalEnd=usrHistoryIntervalEnd, usrHistoryAbsValue=usrHistoryAbsValue, usrHistoryValStatus=usrHistoryValStatus, probeConfig=probeConfig, probeCapabilities=probeCapabilities, probeSoftwareRev=probeSoftwareRev, probeHardwareRev=probeHardwareRev, probeDateTime=probeDateTime, probeResetControl=probeResetControl, probeDownloadFile=probeDownloadFile, probeDownloadTFTPServer=probeDownloadTFTPServer, probeDownloadAction=probeDownloadAction, probeDownloadStatus=probeDownloadStatus, serialConfigTable=serialConfigTable, serialConfigEntry=serialConfigEntry, serialMode=serialMode, serialProtocol=serialProtocol, serialTimeout=serialTimeout, serialModemInitString=serialModemInitString, serialModemHangUpString=serialModemHangUpString, serialModemConnectResp=serialModemConnectResp, serialModemNoConnectResp=serialModemNoConnectResp, serialDialoutTimeout=serialDialoutTimeout, serialStatus=serialStatus)
mibBuilder.exportSymbols("RMON2-MIB", netConfigTable=netConfigTable, netConfigEntry=netConfigEntry, netConfigIPAddress=netConfigIPAddress, netConfigSubnetMask=netConfigSubnetMask, netConfigStatus=netConfigStatus, netDefaultGateway=netDefaultGateway, trapDestTable=trapDestTable, trapDestEntry=trapDestEntry, trapDestIndex=trapDestIndex, trapDestCommunity=trapDestCommunity, trapDestProtocol=trapDestProtocol, trapDestAddress=trapDestAddress, trapDestOwner=trapDestOwner, trapDestStatus=trapDestStatus, serialConnectionTable=serialConnectionTable, serialConnectionEntry=serialConnectionEntry, serialConnectIndex=serialConnectIndex, serialConnectDestIpAddress=serialConnectDestIpAddress, serialConnectType=serialConnectType, serialConnectDialString=serialConnectDialString, serialConnectSwitchConnectSeq=serialConnectSwitchConnectSeq, serialConnectSwitchDisconnectSeq=serialConnectSwitchDisconnectSeq, serialConnectSwitchResetSeq=serialConnectSwitchResetSeq, serialConnectOwner=serialConnectOwner, serialConnectStatus=serialConnectStatus, rmonConformance=rmonConformance, rmon2MIBCompliances=rmon2MIBCompliances, rmon2MIBGroups=rmon2MIBGroups)

# Groups
mibBuilder.exportSymbols("RMON2-MIB", protocolDirectoryGroup=protocolDirectoryGroup, protocolDistributionGroup=protocolDistributionGroup, addressMapGroup=addressMapGroup, nlHostGroup=nlHostGroup, nlMatrixGroup=nlMatrixGroup, alHostGroup=alHostGroup, alMatrixGroup=alMatrixGroup, usrHistoryGroup=usrHistoryGroup, probeInformationGroup=probeInformationGroup, probeConfigurationGroup=probeConfigurationGroup, rmon1EnhancementGroup=rmon1EnhancementGroup, rmon1EthernetEnhancementGroup=rmon1EthernetEnhancementGroup, rmon1TokenRingEnhancementGroup=rmon1TokenRingEnhancementGroup)

# Compliances
mibBuilder.exportSymbols("RMON2-MIB", rmon2MIBCompliance=rmon2MIBCompliance, rmon2MIBApplicationLayerCompliance=rmon2MIBApplicationLayerCompliance)
