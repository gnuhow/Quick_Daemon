# PySNMP SMI module. Autogenerated from smidump -f python ATM2-MIB
# by libsmi2pysnmp-0.1.3 at Mon Apr  2 20:38:43 2012,
# Python version sys.version_info(major=2, minor=7, micro=2, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( atmInterfaceConfEntry, atmMIBObjects, atmVcCrossConnectEntry, atmVclEntry, atmVclVci, atmVclVpi, atmVpCrossConnectEntry, atmVplEntry, atmVplVpi, ) = mibBuilder.importSymbols("ATM-MIB", "atmInterfaceConfEntry", "atmMIBObjects", "atmVcCrossConnectEntry", "atmVclEntry", "atmVclVci", "atmVclVpi", "atmVpCrossConnectEntry", "atmVplEntry", "atmVplVpi")
( AtmAddr, AtmIlmiNetworkPrefix, AtmInterfaceType, AtmSigDescrParamIndex, AtmTrafficDescrParamIndex, AtmVcIdentifier, AtmVpIdentifier, ) = mibBuilder.importSymbols("ATM-TC-MIB", "AtmAddr", "AtmIlmiNetworkPrefix", "AtmInterfaceType", "AtmSigDescrParamIndex", "AtmTrafficDescrParamIndex", "AtmVcIdentifier", "AtmVpIdentifier")
( InterfaceIndex, InterfaceIndexOrZero, ifIndex, ) = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex", "InterfaceIndexOrZero", "ifIndex")
( SnmpAdminString, ) = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
( ModuleCompliance, NotificationGroup, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
( Bits, Counter32, Gauge32, Integer32, Integer32, ModuleIdentity, MibIdentifier, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "Gauge32", "Integer32", "Integer32", "ModuleIdentity", "MibIdentifier", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks")
( RowStatus, TimeStamp, TruthValue, ) = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "TimeStamp", "TruthValue")

# Objects

atm2MIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 37, 1, 14)).setRevisions(("2003-09-23 00:00",))
if mibBuilder.loadTexts: atm2MIB.setOrganization("IETF AToMMIB Working Group")
if mibBuilder.loadTexts: atm2MIB.setContactInfo("AToMMIB WG\nhttp://www.ietf.org/html.charters/atommib-charter.html\nEditors:\n       Faye Ly\nPostal:  Pedestal Networks\n       6503 Dumbarton Circle\n       Fremont, CA 94555\n       USA\nTel:     +1 510 896 2908\nE-Mail:  faye@pedestalnetworks.com\n\n       Michael Noto\nPostal:  Cisco Systems\n       170 W. Tasman Drive\n       San Jose, CA 95134-1706\n       USA\n\nE-mail:  mnoto@cisco.com\n\n       Andrew Smith\nPostal:  Consultant\n\nE-Mail:  ah_smith@acm.org\n\n       Ethan Mickey Spiegel\nPostal:  Cisco Systems\n       170 W. Tasman Drive\n       San Jose, CA 95134-1706\n       USA\nTel:     +1 408 526 6408\nFax:     +1 408 526 6488\nE-Mail:  mspiegel@cisco.com\n\n       Kaj Tesink\nPostal:  Telcordia Technologies\n       331 Newman Springs Road\n\n\n\n       Red Bank, NJ 07701\n       USA\nTel:     +1 732 758 5254\nE-mail:  kaj@research.telcordia.com")
if mibBuilder.loadTexts: atm2MIB.setDescription("Copyright (C) The Internet Society (2003). This version of\nthis MIB module is part of RFC 3606; see the RFC itself for\nfull legal notices.\n\nThis MIB Module is a supplement to the ATM-MIB\ndefined in RFC 2515.")
atm2MIBObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 37, 1, 14, 1))
atmSvcVpCrossConnectTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 1))
if mibBuilder.loadTexts: atmSvcVpCrossConnectTable.setDescription("The ATM SVPC Cross-Connect table.  A\nbi-directional VP cross-connect between two\nswitched VPLs is modeled as one entry in this\ntable.  A Soft PVPC cross-connect, between a\nsoft permanent VPL and a switched VPL, is\nalso modeled as one entry in this table.")
atmSvcVpCrossConnectEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 1, 1)).setIndexNames((0, "ATM2-MIB", "atmSvcVpCrossConnectIndex"), (0, "ATM2-MIB", "atmSvcVpCrossConnectLowIfIndex"), (0, "ATM2-MIB", "atmSvcVpCrossConnectLowVpi"), (0, "ATM2-MIB", "atmSvcVpCrossConnectHighIfIndex"), (0, "ATM2-MIB", "atmSvcVpCrossConnectHighVpi"))
if mibBuilder.loadTexts: atmSvcVpCrossConnectEntry.setDescription("An entry in the ATM SVPC Cross-Connect table.\nThis entry is used to model a bi-directional\nATM VP cross-connect between two VPLs.")
atmSvcVpCrossConnectIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: atmSvcVpCrossConnectIndex.setDescription("A unique value to identify this SVPC\ncross-connect.  For each VP associated\nwith this cross-connect, the agent reports\nthis cross-connect index value in the\natmVplCrossConnectIdentifer attribute of the\n\n\n\ncorresponding atmVplTable entries.")
atmSvcVpCrossConnectLowIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 1, 1, 2), InterfaceIndex()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: atmSvcVpCrossConnectLowIfIndex.setDescription("The value of this object is equal to the\nifIndex value of the ATM interface port for this\nSVPC cross-connect.  The term low implies\nthat this ATM interface has the numerically lower\nifIndex value than the other ATM interface\nidentified in the same atmSvcVpCrossConnectEntry.")
atmSvcVpCrossConnectLowVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 1, 1, 3), AtmVpIdentifier()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: atmSvcVpCrossConnectLowVpi.setDescription("The value of this object is equal to the VPI\nvalue associated with the SVPC cross-connect\nat the ATM interface that is identified by\natmSvcVpCrossConnectLowIfIndex.  The VPI value\ncannot exceed the number supported by the\natmInterfaceCurrentMaxSvpcVpi at the low ATM interface\nport.")
atmSvcVpCrossConnectHighIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 1, 1, 4), InterfaceIndex()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: atmSvcVpCrossConnectHighIfIndex.setDescription("The value of this object is equal to the\nifIndex value of the ATM interface port for\nthis SVC VP cross-connect.  The term high\nimplies that this ATM interface has the\nnumerically higher ifIndex value than the\nother ATM interface identified in the same\natmSvcVpCrossConnectEntry.")
atmSvcVpCrossConnectHighVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 1, 1, 5), AtmVpIdentifier()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: atmSvcVpCrossConnectHighVpi.setDescription("The value of this object is equal to the VPI\nvalue associated with the SVPC cross-connect\nat the ATM interface that is identified by\natmSvcVpCrossConnectHighIfIndex.  The VPI value\ncannot exceed the number supported by the\natmInterfaceCurrentMaxSvpcVpi at the high ATM interface\nport.")
atmSvcVpCrossConnectCreationTime = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 1, 1, 6), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSvcVpCrossConnectCreationTime.setDescription("The value of the sysUpTime object\nat the time this bi-directional SVPC\ncross-connect was created.  If the current\nstate was entered prior to the last\nre-initialization of the agent, then this\nobject contains a zero value.")
atmSvcVpCrossConnectRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 1, 1, 7), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSvcVpCrossConnectRowStatus.setDescription("This object is used to delete rows in the\natmSvcVpCrossConnectTable.")
atmSvcVcCrossConnectTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 2))
if mibBuilder.loadTexts: atmSvcVcCrossConnectTable.setDescription("The ATM SVCC Cross-Connect table.  A\nbi-directional VC cross-connect between two\nswitched VCLs is modeled as one entry in\nthis table.  A Soft PVCC cross-connect,\nbetween a soft permanent VCL and a switched\nVCL, is also modeled as one entry in this\ntable.")
atmSvcVcCrossConnectEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 2, 1)).setIndexNames((0, "ATM2-MIB", "atmSvcVcCrossConnectIndex"), (0, "ATM2-MIB", "atmSvcVcCrossConnectLowIfIndex"), (0, "ATM2-MIB", "atmSvcVcCrossConnectLowVpi"), (0, "ATM2-MIB", "atmSvcVcCrossConnectLowVci"), (0, "ATM2-MIB", "atmSvcVcCrossConnectHighIfIndex"), (0, "ATM2-MIB", "atmSvcVcCrossConnectHighVpi"), (0, "ATM2-MIB", "atmSvcVcCrossConnectHighVci"))
if mibBuilder.loadTexts: atmSvcVcCrossConnectEntry.setDescription("An entry in the ATM SVCC Cross-Connect table.\nThis entry is used to model a bi-directional ATM\nVC cross-connect between two VCLs.")
atmSvcVcCrossConnectIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: atmSvcVcCrossConnectIndex.setDescription("A unique value to identify this SVCC cross-connect.\nFor each VP associated with this cross-connect, the\nagent reports this cross-connect index value in the\natmVclCrossConnectIdentifier attribute of the\ncorresponding atmVplTable entries.")
atmSvcVcCrossConnectLowIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 2, 1, 2), InterfaceIndex()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: atmSvcVcCrossConnectLowIfIndex.setDescription("The value of this object is equal to the\nifIndex value of the ATM interface port for this\n\n\n\nSVCC cross-connect.  The term low implies that\nthis ATM interface has the numerically lower\nifIndex value than the other ATM interface\nidentified in the same atmSvcVcCrossConnectEntry.")
atmSvcVcCrossConnectLowVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 2, 1, 3), AtmVpIdentifier()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: atmSvcVcCrossConnectLowVpi.setDescription("The value of this object is equal to the VPI\nvalue associated with the SVCC cross-connect\nat the ATM interface that is identified by\natmSvcVcCrossConnectLowIfIndex.  The VPI value\ncannot exceed the number supported by the\natmInterfaceCurrentMaxSvccVpi at the low ATM interface\nport.")
atmSvcVcCrossConnectLowVci = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 2, 1, 4), AtmVcIdentifier()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: atmSvcVcCrossConnectLowVci.setDescription("The value of this object is equal to the VCI\nvalue associated with the SVCC cross-connect\nat the ATM interface that is identified by\natmSvcVcCrossConnectLowIfIndex.  The VCI value\ncannot exceed the number supported by the\natmInterfaceCurrentMaxSvccVci at the low ATM interface\nport.")
atmSvcVcCrossConnectHighIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 2, 1, 5), InterfaceIndex()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: atmSvcVcCrossConnectHighIfIndex.setDescription("The value of this object is equal to the\nifIndex value for the ATM interface port for\nthis SVCC cross-connect.  The term high implies\nthat this ATM interface has the numerically\nhigher ifIndex value than the other ATM interface\nidentified in the same atmSvcVcCrossConnectEntry.")
atmSvcVcCrossConnectHighVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 2, 1, 6), AtmVpIdentifier()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: atmSvcVcCrossConnectHighVpi.setDescription("The value of this object is equal to the VPI\nvalue associated with the SVCC cross-connect\nat the ATM interface that is identified by\natmSvcVcCrossConnectHighIfIndex.  The VPI value\ncannot exceed the number supported by the\natmInterfaceCurrentMaxSvccVpi at the high ATM interface\nport.")
atmSvcVcCrossConnectHighVci = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 2, 1, 7), AtmVcIdentifier()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: atmSvcVcCrossConnectHighVci.setDescription("The value of this object is equal to the VCI\nvalue associated with the SVCC cross-connect\nat the ATM interface that is identified by\natmSvcVcCrossConnectHighIfIndex.  The VCI value\ncannot exceed the number supported by the\natmInterfaceMaxVciBits at the high ATM interface\nport.")
atmSvcVcCrossConnectCreationTime = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 2, 1, 8), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSvcVcCrossConnectCreationTime.setDescription("The value of the sysUpTime object\nat the time this bi-directional SVCC\ncross-connect was created.  If the current\nstate was entered prior to the last\nre-initialization of the agent, then this\nobject contains a zero value.")
atmSvcVcCrossConnectRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 2, 1, 9), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSvcVcCrossConnectRowStatus.setDescription("This object is used to delete rows in the\natmSvcVcCrossConnectTable.")
atmSigStatTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3))
if mibBuilder.loadTexts: atmSigStatTable.setDescription("This table contains ATM interface signalling\nstatistics, one entry per ATM signalling\ninterface.")
atmSigStatEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1)).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: atmSigStatEntry.setDescription("This list contains signalling statistics variables.")
atmSigSSCOPConEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigSSCOPConEvents.setDescription("SSCOP Connection Events Counter.  This counter counts\nthe sum of the following errors:\n\n1) SSCOP Connection Disconnect Counter\n\n    The abnormal occurrence of this event is\n    characterized by the expiry of Timer_NO_RESPONSE.\n    (This event is communicated to the layer management\n    with MAA-ERROR code P.  See ITU-T Q.2110.)\n\n 2) SSCOP Connection Initiation Failure\n\n    This condition indicates the inability to establish\n    an SSCOP connection.  This event occurs whenever the\n    number of expiries of the connection control timer\n    (Timer_CC) equals or exceeds the MaxCC, or upon\n    receipt of a connection reject message BGREJ PDU.\n    (This event is communicated to layer management with\n    MAA-ERROR code O.  See ITU-T Q.2110.)\n\n 3) SSCOP Connection Re-Establ/Resynch\n\n    This event occurs upon receipt of a BGN PDU or\n    RS PDU.")
atmSigSSCOPErrdPdus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigSSCOPErrdPdus.setDescription("SSCOP Errored PDUs Counter.  This counter counts the\nsum of the following errors:\n\n1) Invalid PDUs.\n   These are defined in SSCOP and consist of PDUs\n   with an incorrect length (MAA-ERROR code U), an\n   undefined PDU type code, or that are not 32-bit\n   aligned.\n\n2) PDUs that result in MAA-ERROR codes and are\n\n\n\n   discarded.\n\nSee MAA-ERROR codes A-D, F-M, and Q-T defined in\nITU-T Q.2110.")
atmSigDetectSetupAttempts = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigDetectSetupAttempts.setDescription("Call Setup Attempts Counter.  This counter counts\nthe number of call setup attempts (both successful\nand unsuccessful) detected on this interface.")
atmSigEmitSetupAttempts = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigEmitSetupAttempts.setDescription("Call Setup Attempts Counter.  This counter counts\nthe number of call setup attempts (both successful\nand unsuccessful) transmitted on this interface.")
atmSigDetectUnavailRoutes = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigDetectUnavailRoutes.setDescription("Number of Route Unavailability detected on this interface.\nThis counter is incremented when a RELEASE, RELEASE COMPLETE\n(only when not preceded by a RELEASE message for the same\ncall), ADD PARTY REJECT, or STATUS message that\ncontains one of the following cause code values is\nreceived (Note: These cause values\napply to both UNI3.0 and UNI3.1):\n\nCause Value            Meaning\n\n\n\n\n\n   1            unallocated (unassigned) number\n   2            no route to specified transit network\n   3            no route to destination\n\nNOTE:  For this counter, RELEASE COMPLETE\nmessages that are a reply to a previous RELEASE\nmessage and contain the same cause value, are\nredundant (for counting purposes) and should not\nbe counted.")
atmSigEmitUnavailRoutes = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigEmitUnavailRoutes.setDescription("Number of Route Unavailability transmitted from this\ninterface.  This counter is incremented when a RELEASE,\nRELEASE COMPLETE (only when not preceded by a RELEASE\nmessage for the same call), ADD PARTY REJECT, or\nSTATUS message that contains one of the following cause\ncode values is transmitted (Note: These cause values apply\nto both UNI3.0 and UNI3.1):\n\nCause Value            Meaning\n\n   1            unallocated (unassigned) number\n   2            no route to specified transit network\n   3            no route to destination\n\nNOTE:  For this counter, RELEASE COMPLETE\nmessages that are a reply to a previous RELEASE\nmessage and contain the same cause value, are\nredundant (for counting purposes) and should not\nbe counted.")
atmSigDetectUnavailResrcs = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigDetectUnavailResrcs.setDescription("Number of Resource Unavailability detected on this\ninterface.  This counter is incremented when a RELEASE,\nRELEASE COMPLETE (only when not preceded by a RELEASE\nmessage for the same call), ADD PARTY REJECT, or\nSTATUS message that contains one of the following\n\n\n\ncause code values is received (Note: These cause\nvalues apply to both UNI3.0 and UNI3.1 unless\notherwise stated):\n\nCause Value          Meaning\n\n   35          requested VPCI/VCI not available\n   37          user cell rate not available (UNI3.1\n               only)\n   38          network out of order\n   41          temporary failure\n   45          no VPCI/VCI available\n   47          resource unavailable, unspecified\n   49          Quality of Service unavailable\n   51          user cell rate not available (UNI3.0\n               only)\n   58          bearer capability not presently\n               available\n   63          Service or option not available,\n               unspecified\n   92          too many pending add party requests\n\nNOTE:  For this counter, RELEASE COMPLETE\nmessages that are a reply to a previous RELEASE\nmessage and contain the same cause value, are\nredundant (for counting purposes) and should not\nbe counted.")
atmSigEmitUnavailResrcs = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigEmitUnavailResrcs.setDescription("Number of Resource Unavailability transmitted from this\ninterface.  This counter is incremented when a RELEASE,\nRELEASE COMPLETE (only when not preceded by a RELEASE message\nfor the same call), ADD PARTY REJECT, or STATUS message that\ncontains one of the following cause code values is transmitted\n(Note: These cause values apply to both UNI3.0 and UNI3.1\nunless otherwise stated):\n\nCause Value          Meaning\n\n   35          requested VPCI/VCI not available\n   37          user cell rate not available (UNI3.1\n               only)\n   38          network out of order\n\n\n\n   41          temporary failure\n   45          no VPCI/VCI available\n   47          resource unavailable, unspecified\n   49          Quality of Service unavailable\n   51          user cell rate not available (UNI3.0\n               only)\n   58          bearer capability not presently\n               available\n   63          Service or option not available,\n               unspecified\n   92          too many pending add party requests\n\nNOTE:  For this counter, RELEASE COMPLETE messages that are a\nreply to a previous RELEASE message and contain the same cause\nvalue, are redundant (for counting purposes) and should not be\ncounted.")
atmSigDetectCldPtyEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigDetectCldPtyEvents.setDescription("Number of Called Party Responsible For Unsuccessful Call\ndetected on this interface.  This counter is incremented when a\nRELEASE, RELEASE COMPLETE (only when not preceded by a RELEASE\nmessage for the same call), ADD PARTY REJECT, or STATUS message\nthat contains one of the following cause code values is\nreceived (Note: These cause values apply to both UNI3.0 and\nUNI3.1):\n\nCause Value         Meaning\n\n   17           user busy\n   18           no user responding\n   21           call rejected\n   22           number changed\n   23           user rejects all calls with calling\n                line identification restriction (CLIR)\n   27           destination out of order\n   31           normal, unspecified\n   88           incompatible destination\n\n\nNOTE:  For this counter, RELEASE COMPLETE messages that are a\nreply to a previous RELEASE message and contain the same cause\nvalue, are redundant (for counting purposes) and should not be\n\n\n\ncounted.\n\nNote: Cause Value #30 'response to STATUS ENQUIRY' was not\nincluded in this memo since it did not apply to a hard\nfailure.")
atmSigEmitCldPtyEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigEmitCldPtyEvents.setDescription("Number of Called Party Responsible For Unsuccessful Call\ntransmitted from this interface.  This counter is incremented\nwhen a RELEASE, RELEASE COMPLETE (only when not preceded by a\nRELEASE message for the same call), ADD PARTY REJECT, or STATUS\nmessage that contains one of the following cause code values is\ntransmitted (Note: These cause values apply to both UNI3.0 and\nUNI3.1):\n\nCause Value         Meaning\n\n   17           user busy\n   18           no user responding\n   21           call rejected\n   22           number changed\n   23           user rejects all calls with calling\n                line identification restriction (CLIR)\n   27           destination out of order\n   31           normal, unspecified\n   88           incompatible destination\n\nNOTE:  For this counter, RELEASE COMPLETE messages that are a\nreply to a previous RELEASE message and contain the same cause\nvalue, are redundant (for counting purposes) and should not be\ncounted.\n\nNote: Cause Value #30 'response to STATUS ENQUIRY' was not\nincluded in this memo since it did not apply to a hard failure.")
atmSigDetectMsgErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigDetectMsgErrors.setDescription("Number of Incorrect Messages detected on this interface.  The\nIncorrect Messages Counter reflects any sort of incorrect\ninformation in a message.  This includes:\n\n- RELEASE, RELEASE COMPLETE, ADD PARTY REJECT,\n  and STATUS messages transmitted, that contain any of\n  the Cause values listed below.\n\n- Ignored messages.  These messages are dropped\n  because the message was so damaged that it could\n  not be further processed.  A list of dropped\n  messages is compiled below:\n\n   1.  Message with invalid protocol discriminator\n\n   2.  Message with errors in the call reference I.E.\n        - Bits 5-8 of the first octet not equal to\n          '0000'\n        - Bits 1-4 of the first octet indicating a\n          length other than 3 octets\n        - RELEASE COMPLETE message received with a\n          call reference that does not relate to a\n          call active or in progress\n        - SETUP message received with call reference\n          flag incorrectly set to 1\n        - SETUP message received with a call\n          reference for a call that is already\n          active or in progress.\n\n   3.  Message too short\n\nThe following cause values are monitored by this counter (Note:\nThese cause values apply to both UNI3.0 and UNI3.1 unless\notherwise stated):\n\nCause Value     Meaning\n\n   10     VPCI/VCI unacceptable (UNI3.0 only)\n   36     VPCI/VCI assignment failure (UNI3.1 only)\n   81     invalid call reference value\n   82     identified channel does not exist\n   89     invalid endpoint reference\n   96     mandatory information element is missing\n   97     message type non-existent or not\n          implemented\n   99     information element non-existent or not\n          implemented\n\n\n\n   100    invalid information element contents\n   101    message not compatible with call state\n   104    incorrect message length\n   111    protocol error, unspecified\n\n   NOTE:  For this counter, RELEASE COMPLETE messages that are\n   a reply to a previous RELEASE message and contain the same\n   cause value, are redundant (for counting purposes) and\n   should not be counted.")
atmSigEmitMsgErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigEmitMsgErrors.setDescription("Number of Incorrect Messages transmitted on this interface.\nThe Incorrect Messages Counter reflects any sort of incorrect\ninformation in a message.  This includes:\n\n- RELEASE, RELEASE COMPLETE, ADD PARTY REJECT,\n  and STATUS messages transmitted or\n  received, that contain any of the Cause values\n  listed below.\n\n- Ignored messages.  These messages are dropped\n  because the message was so damaged that it could\n  not be further processed.  A list of dropped\n  messages is compiled below:\n\n   1.  Message with invalid protocol discriminator\n\n   2.  Message with errors in the call reference I.E.\n        - Bits 5-8 of the first octet not equal to\n          '0000'\n        - Bits 1-4 of the first octet indicating a\n          length other than 3 octets\n        - RELEASE COMPLETE message received with a\n          call reference that does not relate to a\n          call active or in progress\n        - SETUP message received with call reference\n          flag incorrectly set to 1\n        - SETUP message received with a call\n          reference for a call that is already\n          active or in progress.\n\n   3.  Message too short\n\n\n\nThe following cause values are monitored by this counter\n(Note: These cause values apply to both UNI3.0 and UNI3.1\nunless otherwise stated):\n\nCause Value     Meaning\n\n   10     VPCI/VCI unacceptable (UNI3.0 only)\n   36     VPCI/VCI assignment failure (UNI3.1 only)\n   81     invalid call reference value\n   82     identified channel does not exist\n   89     invalid endpoint reference\n   96     mandatory information element is missing\n   97     message type non-existent or not\n          implemented\n   99     information element non-existent or not\n          implemented\n   100    invalid information element contents\n   101    message not compatible with call state\n   104    incorrect message length\n   111    protocol error, unspecified\n\n   NOTE:  For this counter, RELEASE COMPLETE messages that are\n   a reply to a previous RELEASE message and contain the same\n   cause value, are redundant (for counting purposes) and\n   should not be counted.")
atmSigDetectClgPtyEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigDetectClgPtyEvents.setDescription("Number of Calling Party Events detected on this interface.\nThis counter monitors error events that occur due to the\noriginating user doing something wrong.  This counter is\nincremented when a RELEASE, RELEASE COMPLETE (only when not\npreceded by a RELEASE message for the same call), ADD PARTY\nREJECT, or STATUS message that contains one of the following\ncause code values is received (Note: These cause values\napply to both UNI3.0 and UNI3.1):\n\nCause Value     Meaning\n\n   28     invalid number format (address incomplete)\n   43     access information discarded\n   57     bearer capability not authorized\n   65     bearer capability not implemented\n\n\n\n   73     unsupported combination of traffic\n          parameters\n   78     AAL parameters cannot be supported (UNI3.1\n          only)\n   91     invalid transit network selection\n   93     AAL parameters cannot be supported (UNI3.0\n          only)\n\n   NOTE:  For this counter, RELEASE COMPLETE messages that\n   are a reply to a previous RELEASE message and contain\n   the same cause value, are redundant (for counting purposes)\n   and should not be counted.")
atmSigEmitClgPtyEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigEmitClgPtyEvents.setDescription("Number of Calling Party Events transmitted from this interface.\nThis counter monitors error events that occur due to the\noriginating user doing something wrong.  This counter is\nincremented when a RELEASE, RELEASE COMPLETE (only when not\npreceded by a RELEASE message for the same call), ADD PARTY\nREJECT, or STATUS message that contains one of the following\ncause code values is transmitted (Note: These cause values\napply to both UNI3.0 and UNI3.1):\n\nCause Value     Meaning\n\n   28     invalid number format (address incomplete)\n   43     access information discarded\n   57     bearer capability not authorized\n   65     bearer capability not implemented\n   73     unsupported combination of traffic\n          parameters\n   78     AAL parameters cannot be supported (UNI3.1\n          only)\n   91     invalid transit network selection\n   93     AAL parameters cannot be supported (UNI3.0\n          only)\n\n   NOTE:  For this counter, RELEASE COMPLETE messages that are\n   a reply to a previous RELEASE message and contain the same\n   cause value, are redundant (for counting purposes) and\n   should not be counted.")
atmSigDetectTimerExpireds = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigDetectTimerExpireds.setDescription("Number of Timer Expiries detected on this interface.  The Timer\nExpiries Counter provides a count of network timer expiries, and\nto some extent, host or switch timer expiries.  The conditions\nfor incrementing this counter are:\n\n   - Expiry of any network timer\n\n   - Receipt of a RELEASE or RELEASE COMPLETE\n     message with Cause #102, 'recovery on\n     timer expiry'.\n\n   NOTE:  For this counter, RELEASE COMPLETE messages that are\n   a reply to a previous RELEASE message and contain the same\n   cause value, are redundant (for counting purposes) and\n   should not be counted.")
atmSigEmitTimerExpireds = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigEmitTimerExpireds.setDescription("Number of Timer Expiries transmitted from this interface.\nThe Timer Expiries Counter provides a count of network timer\nexpiries, and to some extent, host or switch timer expiries.\nThe conditions for incrementing this counter are:\n\n   - Expiry of any network timer\n\n   - Receipt of a RELEASE or RELEASE COMPLETE\n     message with Cause #102, 'recovery on\n     timer expiry'.\n\nNOTE:  For this counter, RELEASE COMPLETE messages that are a\nreply to a previous RELEASE message and contain the same cause\nvalue, are redundant (for counting purposes) and should not be\ncounted.")
atmSigDetectRestarts = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigDetectRestarts.setDescription("Number of Restart Activity errors detected on this interface.\nThe Restart Activity Counter provides a count of host, switch,\nor network restart activity.  This counter is incremented when\nreceiving a RESTART message.")
atmSigEmitRestarts = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigEmitRestarts.setDescription("Number of Restart Activity errors transmitted from this\ninterface.  The Restart Activity Counter provides a count of\nhost, switch, or network restart activity.  This counter is\nincremented when transmitting a RESTART message.")
atmSigInEstabls = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigInEstabls.setDescription("Number of SVCs established at this signalling entity for\nincoming connections.")
atmSigOutEstabls = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigOutEstabls.setDescription("Number of SVCs established at this signalling entity for\noutgoing connections.")
atmSigSupportTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 4))
if mibBuilder.loadTexts: atmSigSupportTable.setDescription("This table contains ATM local interface configuration\nparameters, one entry per ATM signalling interface.")
atmSigSupportEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 4, 1)).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: atmSigSupportEntry.setDescription("This list contains signalling configuration parameters\nand state variables.")
atmSigSupportClgPtyNumDel = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 4, 1, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSigSupportClgPtyNumDel.setDescription("This object indicates whether the Calling Party Number\nInformation Element is transferred to the called party\naddress.  The value of this object can be:\n\n  - enabled(1)  This Information Element is transferred\n                to the called party\n\n  - disabled(2) This Information Element is NOT\n                transferred to the called party.")
atmSigSupportClgPtySubAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 4, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSigSupportClgPtySubAddr.setDescription("This object indicates whether to accept and transfer the Calling\nParty Subaddress Information Element from the calling party to\nthe called party.  Calling party subaddress information shall\nonly be transferred to the called party if calling party number\ndelivery is enabled (i.e., atmSigSupportClgPtyNumDel =\n'enabled(1)'.  The value of this object can be:\n\n  - enabled(1)  This Information Element is transferred\n                to the called party\n\n  - disabled(2) This Information Element is NOT\n                transferred to the called party.")
atmSigSupportCldPtySubAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 4, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSigSupportCldPtySubAddr.setDescription("This object indicates whether to accept, transfer, and deliver\nthe Called Party Subaddress Information Element from the calling\nparty to the called party.  The value of this object can be:\n\n  - enabled(1)  This Information Element is transferred\n                to the called party\n\n  - disabled(2) This Information Element is NOT\n                transferred to the called party.")
atmSigSupportHiLyrInfo = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 4, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSigSupportHiLyrInfo.setDescription("This object indicates whether to accept, transfer, and deliver\nthe Broadband High Layer Information Element from the calling\nparty to the called party.  The value of this object can be:\n\n  - enabled(1)  This Information Element is transferred\n                to the called party\n\n\n\n\n  - disabled(2) This Information Element is NOT\n                transferred to the called party.")
atmSigSupportLoLyrInfo = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 4, 1, 5), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSigSupportLoLyrInfo.setDescription("This object indicates whether to accept, transfer, and deliver\nthe Broadband Low Layer Information Element from the calling\nparty to the called party.  The value of this object can be:\n\n  - enabled(1)  This Information Element is transferred\n                to the called party\n\n  - disabled(2) This Information Element is NOT\n                transferred to the called party.")
atmSigSupportBlliRepeatInd = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 4, 1, 6), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSigSupportBlliRepeatInd.setDescription("This object indicates whether to accept, transfer, and deliver\nthe Broadband Repeat Indicator with two or three instances of\nthe Broadband Low Layer Information Element for low layer\ninformation selection from the calling party to the called\nparty.  This object's value should always be disabled(2) if\nthe value of atmSigSupportLolyrInfo is disabled(2).\n\nThe value of this object can be:\n\n- enabled(1)  This Information Element is transferred\n      to the called party\n\n- disabled(2) This Information Element is NOT\n      transferred to the called party.")
atmSigSupportAALInfo = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 4, 1, 7), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSigSupportAALInfo.setDescription("This object indicates whether to accept, transfer, and deliver\nthe ATM Adaptation Layer Parameters Information Element from the\ncalling party to the called party.  The value of this object can\nbe:\n\n  - enabled(1)  This Information Element is transferred\n                to the called party\n\n  - disabled(2) This Information Element is NOT\n                transferred to the called party.")
atmSigSupportPrefCarrier = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 4, 1, 8), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0,0),ValueSizeConstraint(4,4),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSigSupportPrefCarrier.setDescription("This parameter identifies the carrier to which intercarrier\ncalls originated from this interface are routed when transit\nnetwork selection information is not provided by the calling\nparty.  If a Carrier Identification Code (CIC) is used the\nparameter shall contain the CIC.  For three-digit CICs, the first\noctet shall be '0' and the CIC is contained in the three\nfollowing octets.  If the preferred carrier feature is not\nsupported the value is a zero-length string.")
atmSigDescrParamTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5))
if mibBuilder.loadTexts: atmSigDescrParamTable.setDescription("A table contains signalling capabilities of VCLs except the\nTraffic Descriptor.  Traffic descriptors are described in\nthe atmTrafficDescrParamTable.")
atmSigDescrParamEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1)).setIndexNames((0, "ATM2-MIB", "atmSigDescrParamIndex"))
if mibBuilder.loadTexts: atmSigDescrParamEntry.setDescription("Each entry in this table represents a\nset of signalling capabilities that can\nbe applied to a VCL.  There is no requirement\nfor unique entries, except that the index must\nbe unique.")
atmSigDescrParamIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 1), AtmSigDescrParamIndex()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: atmSigDescrParamIndex.setDescription("The value of this object is used by the\natmVclGenSigDescrIndex object in the atmVclGenTable to\nidentify a row in this table.")
atmSigDescrParamAalType = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(5,6,2,4,1,3,)).subtype(namedValues=NamedValues(("other", 1), ("aal1", 2), ("aal34", 3), ("aal5", 4), ("userDefined", 5), ("aal2", 6), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSigDescrParamAalType.setDescription("The AAL type.  The value of this object is set to other(1)\nwhen not defined.")
atmSigDescrParamAalSscsType = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,4,5,3,)).subtype(namedValues=NamedValues(("other", 1), ("assured", 2), ("nonassured", 3), ("frameRelay", 4), ("null", 5), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSigDescrParamAalSscsType.setDescription("The SSCS type used by this entry.")
atmSigDescrParamBhliType = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(5,1,2,3,4,)).subtype(namedValues=NamedValues(("other", 1), ("iso", 2), ("user", 3), ("hiProfile", 4), ("vendorSpecific", 5), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSigDescrParamBhliType.setDescription("The Broadband high layer type.")
atmSigDescrParamBhliInfo = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 8)).clone('')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSigDescrParamBhliInfo.setDescription("The Broadband high layer information.  When\natmSigDescrParamBhliType is set to iso(2), the value of this\nobject is a zero length string.  When\natmSigDescrParamBhliType is set to user(3), the value of\nthis object is an octet string with length ranging from 0 to\n8.  When atmSigDescrParamBhliType is set to hiProfile(4),\nthe value of this object is a length of 4 octet string\ncontaining user to user profile identifier.  When\natmSigDescrParamBhliType is set to vendorSpecific(5), the\nvalue of this object is a length of 7 octet string, where\nthe most significant 3 octets consist of a globally-\nadministered OUI, and the least significant 4 octets are the\nvender administered application OUI.")
atmSigDescrParamBbcConnConf = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 6), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("ptp", 1), ("ptmp", 2), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSigDescrParamBbcConnConf.setDescription("The Broadband bearer capability user plane connection\nconfiguration parameter.")
atmSigDescrParamBlliLayer2 = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 7), Integer().subtype(subtypeSpec=SingleValueConstraint(5,2,3,12,8,7,13,11,9,14,1,10,6,4,)).subtype(namedValues=NamedValues(("other", 1), ("iso88022", 10), ("x75slp", 11), ("q922", 12), ("userDef", 13), ("iso7776", 14), ("iso1745", 2), ("q921", 3), ("x25linklayer", 4), ("x25multilink", 5), ("lapb", 6), ("hdlcArm", 7), ("hdlcNrm", 8), ("hdlcAbm", 9), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSigDescrParamBlliLayer2.setDescription("The Broadband low layer information, protocol type of layer\n2.  The value of this object is other(1) if layer 2 protocol\nis not used.")
atmSigDescrParamBlliLayer3 = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 8), Integer().subtype(subtypeSpec=SingleValueConstraint(5,4,6,1,3,2,8,7,)).subtype(namedValues=NamedValues(("other", 1), ("x25pkt", 2), ("isoiec8208", 3), ("x223iso8878", 4), ("isoiec8473", 5), ("t70", 6), ("tr9577", 7), ("userDef", 8), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSigDescrParamBlliLayer3.setDescription("The Broadband low layer information, protocol type of layer\n\n\n\n3.  The value of this object is other(1) if layer 3 protocol\nis not used.")
atmSigDescrParamBlliPktSize = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 9), Integer().subtype(subtypeSpec=SingleValueConstraint(9,2,8,3,5,10,7,6,1,4,)).subtype(namedValues=NamedValues(("other", 1), ("s4096", 10), ("s16", 2), ("s32", 3), ("s64", 4), ("s128", 5), ("s256", 6), ("s512", 7), ("s1024", 8), ("s2048", 9), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSigDescrParamBlliPktSize.setDescription("The default packet size defined in B-LLI.")
atmSigDescrParamBlliSnapId = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 10), Integer().subtype(subtypeSpec=SingleValueConstraint(3,1,2,)).subtype(namedValues=NamedValues(("other", 1), ("true", 2), ("false", 3), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSigDescrParamBlliSnapId.setDescription("The SNAP ID used for Broadband low layer protocol layer 3.\nThe value of this object is other(1) if\natmSigDescrParamBlliLayer3 is set to other(1).")
atmSigDescrParamBlliOuiPid = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 11), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0,0),ValueSizeConstraint(5,5),)).clone('')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSigDescrParamBlliOuiPid.setDescription("The OUI/PID encoding for Broadband low layer protocol layer\n3.  The value of this object is a zero length string if\natmSigDescrParamBlliLayer3 is set to other(1).  When used,\nit is always 5 octets with the most significant octet as the\nOUI Octet 1 and the least significant octet as the PID Octet\n2.")
atmSigDescrParamRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 12), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSigDescrParamRowStatus.setDescription("This object is used to create and delete rows in the\natmSigDescrParamTable.")
atmIfRegisteredAddrTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 6))
if mibBuilder.loadTexts: atmIfRegisteredAddrTable.setDescription("This table contains a list of ATM addresses that can be used for\ncalls to and from a given interface by a switch or service.  The\nATM addresses are either registered by the endsystem via ILMI or\nstatically configured.  This table does not expose PNNI\nreachability information.  ILMI registered addresses cannot be\ndeleted using this table.  This table only applies to switches\nand network services.")
atmIfRegisteredAddrEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 6, 1)).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM2-MIB", "atmIfRegAddrAddress"))
if mibBuilder.loadTexts: atmIfRegisteredAddrEntry.setDescription("An entry in the ATM Interface Registered Address table.")
atmIfRegAddrAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 6, 1, 1), AtmAddr()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: atmIfRegAddrAddress.setDescription("An address registered for a given switch or service interface.")
atmIfRegAddrAddressSource = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 6, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(3,1,2,)).subtype(namedValues=NamedValues(("other", 1), ("static", 2), ("dynamic", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfRegAddrAddressSource.setDescription("The type of address source for a given ATM Address. The value\ndynamic(3) is indicated when ILMI is used.")
atmIfRegAddrOrgScope = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 6, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(7,15,6,13,8,1,9,2,4,3,5,14,11,10,12,)).subtype(namedValues=NamedValues(("localNetwork", 1), ("communityMinusOne", 10), ("intraCommunity", 11), ("communityPlusOne", 12), ("regional", 13), ("interRegional", 14), ("global", 15), ("localNetworkPlusOne", 2), ("localNetworkPlusTwo", 3), ("siteMinusOne", 4), ("intraSite", 5), ("sitePlusOne", 6), ("organizationMinusOne", 7), ("intraOrganization", 8), ("organizationPlusOne", 9), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmIfRegAddrOrgScope.setDescription("This object indicates the organizational scope for\nthe referenced address.  The information of the\nreferenced address shall not be distributed outside\nthe indicated scope.   Refer to Annex 5.3 of ATM\nForum UNI Signalling 4.0 for guidelines regarding\nthe use of organizational scopes.\n\nThis value cannot be configured for ILMI-registered\naddresses.\n\nThe default values for organizational scope are\nlocalNetwork(1) for ATM group addresses, and\nglobal(15) for individual addresses.")
atmIfRegAddrRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 6, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmIfRegAddrRowStatus.setDescription("This object is used to create and delete rows in the\natmIfRegisteredAddrTable.  Rows created dynamically (e.g., ILMI-\nregistered addresses) cannot be deleted using this object.")
atmVclAddrTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 7))
if mibBuilder.loadTexts: atmVclAddrTable.setDescription("This table provides a mapping between the atmVclTable and\nthe ATM called party/calling party address.  This table can\nbe used to retrieve the calling party and called party ATM\naddress pair for a given VCL.  Note that there can be more\nthan one pair of calling party and called party ATM\naddresses for a VCL in a point to multi-point call.")
atmVclAddrEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 7, 1)).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVclVpi"), (0, "ATM-MIB", "atmVclVci"), (0, "ATM2-MIB", "atmVclAddrAddr"))
if mibBuilder.loadTexts: atmVclAddrEntry.setDescription("Each entry in this table represents a binding between a VCL\nand an ATM address associated with this call.  This ATM\n\n\n\naddress can be either the called party address or the\ncalling party address.  There can be more than one pair of\ncalling/called party ATM addresses associated with the VCL\nentry for point to multi-point calls.  Objects\natmVclAddrType, and atmVclAddrRowStatus are\nrequired during row creation.")
atmVclAddrAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 7, 1, 1), AtmAddr()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: atmVclAddrAddr.setDescription("An ATM address on one end of the VCL.  For SVCs, the agent\nsupplies the value of this object at creation time.  For PVC\nVCL, the manager can supply the value of this object during\nor after the PVC VCL creation.")
atmVclAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 7, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("callingParty", 1), ("calledParty", 2), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVclAddrType.setDescription("The type of ATM Address represented by the object\natmVclAddrAddr.  Choices are either the calling party ATM\naddress or the called party ATM address.")
atmVclAddrRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 7, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVclAddrRowStatus.setDescription("This object is used to create or destroy an\nentry from this table.  Note that the manager entity\n\n\n\ncan only destroy the PVC VCLs.")
atmAddrVclTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 8))
if mibBuilder.loadTexts: atmAddrVclTable.setDescription("This table provides an alternative way to retrieve the\natmVclTable.  This table can be used to retrieve the\nindexing to the atmVclTable by an ATM address.")
atmAddrVclEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 8, 1)).setIndexNames((0, "ATM2-MIB", "atmVclAddrAddr"), (0, "ATM2-MIB", "atmAddrVclAtmIfIndex"), (0, "ATM2-MIB", "atmAddrVclVpi"), (0, "ATM2-MIB", "atmAddrVclVci"))
if mibBuilder.loadTexts: atmAddrVclEntry.setDescription("Each entry in this table represents an entry in the\natmVclTable of the ATM-MIB by its ATM address.  The ATM\naddress is either the calling or called party ATM address\nof the call.  Entries in this table are read only.\nThey show up when entries are created in the\natmVclAddrTable.")
atmAddrVclAtmIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 8, 1, 1), InterfaceIndex()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: atmAddrVclAtmIfIndex.setDescription("The interface index of the ATM interface to which this\nVCL pertains.  This object combined with the\natmAddrVclVpi and atmAddrVclVci objects serves as an\nindex to the atmVclTable.")
atmAddrVclVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 8, 1, 2), AtmVpIdentifier()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: atmAddrVclVpi.setDescription("The VPI value of the VCL.  This object combined with the\natmAddrVclAtmIfIndex and atmAddrVclVci objects serves as\nan index to the atmVclTable.")
atmAddrVclVci = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 8, 1, 3), AtmVcIdentifier()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: atmAddrVclVci.setDescription("The VCI value of the VCL.  This object combined with the\natmAddrVclAtmIfIndex and atmAddrVclVpi objects serves as\nan index to the atmVclTable.")
atmAddrVclAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 8, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("callingParty", 1), ("calledParty", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAddrVclAddrType.setDescription("The type of ATM Address represented by the object\natmVclAddrAddr.  Choices are either calling party address\nor called party address.")
atmVplStatTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 9))
if mibBuilder.loadTexts: atmVplStatTable.setDescription("This table contains all statistics counters per VPL.  It is\nused to monitor the usage of the VPL in terms of incoming\ncells and outgoing cells.")
atmVplStatEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 9, 1)).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVplVpi"))
if mibBuilder.loadTexts: atmVplStatEntry.setDescription("Each entry in this table represents a VPL.")
atmVplStatTotalCellIns = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 9, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVplStatTotalCellIns.setDescription("The total number of valid ATM cells received by this VPL\nincluding both CLP=0 and CLP=1 cells.  The cells are\ncounted prior to the application of the traffic policing.")
atmVplStatClp0CellIns = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 9, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVplStatClp0CellIns.setDescription("The number of valid ATM cells received by this VPL with\nCLP=0.  The cells are counted prior to the application of\nthe traffic policing.")
atmVplStatTotalDiscards = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 9, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVplStatTotalDiscards.setDescription("The total number of valid ATM cells discarded by the\ntraffic policing entity.  This includes cells originally\nreceived with CLP=0 and CLP=1.")
atmVplStatClp0Discards = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 9, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVplStatClp0Discards.setDescription("The total number of valid ATM cells received with CLP=0 and\ndiscarded by the traffic policing entity.")
atmVplStatTotalCellOuts = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 9, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVplStatTotalCellOuts.setDescription("The total number of valid ATM cells transmitted  by this\nVPL.  This includes both CLP=0 and CLP=1 cells.")
atmVplStatClp0CellOuts = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 9, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVplStatClp0CellOuts.setDescription("The total number of valid ATM cells transmitted with CLP=0\nby this VPL.")
atmVplStatClp0Tagged = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 9, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVplStatClp0Tagged.setDescription("The total number of valid ATM cells tagged by the traffic\npolicing entity from CLP=0 to CLP=1.")
atmVplLogicalPortTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 10))
if mibBuilder.loadTexts: atmVplLogicalPortTable.setDescription("Indicates whether the VPL is an ATM Logical Port interface\n(ifType=80).")
atmVplLogicalPortEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 10, 1))
if mibBuilder.loadTexts: atmVplLogicalPortEntry.setDescription("An entry with information about the ATM Logical Port\ninterface.")
atmVplLogicalPortDef = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 10, 1, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("notLogicalIf", 1), ("isLogicalIf", 2), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVplLogicalPortDef.setDescription("Indicates whether the VPC at this VPL interface is an ATM\nLogical Port interface.")
atmVplLogicalPortIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 10, 1, 2), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVplLogicalPortIndex.setDescription("The ifTable index of the ATM logical port interface\nassociated with this VPL. The distinguished value of zero\nindicates that the agent has not (yet) assigned such an\nifTable Index. The zero value must be assigned by the agent\nif the value of atmVplLogicalPortDef is set to notLogicalIf,\nor if the VPL row is not active.")
atmVclStatTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 11))
if mibBuilder.loadTexts: atmVclStatTable.setDescription("This table contains all statistics counters per VCL.  It is\nused to monitor the usage of the VCL in terms of incoming\ncells and outgoing cells.")
atmVclStatEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 11, 1)).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVclVpi"), (0, "ATM-MIB", "atmVclVci"))
if mibBuilder.loadTexts: atmVclStatEntry.setDescription("Each entry in this table represents a VCL.")
atmVclStatTotalCellIns = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVclStatTotalCellIns.setDescription("The total number of valid ATM cells received by this VCL\nincluding both CLP=0 and CLP=1 cells.  The cells are counted\nprior to the application of the traffic policing.")
atmVclStatClp0CellIns = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVclStatClp0CellIns.setDescription("The number of valid ATM cells received by this VCL with\nCLP=0.  The cells are counted prior to the application of\nthe traffic policing.")
atmVclStatTotalDiscards = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVclStatTotalDiscards.setDescription("The total number of valid ATM cells discarded by the\ntraffic policing entity.  This includes cells originally\nreceived with CLP=0 and CLP=1.")
atmVclStatClp0Discards = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVclStatClp0Discards.setDescription("The total number of valid ATM cells received with CLP=0\nand discarded by the traffic policing entity.")
atmVclStatTotalCellOuts = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVclStatTotalCellOuts.setDescription("The total number of valid ATM cells transmitted  by this\nVCL.  This includes both CLP=0 and CLP=1 cells.")
atmVclStatClp0CellOuts = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 11, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVclStatClp0CellOuts.setDescription("The total number of valid ATM cells transmitted with CLP=0\nby this VCL.")
atmVclStatClp0Tagged = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 11, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVclStatClp0Tagged.setDescription("The total number of valid ATM cells tagged by the traffic\npolicing entity from CLP=0 to CLP=1.")
atmAal5VclStatTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 12))
if mibBuilder.loadTexts: atmAal5VclStatTable.setDescription("This table provides a collection of objects providing AAL5\nconfiguration and performance statistics of a VCL.")
atmAal5VclStatEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 12, 1)).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVclVpi"), (0, "ATM-MIB", "atmVclVci"))
if mibBuilder.loadTexts: atmAal5VclStatEntry.setDescription("Each entry in this table represents an AAL5 VCL, and\nis indexed by ifIndex values of AAL5 interfaces and\nthe associated VPI/VCI values.")
atmAal5VclInPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAal5VclInPkts.setDescription("The number of AAL5 CPCS PDUs received on the AAL5 VCC at\nthe interface identified by the ifIndex.")
atmAal5VclOutPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 12, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAal5VclOutPkts.setDescription("The number of AAL5 CPCS PDUs transmitted on the AAL5 VCC\nat the interface identified by the ifIndex.")
atmAal5VclInOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 12, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAal5VclInOctets.setDescription("The number of octets contained in AAL5 CPCS PDUs received\non the AAL5 VCC at the interface identified by the ifIndex.")
atmAal5VclOutOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 12, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAal5VclOutOctets.setDescription("The number of octets contained in AAL5 CPCS PDUs\ntransmitted on the AAL5 VCC at the interface identified by\nthe ifIndex.")
atmVclGenTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 13))
if mibBuilder.loadTexts: atmVclGenTable.setDescription("General Information for each VC.")
atmVclGenEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 13, 1))
if mibBuilder.loadTexts: atmVclGenEntry.setDescription("An entry with general information about the ATM VC.")
atmVclGenSigDescrIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 13, 1, 1), AtmSigDescrParamIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVclGenSigDescrIndex.setDescription("The value of this object identifies the row in the ATM\nSignalling Descriptor Parameter Table which applies to this\nVCL.")
atmInterfaceExtTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14))
if mibBuilder.loadTexts: atmInterfaceExtTable.setDescription("This table contains ATM interface configuration and monitoring\ninformation not defined in the atmInterfaceConfTable from the\nATM-MIB.  This includes the type of connection setup procedures,\nILMI information, and information on the VPI/VCI range.")
atmInterfaceExtEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1))
if mibBuilder.loadTexts: atmInterfaceExtEntry.setDescription("An entry extends the atmInterfaceConfEntry defined in the ATM-\nMIB.  Each entry corresponds to an ATM interface.")
atmIntfConfigType = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 1), AtmInterfaceType().clone('autoConfig')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIntfConfigType.setDescription("The type of connection setup procedures configured for the ATM\ninterface.  Setting this variable to a value of 'other' is not\nallowed.")
atmIntfActualType = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 2), AtmInterfaceType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIntfActualType.setDescription("The type of connection setup procedures currently being used on\nthe interface.  This may reflect a manually configured value for\nthe interface type, or may be determined by other means such as\nauto-configuration.  A value of `autoConfig' indicates that\nauto-configuration was requested but has not yet been completed.")
atmIntfConfigSide = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(3,1,2,)).subtype(namedValues=NamedValues(("other", 1), ("user", 2), ("network", 3), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIntfConfigSide.setDescription("The configured role of the managed entity as one side of the ATM\ninterface.  This value does not apply when the object\natmIntfConfigType is set to `autoConfig', `atmfPnni1Dot0', or\n`atmfBici2Dot0'.")
atmIntfActualSide = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(4,3,1,2,)).subtype(namedValues=NamedValues(("other", 1), ("user", 2), ("network", 3), ("symmetric", 4), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIntfActualSide.setDescription("The current role used by the managed entity to represent one\nside of the ATM interface.")
atmIntfIlmiAdminStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 5), Bits().subtype(namedValues=NamedValues(("ilmi", 0), ("ilmiAddressRegistration", 1), ("ilmiConnectivity", 2), ("ilmiPvcPvpMgmt", 3), ("ilmiSigVccParamNegotiation", 4), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIntfIlmiAdminStatus.setDescription("Indicates which components of ILMI are administratively enabled\non this interface.  If the 'ilmi' bit is not set, then no ILMI\ncomponents are operational.  ILMI components other than auto-\nconfiguration that are not represented in the value have their\nadministrative status determined according to the 'ilmi' bit.\nThe ILMI auto-configuration component is enabled/disabled by the\natmIntfConfigType object.")
atmIntfIlmiOperStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 6), Bits().subtype(namedValues=NamedValues(("ilmi", 0), ("ilmiAddressRegistration", 1), ("ilmiConnectivity", 2), ("ilmiPvcPvpMgmt", 3), ("ilmiSigVccParamNegotiation", 4), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIntfIlmiOperStatus.setDescription("Indicates which components of ILMI are operational on this\ninterface.")
atmIntfIlmiFsmState = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 7), Integer().subtype(subtypeSpec=SingleValueConstraint(7,9,6,1,4,5,2,8,3,)).subtype(namedValues=NamedValues(("stopped", 1), ("linkFailing", 2), ("establishing", 3), ("configuring", 4), ("retrievingNetworkPrefixes", 5), ("registeringNetworkPrefixes", 6), ("retrievingAddresses", 7), ("registeringAddresses", 8), ("verifying", 9), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIntfIlmiFsmState.setDescription("Indicates the state of the ILMI Finite State Machine associated\nwith this interface.")
atmIntfIlmiEstablishConPollIntvl = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIntfIlmiEstablishConPollIntvl.setDescription("The amount of time S between successive transmissions of ILMI\nmessages on this interface for the purpose of detecting\nestablishment of ILMI connectivity.")
atmIntfIlmiCheckConPollIntvl = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIntfIlmiCheckConPollIntvl.setDescription("The amount of time T between successive transmissions of ILMI\nmessages on this interface for the purpose of detecting loss of\nILMI connectivity.  The distinguished value zero disables ILMI\nconnectivity procedures on this interface.")
atmIntfIlmiConPollInactFactor = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIntfIlmiConPollInactFactor.setDescription("The number K of consecutive polls on this interface for which no\nILMI response message is received before ILMI connectivity is\ndeclared lost.")
atmIntfIlmiPublicPrivateIndctr = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 11), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,3,)).subtype(namedValues=NamedValues(("other", 1), ("public", 2), ("private", 3), )).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIntfIlmiPublicPrivateIndctr.setDescription("Specifies whether this end of the interface is advertised in\nILMI as a device of the `public' or `private' type.")
atmInterfaceConfMaxSvpcVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmInterfaceConfMaxSvpcVpi.setDescription("The maximum VPI that the signalling stack on the ATM interface\nis configured to support for allocation to switched virtual path\nconnections.")
atmInterfaceCurrentMaxSvpcVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmInterfaceCurrentMaxSvpcVpi.setDescription("The maximum VPI that the signalling stack on the ATM interface\nmay currently allocate to switched virtual path connections.\nThis value is the minimum of atmInterfaceConfMaxSvpcVpi, and the\natmInterfaceMaxSvpcVpi of the interface's UNI/NNI peer.\n\nIf the interface does not negotiate with its peer to determine\nthe maximum VPI that can be allocated to SVPCs on the interface,\nthen the value of this object must equal\natmInterfaceConfMaxSvpcVpi. ")
atmInterfaceConfMaxSvccVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmInterfaceConfMaxSvccVpi.setDescription("The maximum VPI that the signalling stack on the ATM interface\nis configured to support for allocation to switched virtual\nchannel connections.")
atmInterfaceCurrentMaxSvccVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmInterfaceCurrentMaxSvccVpi.setDescription("The maximum VPI that the signalling stack on the ATM interface\nmay currently allocate to switched virtual channel connections.\nThis value is the minimum of atmInterfaceConfMaxSvccVpi, and the\natmInterfaceConfMaxSvccVpi of the interface's UNI/NNI peer.\n\nIf the interface does not negotiate with its peer to determine\nthe maximum VPI that can be allocated to SVCCs on the interface,\nthen the value of this object must equal\natmInterfaceConfMaxSvccVpi.")
atmInterfaceConfMinSvccVci = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmInterfaceConfMinSvccVci.setDescription("The minimum VCI that the signalling stack on the ATM interface\nis configured to support for allocation to switched virtual\nchannel connections.")
atmInterfaceCurrentMinSvccVci = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmInterfaceCurrentMinSvccVci.setDescription("The minimum VCI that the signalling stack on the ATM interface\nmay currently allocate to switched virtual channel connections.\nThis value is the maximum of atmInterfaceConfMinSvccVci, and the\natmInterfaceConfMinSvccVci of the interface's UNI/NNI peer.\nIf the interface does not negotiate with its peer to determine\nthe minimum VCI that can be allocated to SVCCs on the interface,\nthen the value of this object must equal\natmInterfaceConfMinSvccVci.")
atmIntfSigVccRxTrafficDescrIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 18), AtmTrafficDescrParamIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIntfSigVccRxTrafficDescrIndex.setDescription("This object identifies the row in the atmTrafficDescrParamTable\nused during ILMI auto-configuration to specify the advertised\nsignalling VCC traffic parameters for the receive direction.\nThe traffic descriptor resulting from ILMI auto-configuration of\nthe signalling VCC is indicated in the atmVclTable.")
atmIntfSigVccTxTrafficDescrIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 19), AtmTrafficDescrParamIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIntfSigVccTxTrafficDescrIndex.setDescription("This object identifies the row in the atmTrafficDescrParamTable\nused during ILMI auto-configuration to specify the advertised\nsignalling VCC traffic parameters for the transmit direction.\nThe traffic descriptor resulting from ILMI auto-configuration of\nthe signalling VCC is indicated in the atmVclTable.")
atmIntfPvcFailures = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIntfPvcFailures.setDescription("The number of times the operational status of a PVPL or PVCL on\nthis interface has gone down.")
atmIntfCurrentlyFailingPVpls = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 21), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIntfCurrentlyFailingPVpls.setDescription("The current number of VPLs on this interface for which there is\nan active row in the atmVplTable having an atmVplConnKind value\nof `pvc' and an atmVplOperStatus with a value other than `up'.")
atmIntfCurrentlyFailingPVcls = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 22), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIntfCurrentlyFailingPVcls.setDescription("The current number of VCLs on this interface for which there is\nan active row in the atmVclTable having an atmVclConnKind value\nof `pvc' and an atmVclOperStatus with a value other than `up'.")
atmIntfPvcFailuresTrapEnable = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 23), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIntfPvcFailuresTrapEnable.setDescription("Allows the generation of traps in response to PVCL or PVPL\nfailures on this interface.")
atmIntfPvcNotificationInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIntfPvcNotificationInterval.setDescription("The minimum interval between the sending of\natmIntfPvcFailuresTrap notifications for this interface.")
atmIntfLeafSetupFailures = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIntfLeafSetupFailures.setDescription("Number of setup failures.  For root, this is the number of\nrejected setup requests and for leaf, this is the number of setup\nfailure received.")
atmIntfLeafSetupRequests = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIntfLeafSetupRequests.setDescription("Number of setup requests.  For root, this includes both incoming\nsetup request and root intiated setup requests.")
atmIlmiSrvcRegTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 15))
if mibBuilder.loadTexts: atmIlmiSrvcRegTable.setDescription("This table contains a list of all the ATM network services known\nby this device.\n\nThe characteristics of these services are made available through\nthe ILMI, using the ILMI general-purpose service registry MIB.\nThese services may be made available to all ATM interfaces\n(atmIlmiSrvcRegIndex = 0) or to some specific ATM interfaces only\n(atmIlmiSrvcRegIndex = ATM interface index).")
atmIlmiSrvcRegEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 15, 1)).setIndexNames((0, "ATM2-MIB", "atmIlmiSrvcRegIndex"), (0, "ATM2-MIB", "atmIlmiSrvcRegServiceID"), (0, "ATM2-MIB", "atmIlmiSrvcRegAddressIndex"))
if mibBuilder.loadTexts: atmIlmiSrvcRegEntry.setDescription("Information about a single service provider that is available to\nthe user-side of an adjacent device through the ILMI.\n\nImplementors need to be aware that if the size of the\natmIlmiSrvcRegServiceID exceeds 112 sub-identifiers then OIDs of\n\n\n\ncolumn instances in this table will have more than 128 sub-\nidentifiers and cannot be accessed using SNMPv1, SNMPv2, or\nSNMPv3.")
atmIlmiSrvcRegIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 15, 1, 1), InterfaceIndexOrZero()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: atmIlmiSrvcRegIndex.setDescription("The ATM interface where the service defined in this entry can be\nmade available to an ATM device attached to this interface.\n\nThe value of 0 has a special meaning: when an ATM service is\ndefined in an entry whose atmIlmiSrvcRegIndex is zero, the ATM\nservice is available to ATM devices connected to any ATM\ninterface.  (default value(s)).\n\nWhen the user-side of an adjacent device queries the content of\nthe ILMI service registry MIB (using the ILMI protocol), the\nlocal network-side responds with the ATM services defined in\natmIlmiSrvcRegTable entries, provided that these entries are\nindexed by:\n\n- the corresponding ifIndex value (atmIlmiSrvcRegIndex\n  equal to the ifIndex of the interface to which the\n  adjacent device is connected) - zero (atmIlmiSrvcRegIndex=0).")
atmIlmiSrvcRegServiceID = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 15, 1, 2), ObjectIdentifier()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: atmIlmiSrvcRegServiceID.setDescription("This is the service identifier which uniquely identifies the\n\n\n\ntype of service at the address provided in the table.  The object\nidentifiers for the LAN Emulation Configuration Server (LECS) and\nthe ATM Name Server (ANS) are defined in the ATM Forum ILMI\nService Registry MIB.  The object identifiers for the ATMARP\nServer, the Multicast Address Resolution Server (MARS), and the\nNHRP Server (NHS) are defined in RFC 2601, RFC 2602, and RFC\n2603, respectively.")
atmIlmiSrvcRegAddressIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 15, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: atmIlmiSrvcRegAddressIndex.setDescription("An arbitrary integer to differentiate multiple rows containing\ndifferent ATM addresses for the same service on the same\ninterface.  This number need NOT be the same as the corresponding\nILMI atmfSrvcRegAddressIndex MIB object.")
atmIlmiSrvcRegATMAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 15, 1, 4), AtmAddr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmIlmiSrvcRegATMAddress.setDescription("This is the full address of the service.  The user-side of the\nadjacent device may use this address to establish a connection\nwith the service.")
atmIlmiSrvcRegParm1 = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 15, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmIlmiSrvcRegParm1.setDescription("An octet string used according to the value of\natmIlmiSrvcRegServiceID.")
atmIlmiSrvcRegRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 15, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmIlmiSrvcRegRowStatus.setDescription("This object is used to create or destroy an entry from this\ntable.")
atmIlmiNetworkPrefixTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 16))
if mibBuilder.loadTexts: atmIlmiNetworkPrefixTable.setDescription("A table specifying per-interface network prefix(es) supplied by\nthe network side of the UNI during ILMI address registration.\nWhen no network prefixes are specified for a particular\ninterface, one or more network prefixes based on the switch\naddress(es) may be used for ILMI address registration.")
atmIlmiNetworkPrefixEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 16, 1)).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM2-MIB", "atmIlmiNetPrefixPrefix"))
if mibBuilder.loadTexts: atmIlmiNetworkPrefixEntry.setDescription("Information about a single network prefix supplied by the\nnetwork side of the UNI during ILMI address registration.  Note\nthat the index variable atmIlmiNetPrefixPrefix is a variable-\nlength string, and as such the rule for variable-length strings\nin section 7.7 of RFC 2578 applies.")
atmIlmiNetPrefixPrefix = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 16, 1, 1), AtmIlmiNetworkPrefix()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: atmIlmiNetPrefixPrefix.setDescription("The network prefix specified for use in ILMI address\nregistration.")
atmIlmiNetPrefixRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 16, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmIlmiNetPrefixRowStatus.setDescription("Used to create, delete, activate and de-activate network\nprefixes used in ILMI address registration.")
atmSwitchAddressTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 17))
if mibBuilder.loadTexts: atmSwitchAddressTable.setDescription("This table contains one or more ATM endsystem addresses on a\nper-switch basis.  These addresses are used to identify the\nswitch.  When no ILMI network prefixes are configured for certain\ninterfaces, network prefixes based on the switch address(es) may\nbe used for ILMI address registration.")
atmSwitchAddressEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 17, 1)).setIndexNames((0, "ATM2-MIB", "atmSwitchAddressIndex"))
if mibBuilder.loadTexts: atmSwitchAddressEntry.setDescription("An entry in the ATM Switch Address table.")
atmSwitchAddressIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 17, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: atmSwitchAddressIndex.setDescription("An arbitrary index used to enumerate the ATM endsystem addresses\nfor this switch.")
atmSwitchAddressAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 17, 1, 2), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(13,13),ValueSizeConstraint(20,20),))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSwitchAddressAddress.setDescription("An ATM endsystem address or address prefix used to identify this\nswitch.  When no ESI or SEL field is specified, the switch may\ngenerate the ESI and SEL fields automatically to obtain a\ncomplete 20-byte ATM endsystem address.")
atmSwitchAddressRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 17, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSwitchAddressRowStatus.setDescription("Used to create, delete, activate, and de-activate addresses used\nto identify this switch.")
atmVpCrossConnectXTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 18))
if mibBuilder.loadTexts: atmVpCrossConnectXTable.setDescription("This table contains one row per VP Cross-Connect represented in\nthe atmVpCrossConnectTable.")
atmVpCrossConnectXEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 18, 1))
if mibBuilder.loadTexts: atmVpCrossConnectXEntry.setDescription("Information about a particular ATM VP Cross-Connect.\nEach entry provides an two objects that name the Cross-Connect.\nOne is assigned by the Service User and the other by the Service\nProvider.")
atmVpCrossConnectUserName = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 18, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVpCrossConnectUserName.setDescription("This is a service user assigned textual representation of a VPC\nPVC.")
atmVpCrossConnectProviderName = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 18, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpCrossConnectProviderName.setDescription("This is a system supplied textual representation of VPC PVC.  It\nis assigned by the service provider.")
atmVcCrossConnectXTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 19))
if mibBuilder.loadTexts: atmVcCrossConnectXTable.setDescription("This table contains one row per VC Cross-Connect represented in\nthe atmVcCrossConnectTable.")
atmVcCrossConnectXEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 19, 1))
if mibBuilder.loadTexts: atmVcCrossConnectXEntry.setDescription("Information about a particular ATM VC Cross-Connect.\nEach entry provides an two objects that name the Cross-Connect.\nOne is assigned by the Service User and the other by the Service\nProvider.")
atmVcCrossConnectUserName = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 19, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVcCrossConnectUserName.setDescription("This is a service user assigned textual representation of a VCC\n\n\n\nPVC.")
atmVcCrossConnectProviderName = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 19, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcCrossConnectProviderName.setDescription("This is a system supplied textual representation of VCC PVC.  It\nis assigned by the service provider.")
atmCurrentlyFailingPVplTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 20))
if mibBuilder.loadTexts: atmCurrentlyFailingPVplTable.setDescription("A table indicating all VPLs for which there is an active row in\nthe atmVplTable having an atmVplConnKind value of `pvc' and an\natmVplOperStatus with a value other than `up'.")
atmCurrentlyFailingPVplEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 20, 1)).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVplVpi"))
if mibBuilder.loadTexts: atmCurrentlyFailingPVplEntry.setDescription("Each entry in this table represents a VPL for which the\natmVplRowStatus is `active', the atmVplConnKind is `pvc', and the\natmVplOperStatus is other than `up'.")
atmCurrentlyFailingPVplTimeStamp = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 20, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmCurrentlyFailingPVplTimeStamp.setDescription("The time at which this PVPL began to fail.")
atmCurrentlyFailingPVclTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 21))
if mibBuilder.loadTexts: atmCurrentlyFailingPVclTable.setDescription("A table indicating all VCLs for which there is an active row in\nthe atmVclTable having an atmVclConnKind value of `pvc' and an\natmVclOperStatus with a value other than `up'.")
atmCurrentlyFailingPVclEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 21, 1)).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVclVpi"), (0, "ATM-MIB", "atmVclVci"))
if mibBuilder.loadTexts: atmCurrentlyFailingPVclEntry.setDescription("Each entry in this table represents a VCL for which the\natmVclRowStatus is `active', the atmVclConnKind is `pvc', and the\natmVclOperStatus is other than `up'.")
atmCurrentlyFailingPVclTimeStamp = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 21, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmCurrentlyFailingPVclTimeStamp.setDescription("The time at which this PVCL began to fail.")
atm2MIBTraps = MibIdentifier((1, 3, 6, 1, 2, 1, 37, 1, 14, 2))
atmPvcTraps = MibIdentifier((1, 3, 6, 1, 2, 1, 37, 1, 14, 2, 1))
atmPvcTrapsPrefix = MibIdentifier((1, 3, 6, 1, 2, 1, 37, 1, 14, 2, 1, 0))
atm2MIBConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 37, 1, 14, 3))
atm2MIBGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 1))
atm2MIBCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 2))

# Augmentions
atmVclEntry, = mibBuilder.importSymbols("ATM-MIB", "atmVclEntry")
atmVclEntry.registerAugmentions(("ATM2-MIB", "atmVclGenEntry"))
atmVclGenEntry.setIndexNames(*atmVclEntry.getIndexNames())
atmVcCrossConnectEntry, = mibBuilder.importSymbols("ATM-MIB", "atmVcCrossConnectEntry")
atmVcCrossConnectEntry.registerAugmentions(("ATM2-MIB", "atmVcCrossConnectXEntry"))
atmVcCrossConnectXEntry.setIndexNames(*atmVcCrossConnectEntry.getIndexNames())
atmVpCrossConnectEntry, = mibBuilder.importSymbols("ATM-MIB", "atmVpCrossConnectEntry")
atmVpCrossConnectEntry.registerAugmentions(("ATM2-MIB", "atmVpCrossConnectXEntry"))
atmVpCrossConnectXEntry.setIndexNames(*atmVpCrossConnectEntry.getIndexNames())
atmInterfaceConfEntry, = mibBuilder.importSymbols("ATM-MIB", "atmInterfaceConfEntry")
atmInterfaceConfEntry.registerAugmentions(("ATM2-MIB", "atmInterfaceExtEntry"))
atmInterfaceExtEntry.setIndexNames(*atmInterfaceConfEntry.getIndexNames())
atmVplEntry, = mibBuilder.importSymbols("ATM-MIB", "atmVplEntry")
atmVplEntry.registerAugmentions(("ATM2-MIB", "atmVplLogicalPortEntry"))
atmVplLogicalPortEntry.setIndexNames(*atmVplEntry.getIndexNames())

# Notifications

atmIntfPvcFailuresTrap = NotificationType((1, 3, 6, 1, 2, 1, 37, 1, 14, 2, 1, 0, 1)).setObjects(*(("IF-MIB", "ifIndex"), ("ATM2-MIB", "atmIntfCurrentlyFailingPVcls"), ("ATM2-MIB", "atmIntfCurrentlyFailingPVpls"), ("ATM2-MIB", "atmIntfPvcFailures"), ) )
if mibBuilder.loadTexts: atmIntfPvcFailuresTrap.setDescription("A notification indicating that one or more PVPLs or PVCLs on\nthis interface has failed since the last atmPvcFailuresTrap was\nsent.  If this trap has not been sent for the last\natmIntfPvcNotificationInterval, then it will be sent on the next\nincrement of atmIntfPvcFailures.")

# Groups

atmCommonGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 1, 1)).setObjects(*(("ATM2-MIB", "atmIntfPvcFailures"), ("ATM2-MIB", "atmSigEmitSetupAttempts"), ("ATM2-MIB", "atmCurrentlyFailingPVplTimeStamp"), ("ATM2-MIB", "atmIntfCurrentlyFailingPVcls"), ("ATM2-MIB", "atmIntfIlmiConPollInactFactor"), ("ATM2-MIB", "atmIntfSigVccRxTrafficDescrIndex"), ("ATM2-MIB", "atmSigEmitCldPtyEvents"), ("ATM2-MIB", "atmSigDetectCldPtyEvents"), ("ATM2-MIB", "atmSigSSCOPConEvents"), ("ATM2-MIB", "atmSigEmitClgPtyEvents"), ("ATM2-MIB", "atmIntfSigVccTxTrafficDescrIndex"), ("ATM2-MIB", "atmIntfActualType"), ("ATM2-MIB", "atmSigInEstabls"), ("ATM2-MIB", "atmIntfCurrentlyFailingPVpls"), ("ATM2-MIB", "atmInterfaceConfMinSvccVci"), ("ATM2-MIB", "atmIntfIlmiOperStatus"), ("ATM2-MIB", "atmIntfConfigType"), ("ATM2-MIB", "atmIntfIlmiEstablishConPollIntvl"), ("ATM2-MIB", "atmSigOutEstabls"), ("ATM2-MIB", "atmIntfIlmiFsmState"), ("ATM2-MIB", "atmSigEmitTimerExpireds"), ("ATM2-MIB", "atmSigDetectClgPtyEvents"), ("ATM2-MIB", "atmSigEmitRestarts"), ("ATM2-MIB", "atmIntfLeafSetupRequests"), ("ATM2-MIB", "atmVplLogicalPortIndex"), ("ATM2-MIB", "atmIntfActualSide"), ("ATM2-MIB", "atmVplLogicalPortDef"), ("ATM2-MIB", "atmSigDetectRestarts"), ("ATM2-MIB", "atmInterfaceConfMaxSvccVpi"), ("ATM2-MIB", "atmSigDetectMsgErrors"), ("ATM2-MIB", "atmIntfPvcFailuresTrapEnable"), ("ATM2-MIB", "atmIntfPvcNotificationInterval"), ("ATM2-MIB", "atmInterfaceConfMaxSvpcVpi"), ("ATM2-MIB", "atmSigEmitUnavailResrcs"), ("ATM2-MIB", "atmSigSSCOPErrdPdus"), ("ATM2-MIB", "atmInterfaceCurrentMaxSvccVpi"), ("ATM2-MIB", "atmInterfaceCurrentMaxSvpcVpi"), ("ATM2-MIB", "atmSigEmitMsgErrors"), ("ATM2-MIB", "atmIntfIlmiCheckConPollIntvl"), ("ATM2-MIB", "atmSigDetectUnavailRoutes"), ("ATM2-MIB", "atmIntfConfigSide"), ("ATM2-MIB", "atmSigDetectSetupAttempts"), ("ATM2-MIB", "atmCurrentlyFailingPVclTimeStamp"), ("ATM2-MIB", "atmSigDetectTimerExpireds"), ("ATM2-MIB", "atmSigDetectUnavailResrcs"), ("ATM2-MIB", "atmIntfIlmiPublicPrivateIndctr"), ("ATM2-MIB", "atmIntfLeafSetupFailures"), ("ATM2-MIB", "atmInterfaceCurrentMinSvccVci"), ("ATM2-MIB", "atmSigEmitUnavailRoutes"), ("ATM2-MIB", "atmIntfIlmiAdminStatus"), ) )
if mibBuilder.loadTexts: atmCommonGroup.setDescription("A collection of objects providing information\nfor a Switch/Service/Host that implements\nATM interfaces.")
atmCommonStatsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 1, 2)).setObjects(*(("ATM2-MIB", "atmVclStatClp0Tagged"), ("ATM2-MIB", "atmVclStatTotalCellIns"), ("ATM2-MIB", "atmVplStatClp0CellOuts"), ("ATM2-MIB", "atmVplStatTotalDiscards"), ("ATM2-MIB", "atmVplStatClp0Tagged"), ("ATM2-MIB", "atmVclStatClp0Discards"), ("ATM2-MIB", "atmVplStatClp0CellIns"), ("ATM2-MIB", "atmVplStatTotalCellIns"), ("ATM2-MIB", "atmVclStatClp0CellOuts"), ("ATM2-MIB", "atmVclStatTotalCellOuts"), ("ATM2-MIB", "atmVplStatClp0Discards"), ("ATM2-MIB", "atmVclStatClp0CellIns"), ("ATM2-MIB", "atmVclStatTotalDiscards"), ("ATM2-MIB", "atmVplStatTotalCellOuts"), ) )
if mibBuilder.loadTexts: atmCommonStatsGroup.setDescription("A collection of objects providing information\n\n\n\nfor a Switch/Service/Host that implements\nATM VCL and VPL Statistics")
atmSwitchServcGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 1, 3)).setObjects(*(("ATM2-MIB", "atmIfRegAddrOrgScope"), ("ATM2-MIB", "atmIlmiSrvcRegParm1"), ("ATM2-MIB", "atmIlmiSrvcRegRowStatus"), ("ATM2-MIB", "atmIfRegAddrAddressSource"), ("ATM2-MIB", "atmIlmiSrvcRegATMAddress"), ("ATM2-MIB", "atmSvcVpCrossConnectRowStatus"), ("ATM2-MIB", "atmSvcVpCrossConnectCreationTime"), ("ATM2-MIB", "atmSvcVcCrossConnectCreationTime"), ("ATM2-MIB", "atmIfRegAddrRowStatus"), ("ATM2-MIB", "atmSvcVcCrossConnectRowStatus"), ("ATM2-MIB", "atmIlmiNetPrefixRowStatus"), ) )
if mibBuilder.loadTexts: atmSwitchServcGroup.setDescription("A collection of objects providing information\nfor a Switch/Service that implements ATM interfaces.")
atmSwitchServcSigGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 1, 4)).setObjects(*(("ATM2-MIB", "atmSigSupportHiLyrInfo"), ("ATM2-MIB", "atmSigSupportBlliRepeatInd"), ("ATM2-MIB", "atmSigSupportClgPtySubAddr"), ("ATM2-MIB", "atmSigSupportClgPtyNumDel"), ("ATM2-MIB", "atmSigSupportLoLyrInfo"), ("ATM2-MIB", "atmSigSupportCldPtySubAddr"), ("ATM2-MIB", "atmSigSupportAALInfo"), ("ATM2-MIB", "atmSigSupportPrefCarrier"), ) )
if mibBuilder.loadTexts: atmSwitchServcSigGroup.setDescription("A collection of objects providing information\nfor a Switch/Service that implements ATM signalling.")
atmSwitchServcNotifGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 1, 5)).setObjects(*(("ATM2-MIB", "atmIntfPvcFailuresTrap"), ) )
if mibBuilder.loadTexts: atmSwitchServcNotifGroup.setDescription("A collection of notifications providing information\nfor a Switch/Service that implements ATM interfaces.")
atmSwitchGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 1, 6)).setObjects(*(("ATM2-MIB", "atmSwitchAddressAddress"), ("ATM2-MIB", "atmSwitchAddressRowStatus"), ) )
if mibBuilder.loadTexts: atmSwitchGroup.setDescription("A collection of objects providing information\nfor an ATM switch.")
atmServcGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 1, 7)).setObjects(*(("ATM2-MIB", "atmVcCrossConnectProviderName"), ("ATM2-MIB", "atmVcCrossConnectUserName"), ("ATM2-MIB", "atmVpCrossConnectProviderName"), ("ATM2-MIB", "atmVpCrossConnectUserName"), ) )
if mibBuilder.loadTexts: atmServcGroup.setDescription("A collection of objects providing information\nfor an ATM Network Service.")
atmHostGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 1, 8)).setObjects(*(("ATM2-MIB", "atmVclGenSigDescrIndex"), ("ATM2-MIB", "atmAal5VclInPkts"), ("ATM2-MIB", "atmAal5VclOutOctets"), ("ATM2-MIB", "atmVclAddrType"), ("ATM2-MIB", "atmAal5VclInOctets"), ("ATM2-MIB", "atmAddrVclAddrType"), ("ATM2-MIB", "atmVclAddrRowStatus"), ("ATM2-MIB", "atmAal5VclOutPkts"), ) )
if mibBuilder.loadTexts: atmHostGroup.setDescription("A collection of objects providing information\nfor a Host that implements ATM interfaces.")
atmHostSigDescrGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 1, 9)).setObjects(*(("ATM2-MIB", "atmSigDescrParamAalType"), ("ATM2-MIB", "atmSigDescrParamRowStatus"), ("ATM2-MIB", "atmSigDescrParamAalSscsType"), ("ATM2-MIB", "atmSigDescrParamBlliSnapId"), ("ATM2-MIB", "atmSigDescrParamBhliType"), ("ATM2-MIB", "atmSigDescrParamBhliInfo"), ("ATM2-MIB", "atmSigDescrParamBbcConnConf"), ("ATM2-MIB", "atmSigDescrParamBlliOuiPid"), ("ATM2-MIB", "atmSigDescrParamBlliPktSize"), ("ATM2-MIB", "atmSigDescrParamBlliLayer3"), ("ATM2-MIB", "atmSigDescrParamBlliLayer2"), ) )
if mibBuilder.loadTexts: atmHostSigDescrGroup.setDescription("A collection of objects providing information\nfor a Host that implements ATM interfaces.")

# Compliances

atm2MIBCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 2, 1)).setObjects(*(("ATM2-MIB", "atmCommonStatsGroup"), ("ATM2-MIB", "atmSwitchServcGroup"), ("ATM2-MIB", "atmSwitchServcSigGroup"), ("ATM2-MIB", "atmCommonGroup"), ("ATM2-MIB", "atmHostSigDescrGroup"), ("ATM2-MIB", "atmSwitchServcNotifGroup"), ("ATM2-MIB", "atmServcGroup"), ("ATM2-MIB", "atmSwitchGroup"), ("ATM2-MIB", "atmHostGroup"), ) )
if mibBuilder.loadTexts: atm2MIBCompliance.setDescription("The compliance statement for SNMP entities which represent ATM\ninterfaces.  The compliance statements are used to determine\nif a particular group or object applies to hosts,\nnetworks/switches, or both.  The Common group is defined as\napplicable to all three.")

# Exports

# Module identity
mibBuilder.exportSymbols("ATM2-MIB", PYSNMP_MODULE_ID=atm2MIB)

# Objects
mibBuilder.exportSymbols("ATM2-MIB", atm2MIB=atm2MIB, atm2MIBObjects=atm2MIBObjects, atmSvcVpCrossConnectTable=atmSvcVpCrossConnectTable, atmSvcVpCrossConnectEntry=atmSvcVpCrossConnectEntry, atmSvcVpCrossConnectIndex=atmSvcVpCrossConnectIndex, atmSvcVpCrossConnectLowIfIndex=atmSvcVpCrossConnectLowIfIndex, atmSvcVpCrossConnectLowVpi=atmSvcVpCrossConnectLowVpi, atmSvcVpCrossConnectHighIfIndex=atmSvcVpCrossConnectHighIfIndex, atmSvcVpCrossConnectHighVpi=atmSvcVpCrossConnectHighVpi, atmSvcVpCrossConnectCreationTime=atmSvcVpCrossConnectCreationTime, atmSvcVpCrossConnectRowStatus=atmSvcVpCrossConnectRowStatus, atmSvcVcCrossConnectTable=atmSvcVcCrossConnectTable, atmSvcVcCrossConnectEntry=atmSvcVcCrossConnectEntry, atmSvcVcCrossConnectIndex=atmSvcVcCrossConnectIndex, atmSvcVcCrossConnectLowIfIndex=atmSvcVcCrossConnectLowIfIndex, atmSvcVcCrossConnectLowVpi=atmSvcVcCrossConnectLowVpi, atmSvcVcCrossConnectLowVci=atmSvcVcCrossConnectLowVci, atmSvcVcCrossConnectHighIfIndex=atmSvcVcCrossConnectHighIfIndex, atmSvcVcCrossConnectHighVpi=atmSvcVcCrossConnectHighVpi, atmSvcVcCrossConnectHighVci=atmSvcVcCrossConnectHighVci, atmSvcVcCrossConnectCreationTime=atmSvcVcCrossConnectCreationTime, atmSvcVcCrossConnectRowStatus=atmSvcVcCrossConnectRowStatus, atmSigStatTable=atmSigStatTable, atmSigStatEntry=atmSigStatEntry, atmSigSSCOPConEvents=atmSigSSCOPConEvents, atmSigSSCOPErrdPdus=atmSigSSCOPErrdPdus, atmSigDetectSetupAttempts=atmSigDetectSetupAttempts, atmSigEmitSetupAttempts=atmSigEmitSetupAttempts, atmSigDetectUnavailRoutes=atmSigDetectUnavailRoutes, atmSigEmitUnavailRoutes=atmSigEmitUnavailRoutes, atmSigDetectUnavailResrcs=atmSigDetectUnavailResrcs, atmSigEmitUnavailResrcs=atmSigEmitUnavailResrcs, atmSigDetectCldPtyEvents=atmSigDetectCldPtyEvents, atmSigEmitCldPtyEvents=atmSigEmitCldPtyEvents, atmSigDetectMsgErrors=atmSigDetectMsgErrors, atmSigEmitMsgErrors=atmSigEmitMsgErrors, atmSigDetectClgPtyEvents=atmSigDetectClgPtyEvents, atmSigEmitClgPtyEvents=atmSigEmitClgPtyEvents, atmSigDetectTimerExpireds=atmSigDetectTimerExpireds, atmSigEmitTimerExpireds=atmSigEmitTimerExpireds, atmSigDetectRestarts=atmSigDetectRestarts, atmSigEmitRestarts=atmSigEmitRestarts, atmSigInEstabls=atmSigInEstabls, atmSigOutEstabls=atmSigOutEstabls, atmSigSupportTable=atmSigSupportTable, atmSigSupportEntry=atmSigSupportEntry, atmSigSupportClgPtyNumDel=atmSigSupportClgPtyNumDel, atmSigSupportClgPtySubAddr=atmSigSupportClgPtySubAddr, atmSigSupportCldPtySubAddr=atmSigSupportCldPtySubAddr, atmSigSupportHiLyrInfo=atmSigSupportHiLyrInfo, atmSigSupportLoLyrInfo=atmSigSupportLoLyrInfo, atmSigSupportBlliRepeatInd=atmSigSupportBlliRepeatInd, atmSigSupportAALInfo=atmSigSupportAALInfo, atmSigSupportPrefCarrier=atmSigSupportPrefCarrier, atmSigDescrParamTable=atmSigDescrParamTable, atmSigDescrParamEntry=atmSigDescrParamEntry, atmSigDescrParamIndex=atmSigDescrParamIndex, atmSigDescrParamAalType=atmSigDescrParamAalType, atmSigDescrParamAalSscsType=atmSigDescrParamAalSscsType, atmSigDescrParamBhliType=atmSigDescrParamBhliType, atmSigDescrParamBhliInfo=atmSigDescrParamBhliInfo, atmSigDescrParamBbcConnConf=atmSigDescrParamBbcConnConf, atmSigDescrParamBlliLayer2=atmSigDescrParamBlliLayer2, atmSigDescrParamBlliLayer3=atmSigDescrParamBlliLayer3, atmSigDescrParamBlliPktSize=atmSigDescrParamBlliPktSize, atmSigDescrParamBlliSnapId=atmSigDescrParamBlliSnapId, atmSigDescrParamBlliOuiPid=atmSigDescrParamBlliOuiPid, atmSigDescrParamRowStatus=atmSigDescrParamRowStatus, atmIfRegisteredAddrTable=atmIfRegisteredAddrTable, atmIfRegisteredAddrEntry=atmIfRegisteredAddrEntry, atmIfRegAddrAddress=atmIfRegAddrAddress, atmIfRegAddrAddressSource=atmIfRegAddrAddressSource, atmIfRegAddrOrgScope=atmIfRegAddrOrgScope, atmIfRegAddrRowStatus=atmIfRegAddrRowStatus, atmVclAddrTable=atmVclAddrTable, atmVclAddrEntry=atmVclAddrEntry, atmVclAddrAddr=atmVclAddrAddr, atmVclAddrType=atmVclAddrType, atmVclAddrRowStatus=atmVclAddrRowStatus, atmAddrVclTable=atmAddrVclTable, atmAddrVclEntry=atmAddrVclEntry, atmAddrVclAtmIfIndex=atmAddrVclAtmIfIndex, atmAddrVclVpi=atmAddrVclVpi, atmAddrVclVci=atmAddrVclVci, atmAddrVclAddrType=atmAddrVclAddrType, atmVplStatTable=atmVplStatTable, atmVplStatEntry=atmVplStatEntry, atmVplStatTotalCellIns=atmVplStatTotalCellIns, atmVplStatClp0CellIns=atmVplStatClp0CellIns, atmVplStatTotalDiscards=atmVplStatTotalDiscards, atmVplStatClp0Discards=atmVplStatClp0Discards, atmVplStatTotalCellOuts=atmVplStatTotalCellOuts, atmVplStatClp0CellOuts=atmVplStatClp0CellOuts, atmVplStatClp0Tagged=atmVplStatClp0Tagged, atmVplLogicalPortTable=atmVplLogicalPortTable, atmVplLogicalPortEntry=atmVplLogicalPortEntry, atmVplLogicalPortDef=atmVplLogicalPortDef, atmVplLogicalPortIndex=atmVplLogicalPortIndex, atmVclStatTable=atmVclStatTable, atmVclStatEntry=atmVclStatEntry, atmVclStatTotalCellIns=atmVclStatTotalCellIns, atmVclStatClp0CellIns=atmVclStatClp0CellIns, atmVclStatTotalDiscards=atmVclStatTotalDiscards, atmVclStatClp0Discards=atmVclStatClp0Discards, atmVclStatTotalCellOuts=atmVclStatTotalCellOuts, atmVclStatClp0CellOuts=atmVclStatClp0CellOuts, atmVclStatClp0Tagged=atmVclStatClp0Tagged, atmAal5VclStatTable=atmAal5VclStatTable, atmAal5VclStatEntry=atmAal5VclStatEntry, atmAal5VclInPkts=atmAal5VclInPkts, atmAal5VclOutPkts=atmAal5VclOutPkts, atmAal5VclInOctets=atmAal5VclInOctets, atmAal5VclOutOctets=atmAal5VclOutOctets, atmVclGenTable=atmVclGenTable, atmVclGenEntry=atmVclGenEntry, atmVclGenSigDescrIndex=atmVclGenSigDescrIndex, atmInterfaceExtTable=atmInterfaceExtTable, atmInterfaceExtEntry=atmInterfaceExtEntry, atmIntfConfigType=atmIntfConfigType, atmIntfActualType=atmIntfActualType, atmIntfConfigSide=atmIntfConfigSide, atmIntfActualSide=atmIntfActualSide, atmIntfIlmiAdminStatus=atmIntfIlmiAdminStatus, atmIntfIlmiOperStatus=atmIntfIlmiOperStatus, atmIntfIlmiFsmState=atmIntfIlmiFsmState, atmIntfIlmiEstablishConPollIntvl=atmIntfIlmiEstablishConPollIntvl)
mibBuilder.exportSymbols("ATM2-MIB", atmIntfIlmiCheckConPollIntvl=atmIntfIlmiCheckConPollIntvl, atmIntfIlmiConPollInactFactor=atmIntfIlmiConPollInactFactor, atmIntfIlmiPublicPrivateIndctr=atmIntfIlmiPublicPrivateIndctr, atmInterfaceConfMaxSvpcVpi=atmInterfaceConfMaxSvpcVpi, atmInterfaceCurrentMaxSvpcVpi=atmInterfaceCurrentMaxSvpcVpi, atmInterfaceConfMaxSvccVpi=atmInterfaceConfMaxSvccVpi, atmInterfaceCurrentMaxSvccVpi=atmInterfaceCurrentMaxSvccVpi, atmInterfaceConfMinSvccVci=atmInterfaceConfMinSvccVci, atmInterfaceCurrentMinSvccVci=atmInterfaceCurrentMinSvccVci, atmIntfSigVccRxTrafficDescrIndex=atmIntfSigVccRxTrafficDescrIndex, atmIntfSigVccTxTrafficDescrIndex=atmIntfSigVccTxTrafficDescrIndex, atmIntfPvcFailures=atmIntfPvcFailures, atmIntfCurrentlyFailingPVpls=atmIntfCurrentlyFailingPVpls, atmIntfCurrentlyFailingPVcls=atmIntfCurrentlyFailingPVcls, atmIntfPvcFailuresTrapEnable=atmIntfPvcFailuresTrapEnable, atmIntfPvcNotificationInterval=atmIntfPvcNotificationInterval, atmIntfLeafSetupFailures=atmIntfLeafSetupFailures, atmIntfLeafSetupRequests=atmIntfLeafSetupRequests, atmIlmiSrvcRegTable=atmIlmiSrvcRegTable, atmIlmiSrvcRegEntry=atmIlmiSrvcRegEntry, atmIlmiSrvcRegIndex=atmIlmiSrvcRegIndex, atmIlmiSrvcRegServiceID=atmIlmiSrvcRegServiceID, atmIlmiSrvcRegAddressIndex=atmIlmiSrvcRegAddressIndex, atmIlmiSrvcRegATMAddress=atmIlmiSrvcRegATMAddress, atmIlmiSrvcRegParm1=atmIlmiSrvcRegParm1, atmIlmiSrvcRegRowStatus=atmIlmiSrvcRegRowStatus, atmIlmiNetworkPrefixTable=atmIlmiNetworkPrefixTable, atmIlmiNetworkPrefixEntry=atmIlmiNetworkPrefixEntry, atmIlmiNetPrefixPrefix=atmIlmiNetPrefixPrefix, atmIlmiNetPrefixRowStatus=atmIlmiNetPrefixRowStatus, atmSwitchAddressTable=atmSwitchAddressTable, atmSwitchAddressEntry=atmSwitchAddressEntry, atmSwitchAddressIndex=atmSwitchAddressIndex, atmSwitchAddressAddress=atmSwitchAddressAddress, atmSwitchAddressRowStatus=atmSwitchAddressRowStatus, atmVpCrossConnectXTable=atmVpCrossConnectXTable, atmVpCrossConnectXEntry=atmVpCrossConnectXEntry, atmVpCrossConnectUserName=atmVpCrossConnectUserName, atmVpCrossConnectProviderName=atmVpCrossConnectProviderName, atmVcCrossConnectXTable=atmVcCrossConnectXTable, atmVcCrossConnectXEntry=atmVcCrossConnectXEntry, atmVcCrossConnectUserName=atmVcCrossConnectUserName, atmVcCrossConnectProviderName=atmVcCrossConnectProviderName, atmCurrentlyFailingPVplTable=atmCurrentlyFailingPVplTable, atmCurrentlyFailingPVplEntry=atmCurrentlyFailingPVplEntry, atmCurrentlyFailingPVplTimeStamp=atmCurrentlyFailingPVplTimeStamp, atmCurrentlyFailingPVclTable=atmCurrentlyFailingPVclTable, atmCurrentlyFailingPVclEntry=atmCurrentlyFailingPVclEntry, atmCurrentlyFailingPVclTimeStamp=atmCurrentlyFailingPVclTimeStamp, atm2MIBTraps=atm2MIBTraps, atmPvcTraps=atmPvcTraps, atmPvcTrapsPrefix=atmPvcTrapsPrefix, atm2MIBConformance=atm2MIBConformance, atm2MIBGroups=atm2MIBGroups, atm2MIBCompliances=atm2MIBCompliances)

# Notifications
mibBuilder.exportSymbols("ATM2-MIB", atmIntfPvcFailuresTrap=atmIntfPvcFailuresTrap)

# Groups
mibBuilder.exportSymbols("ATM2-MIB", atmCommonGroup=atmCommonGroup, atmCommonStatsGroup=atmCommonStatsGroup, atmSwitchServcGroup=atmSwitchServcGroup, atmSwitchServcSigGroup=atmSwitchServcSigGroup, atmSwitchServcNotifGroup=atmSwitchServcNotifGroup, atmSwitchGroup=atmSwitchGroup, atmServcGroup=atmServcGroup, atmHostGroup=atmHostGroup, atmHostSigDescrGroup=atmHostSigDescrGroup)

# Compliances
mibBuilder.exportSymbols("ATM2-MIB", atm2MIBCompliance=atm2MIBCompliance)
