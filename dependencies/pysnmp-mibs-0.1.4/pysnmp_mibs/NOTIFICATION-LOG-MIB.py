# PySNMP SMI module. Autogenerated from smidump -f python NOTIFICATION-LOG-MIB
# by libsmi2pysnmp-0.1.3 at Mon Apr  2 20:39:24 2012,
# Python version sys.version_info(major=2, minor=7, micro=2, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( SnmpAdminString, SnmpEngineID, ) = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString", "SnmpEngineID")
( ModuleCompliance, ObjectGroup, NotificationGroup) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
( Bits, Counter32, Counter64, Integer32, Integer32, IpAddress, ModuleIdentity, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, Opaque, TimeTicks, TimeTicks, Unsigned32, mib_2, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "Counter64", "Integer32", "Integer32", "IpAddress", "ModuleIdentity", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Opaque", "TimeTicks", "TimeTicks", "Unsigned32", "mib-2")
( DateAndTime, RowStatus, StorageType, TAddress, TDomain, TimeStamp, ) = mibBuilder.importSymbols("SNMPv2-TC", "DateAndTime", "RowStatus", "StorageType", "TAddress", "TDomain", "TimeStamp")

# Objects

notificationLogMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 92)).setRevisions(("2000-11-27 00:00",))
if mibBuilder.loadTexts: notificationLogMIB.setOrganization("IETF Distributed Management Working Group")
if mibBuilder.loadTexts: notificationLogMIB.setContactInfo("Ramanathan Kavasseri\nCisco Systems, Inc.\n170 West Tasman Drive,\nSan Jose CA 95134-1706.\nPhone: +1 408 527 2446\nEmail: ramk@cisco.com")
if mibBuilder.loadTexts: notificationLogMIB.setDescription("The MIB module for logging SNMP Notifications, that is, Traps\n\n\nand Informs.")
notificationLogMIBObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 92, 1))
nlmConfig = MibIdentifier((1, 3, 6, 1, 2, 1, 92, 1, 1))
nlmConfigGlobalEntryLimit = MibScalar((1, 3, 6, 1, 2, 1, 92, 1, 1, 1), Unsigned32().clone(0)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlmConfigGlobalEntryLimit.setDescription("The maximum number of notification entries that may be held\nin nlmLogTable for all nlmLogNames added together.  A particular\nsetting does not guarantee that much data can be held.\n\nIf an application changes the limit while there are\nNotifications in the log, the oldest Notifications MUST be\ndiscarded to bring the log down to the new limit - thus the\nvalue of nlmConfigGlobalEntryLimit MUST take precedence over\nthe values of nlmConfigGlobalAgeOut and nlmConfigLogEntryLimit,\neven if the Notification being discarded has been present for\nfewer minutes than the value of nlmConfigGlobalAgeOut, or if\nthe named log has fewer entries than that specified in\nnlmConfigLogEntryLimit.\n\nA value of 0 means no limit.\n\nPlease be aware that contention between multiple managers\ntrying to set this object to different values MAY affect the\nreliability and completeness of data seen by each manager.")
nlmConfigGlobalAgeOut = MibScalar((1, 3, 6, 1, 2, 1, 92, 1, 1, 2), Unsigned32().clone(1440)).setMaxAccess("readwrite").setUnits("minutes")
if mibBuilder.loadTexts: nlmConfigGlobalAgeOut.setDescription("The number of minutes a Notification SHOULD be kept in a log\nbefore it is automatically removed.\n\nIf an application changes the value of nlmConfigGlobalAgeOut,\nNotifications older than the new time MAY be discarded to meet the\nnew time.\n\nA value of 0 means no age out.\n\nPlease be aware that contention between multiple managers\ntrying to set this object to different values MAY affect the\nreliability and completeness of data seen by each manager.")
nlmConfigLogTable = MibTable((1, 3, 6, 1, 2, 1, 92, 1, 1, 3))
if mibBuilder.loadTexts: nlmConfigLogTable.setDescription("A table of logging control entries.")
nlmConfigLogEntry = MibTableRow((1, 3, 6, 1, 2, 1, 92, 1, 1, 3, 1)).setIndexNames((0, "NOTIFICATION-LOG-MIB", "nlmLogName"))
if mibBuilder.loadTexts: nlmConfigLogEntry.setDescription("A logging control entry.  Depending on the entry's storage type\nentries may be supplied by the system or created and deleted by\napplications using nlmConfigLogEntryStatus.")
nlmLogName = MibTableColumn((1, 3, 6, 1, 2, 1, 92, 1, 1, 3, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: nlmLogName.setDescription("The name of the log.\n\nAn implementation may allow multiple named logs, up to some\nimplementation-specific limit (which may be none).  A\nzero-length log name is reserved for creation and deletion by\nthe managed system, and MUST be used as the default log name by\nsystems that do not support named logs.")
nlmConfigLogFilterName = MibTableColumn((1, 3, 6, 1, 2, 1, 92, 1, 1, 3, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)).clone('')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nlmConfigLogFilterName.setDescription("A value of snmpNotifyFilterProfileName as used as an index\ninto the snmpNotifyFilterTable in the SNMP Notification MIB,\nspecifying the locally or remotely originated Notifications\nto be filtered out and not logged in this log.\n\nA zero-length value or a name that does not identify an\nexisting entry in snmpNotifyFilterTable indicate no\nNotifications are to be logged in this log.")
nlmConfigLogEntryLimit = MibTableColumn((1, 3, 6, 1, 2, 1, 92, 1, 1, 3, 1, 3), Unsigned32().clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nlmConfigLogEntryLimit.setDescription("The maximum number of notification entries that can be held in\nnlmLogTable for this named log.  A particular setting does not\nguarantee that that much data can be held.\n\nIf an application changes the limit while there are\nNotifications in the log, the oldest Notifications are discarded\nto bring the log down to the new limit.\n\n\n\nA value of 0 indicates no limit.\n\nPlease be aware that contention between multiple managers\ntrying to set this object to different values MAY affect the\nreliability and completeness of data seen by each manager.")
nlmConfigLogAdminStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 92, 1, 1, 3, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nlmConfigLogAdminStatus.setDescription("Control to enable or disable the log without otherwise\ndisturbing the log's entry.\n\nPlease be aware that contention between multiple managers\ntrying to set this object to different values MAY affect the\nreliability and completeness of data seen by each manager.")
nlmConfigLogOperStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 92, 1, 1, 3, 1, 5), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,3,)).subtype(namedValues=NamedValues(("disabled", 1), ("operational", 2), ("noFilter", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlmConfigLogOperStatus.setDescription("The operational status of this log:\n\ndisabled  administratively disabled\n\noperational    administratively enabled and working\n\nnoFilter  administratively enabled but either\n          nlmConfigLogFilterName is zero length\n          or does not name an existing entry in\n          snmpNotifyFilterTable")
nlmConfigLogStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 92, 1, 1, 3, 1, 6), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nlmConfigLogStorageType.setDescription("The storage type of this conceptual row.")
nlmConfigLogEntryStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 92, 1, 1, 3, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nlmConfigLogEntryStatus.setDescription("Control for creating and deleting entries.  Entries may be\nmodified while active.\n\nFor non-null-named logs, the managed system records the security\ncredentials from the request that sets nlmConfigLogStatus\nto 'active' and uses that identity to apply access control to\nthe objects in the Notification to decide if that Notification\nmay be logged.")
nlmStats = MibIdentifier((1, 3, 6, 1, 2, 1, 92, 1, 2))
nlmStatsGlobalNotificationsLogged = MibScalar((1, 3, 6, 1, 2, 1, 92, 1, 2, 1), Counter32()).setMaxAccess("readonly").setUnits("notifications")
if mibBuilder.loadTexts: nlmStatsGlobalNotificationsLogged.setDescription("The number of Notifications put into the nlmLogTable.  This\ncounts a Notification once for each log entry, so a Notification\n put into multiple logs is counted multiple times.")
nlmStatsGlobalNotificationsBumped = MibScalar((1, 3, 6, 1, 2, 1, 92, 1, 2, 2), Counter32()).setMaxAccess("readonly").setUnits("notifications")
if mibBuilder.loadTexts: nlmStatsGlobalNotificationsBumped.setDescription("The number of log entries discarded to make room for a new entry\ndue to lack of resources or the value of nlmConfigGlobalEntryLimit\nor nlmConfigLogEntryLimit.  This does not include entries discarded\ndue to the value of nlmConfigGlobalAgeOut.")
nlmStatsLogTable = MibTable((1, 3, 6, 1, 2, 1, 92, 1, 2, 3))
if mibBuilder.loadTexts: nlmStatsLogTable.setDescription("A table of Notification log statistics entries.")
nlmStatsLogEntry = MibTableRow((1, 3, 6, 1, 2, 1, 92, 1, 2, 3, 1))
if mibBuilder.loadTexts: nlmStatsLogEntry.setDescription("A Notification log statistics entry.")
nlmStatsLogNotificationsLogged = MibTableColumn((1, 3, 6, 1, 2, 1, 92, 1, 2, 3, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlmStatsLogNotificationsLogged.setDescription("The number of Notifications put in this named log.")
nlmStatsLogNotificationsBumped = MibTableColumn((1, 3, 6, 1, 2, 1, 92, 1, 2, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlmStatsLogNotificationsBumped.setDescription("The number of log entries discarded from this named log to make\nroom for a new entry due to lack of resources or the value of\nnlmConfigGlobalEntryLimit or nlmConfigLogEntryLimit.  This does not\ninclude entries discarded due to the value of\nnlmConfigGlobalAgeOut.")
nlmLog = MibIdentifier((1, 3, 6, 1, 2, 1, 92, 1, 3))
nlmLogTable = MibTable((1, 3, 6, 1, 2, 1, 92, 1, 3, 1))
if mibBuilder.loadTexts: nlmLogTable.setDescription("A table of Notification log entries.\n\nIt is an implementation-specific matter whether entries in this\ntable are preserved across initializations of the management\nsystem.  In general one would expect that they are not.\n\nNote that keeping entries across initializations of the\nmanagement system leads to some confusion with counters and\nTimeStamps, since both of those are based on sysUpTime, which\nresets on management initialization.  In this situation,\ncounters apply only after the reset and nlmLogTime for entries\nmade before the reset MUST be set to 0.")
nlmLogEntry = MibTableRow((1, 3, 6, 1, 2, 1, 92, 1, 3, 1, 1)).setIndexNames((0, "NOTIFICATION-LOG-MIB", "nlmLogName"), (0, "NOTIFICATION-LOG-MIB", "nlmLogIndex"))
if mibBuilder.loadTexts: nlmLogEntry.setDescription("A Notification log entry.\n\nEntries appear in this table when Notifications occur and pass\nfiltering by nlmConfigLogFilterName and access control.  They are\nremoved to make way for new entries due to lack of resources or\nthe values of nlmConfigGlobalEntryLimit, nlmConfigGlobalAgeOut, or\nnlmConfigLogEntryLimit.\n\nIf adding an entry would exceed nlmConfigGlobalEntryLimit or system\nresources in general, the oldest entry in any log SHOULD be removed\nto make room for the new one.\n\nIf adding an entry would exceed nlmConfigLogEntryLimit the oldest\nentry in that log SHOULD be removed to make room for the new one.\n\nBefore the managed system puts a locally-generated Notification\ninto a non-null-named log it assures that the creator of the log\nhas access to the information in the Notification.  If not it\ndoes not log that Notification in that log.")
nlmLogIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 92, 1, 3, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: nlmLogIndex.setDescription("A monotonically increasing integer for the sole purpose of\nindexing entries within the named log.  When it reaches the\nmaximum value, an extremely unlikely event, the agent wraps the\nvalue back to 1.")
nlmLogTime = MibTableColumn((1, 3, 6, 1, 2, 1, 92, 1, 3, 1, 1, 2), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlmLogTime.setDescription("The value of sysUpTime when the entry was placed in the log. If\nthe entry occurred before the most recent management system\ninitialization this object value MUST be set to zero.")
nlmLogDateAndTime = MibTableColumn((1, 3, 6, 1, 2, 1, 92, 1, 3, 1, 1, 3), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlmLogDateAndTime.setDescription("The local date and time when the entry was logged, instantiated\nonly by systems that have date and time capability.")
nlmLogEngineID = MibTableColumn((1, 3, 6, 1, 2, 1, 92, 1, 3, 1, 1, 4), SnmpEngineID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlmLogEngineID.setDescription("The identification of the SNMP engine at which the Notification\n\n\noriginated.\n\nIf the log can contain Notifications from only one engine\nor the Trap is in SNMPv1 format, this object is a zero-length\nstring.")
nlmLogEngineTAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 92, 1, 3, 1, 1, 5), TAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlmLogEngineTAddress.setDescription("The transport service address of the SNMP engine from which the\nNotification was received, formatted according to the corresponding\nvalue of nlmLogEngineTDomain. This is used to identify the source\nof an SNMPv1 trap, since an nlmLogEngineId cannot be extracted\nfrom the SNMPv1 trap pdu.\n\nThis object MUST always be instantiated, even if the log\ncan contain Notifications from only one engine.\n\nPlease be aware that the nlmLogEngineTAddress may not uniquely\nidentify the SNMP engine from which the Notification was received.\nFor example, if an SNMP engine uses DHCP or NAT to obtain\nip addresses, the address it uses may be shared with other\nnetwork devices, and hence will not uniquely identify the\nSNMP engine.")
nlmLogEngineTDomain = MibTableColumn((1, 3, 6, 1, 2, 1, 92, 1, 3, 1, 1, 6), TDomain()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlmLogEngineTDomain.setDescription("Indicates the kind of transport service by which a Notification\nwas received from an SNMP engine. nlmLogEngineTAddress contains\nthe transport service address of the SNMP engine from which\nthis Notification was received.\n\nPossible values for this object are presently found in the\nTransport Mappings for SNMPv2 document (RFC 1906 [8]).")
nlmLogContextEngineID = MibTableColumn((1, 3, 6, 1, 2, 1, 92, 1, 3, 1, 1, 7), SnmpEngineID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlmLogContextEngineID.setDescription("If the Notification was received in a protocol which has a\ncontextEngineID element like SNMPv3, this object has that value.\nOtherwise its value is a zero-length string.")
nlmLogContextName = MibTableColumn((1, 3, 6, 1, 2, 1, 92, 1, 3, 1, 1, 8), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlmLogContextName.setDescription("The name of the SNMP MIB context from which the Notification came.\nFor SNMPv1 Traps this is the community string from the Trap.")
nlmLogNotificationID = MibTableColumn((1, 3, 6, 1, 2, 1, 92, 1, 3, 1, 1, 9), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlmLogNotificationID.setDescription("The NOTIFICATION-TYPE object identifier of the Notification that\noccurred.")
nlmLogVariableTable = MibTable((1, 3, 6, 1, 2, 1, 92, 1, 3, 2))
if mibBuilder.loadTexts: nlmLogVariableTable.setDescription("A table of variables to go with Notification log entries.")
nlmLogVariableEntry = MibTableRow((1, 3, 6, 1, 2, 1, 92, 1, 3, 2, 1)).setIndexNames((0, "NOTIFICATION-LOG-MIB", "nlmLogName"), (0, "NOTIFICATION-LOG-MIB", "nlmLogIndex"), (0, "NOTIFICATION-LOG-MIB", "nlmLogVariableIndex"))
if mibBuilder.loadTexts: nlmLogVariableEntry.setDescription("A Notification log entry variable.\n\nEntries appear in this table when there are variables in\nthe varbind list of a Notification in nlmLogTable.")
nlmLogVariableIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 92, 1, 3, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: nlmLogVariableIndex.setDescription("A monotonically increasing integer, starting at 1 for a given\nnlmLogIndex, for indexing variables within the logged\nNotification.")
nlmLogVariableID = MibTableColumn((1, 3, 6, 1, 2, 1, 92, 1, 3, 2, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlmLogVariableID.setDescription("The variable's object identifier.")
nlmLogVariableValueType = MibTableColumn((1, 3, 6, 1, 2, 1, 92, 1, 3, 2, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(4,6,7,5,3,8,2,9,1,)).subtype(namedValues=NamedValues(("counter32", 1), ("unsigned32", 2), ("timeTicks", 3), ("integer32", 4), ("ipAddress", 5), ("octetString", 6), ("objectId", 7), ("counter64", 8), ("opaque", 9), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlmLogVariableValueType.setDescription("The type of the value.  One and only one of the value\nobjects that follow must be instantiated, based on this type.")
nlmLogVariableCounter32Val = MibTableColumn((1, 3, 6, 1, 2, 1, 92, 1, 3, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlmLogVariableCounter32Val.setDescription("The value when nlmLogVariableType is 'counter32'.")
nlmLogVariableUnsigned32Val = MibTableColumn((1, 3, 6, 1, 2, 1, 92, 1, 3, 2, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlmLogVariableUnsigned32Val.setDescription("The value when nlmLogVariableType is 'unsigned32'.")
nlmLogVariableTimeTicksVal = MibTableColumn((1, 3, 6, 1, 2, 1, 92, 1, 3, 2, 1, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlmLogVariableTimeTicksVal.setDescription("The value when nlmLogVariableType is 'timeTicks'.")
nlmLogVariableInteger32Val = MibTableColumn((1, 3, 6, 1, 2, 1, 92, 1, 3, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlmLogVariableInteger32Val.setDescription("The value when nlmLogVariableType is 'integer32'.")
nlmLogVariableOctetStringVal = MibTableColumn((1, 3, 6, 1, 2, 1, 92, 1, 3, 2, 1, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlmLogVariableOctetStringVal.setDescription("The value when nlmLogVariableType is 'octetString'.")
nlmLogVariableIpAddressVal = MibTableColumn((1, 3, 6, 1, 2, 1, 92, 1, 3, 2, 1, 9), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlmLogVariableIpAddressVal.setDescription("The value when nlmLogVariableType is 'ipAddress'.\nAlthough this seems to be unfriendly for IPv6, we\nhave to recognize that there are a number of older\nMIBs that do contain an IPv4 format address, known\nas IpAddress.\n\nIPv6 addresses are represented using TAddress or\nInetAddress, and so the underlying datatype is\n\n\nOCTET STRING, and their value would be stored in\nthe nlmLogVariableOctetStringVal column.")
nlmLogVariableOidVal = MibTableColumn((1, 3, 6, 1, 2, 1, 92, 1, 3, 2, 1, 10), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlmLogVariableOidVal.setDescription("The value when nlmLogVariableType is 'objectId'.")
nlmLogVariableCounter64Val = MibTableColumn((1, 3, 6, 1, 2, 1, 92, 1, 3, 2, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlmLogVariableCounter64Val.setDescription("The value when nlmLogVariableType is 'counter64'.")
nlmLogVariableOpaqueVal = MibTableColumn((1, 3, 6, 1, 2, 1, 92, 1, 3, 2, 1, 12), Opaque()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlmLogVariableOpaqueVal.setDescription("The value when nlmLogVariableType is 'opaque'.")
notificationLogMIBConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 92, 3))
notificationLogMIBCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 92, 3, 1))
notificationLogMIBGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 92, 3, 2))

# Augmentions
nlmConfigLogEntry.registerAugmentions(("NOTIFICATION-LOG-MIB", "nlmStatsLogEntry"))
nlmStatsLogEntry.setIndexNames(*nlmConfigLogEntry.getIndexNames())

# Groups

notificationLogConfigGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 92, 3, 2, 1)).setObjects(*(("NOTIFICATION-LOG-MIB", "nlmConfigGlobalEntryLimit"), ("NOTIFICATION-LOG-MIB", "nlmConfigLogFilterName"), ("NOTIFICATION-LOG-MIB", "nlmConfigLogStorageType"), ("NOTIFICATION-LOG-MIB", "nlmConfigLogEntryStatus"), ("NOTIFICATION-LOG-MIB", "nlmConfigGlobalAgeOut"), ("NOTIFICATION-LOG-MIB", "nlmConfigLogAdminStatus"), ("NOTIFICATION-LOG-MIB", "nlmConfigLogOperStatus"), ("NOTIFICATION-LOG-MIB", "nlmConfigLogEntryLimit"), ) )
if mibBuilder.loadTexts: notificationLogConfigGroup.setDescription("Notification log configuration management.")
notificationLogStatsGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 92, 3, 2, 2)).setObjects(*(("NOTIFICATION-LOG-MIB", "nlmStatsGlobalNotificationsLogged"), ("NOTIFICATION-LOG-MIB", "nlmStatsLogNotificationsLogged"), ("NOTIFICATION-LOG-MIB", "nlmStatsGlobalNotificationsBumped"), ("NOTIFICATION-LOG-MIB", "nlmStatsLogNotificationsBumped"), ) )
if mibBuilder.loadTexts: notificationLogStatsGroup.setDescription("Notification log statistics.")
notificationLogLogGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 92, 3, 2, 3)).setObjects(*(("NOTIFICATION-LOG-MIB", "nlmLogEngineID"), ("NOTIFICATION-LOG-MIB", "nlmLogContextName"), ("NOTIFICATION-LOG-MIB", "nlmLogVariableCounter32Val"), ("NOTIFICATION-LOG-MIB", "nlmLogVariableOctetStringVal"), ("NOTIFICATION-LOG-MIB", "nlmLogVariableIpAddressVal"), ("NOTIFICATION-LOG-MIB", "nlmLogVariableInteger32Val"), ("NOTIFICATION-LOG-MIB", "nlmLogVariableOpaqueVal"), ("NOTIFICATION-LOG-MIB", "nlmLogVariableUnsigned32Val"), ("NOTIFICATION-LOG-MIB", "nlmLogContextEngineID"), ("NOTIFICATION-LOG-MIB", "nlmLogNotificationID"), ("NOTIFICATION-LOG-MIB", "nlmLogEngineTDomain"), ("NOTIFICATION-LOG-MIB", "nlmLogVariableCounter64Val"), ("NOTIFICATION-LOG-MIB", "nlmLogEngineTAddress"), ("NOTIFICATION-LOG-MIB", "nlmLogTime"), ("NOTIFICATION-LOG-MIB", "nlmLogVariableID"), ("NOTIFICATION-LOG-MIB", "nlmLogVariableValueType"), ("NOTIFICATION-LOG-MIB", "nlmLogVariableOidVal"), ("NOTIFICATION-LOG-MIB", "nlmLogVariableTimeTicksVal"), ) )
if mibBuilder.loadTexts: notificationLogLogGroup.setDescription("Notification log data.")
notificationLogDateGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 92, 3, 2, 4)).setObjects(*(("NOTIFICATION-LOG-MIB", "nlmLogDateAndTime"), ) )
if mibBuilder.loadTexts: notificationLogDateGroup.setDescription("Conditionally mandatory notification log data.\nThis group is mandatory on systems that keep wall\nclock date and time and should not be implemented\non systems that do not have a wall clock date.")

# Compliances

notificationLogMIBCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 92, 3, 1, 1)).setObjects(*(("NOTIFICATION-LOG-MIB", "notificationLogDateGroup"), ("NOTIFICATION-LOG-MIB", "notificationLogStatsGroup"), ("NOTIFICATION-LOG-MIB", "notificationLogConfigGroup"), ("NOTIFICATION-LOG-MIB", "notificationLogLogGroup"), ) )
if mibBuilder.loadTexts: notificationLogMIBCompliance.setDescription("The compliance statement for entities which implement\nthe Notification Log MIB.")

# Exports

# Module identity
mibBuilder.exportSymbols("NOTIFICATION-LOG-MIB", PYSNMP_MODULE_ID=notificationLogMIB)

# Objects
mibBuilder.exportSymbols("NOTIFICATION-LOG-MIB", notificationLogMIB=notificationLogMIB, notificationLogMIBObjects=notificationLogMIBObjects, nlmConfig=nlmConfig, nlmConfigGlobalEntryLimit=nlmConfigGlobalEntryLimit, nlmConfigGlobalAgeOut=nlmConfigGlobalAgeOut, nlmConfigLogTable=nlmConfigLogTable, nlmConfigLogEntry=nlmConfigLogEntry, nlmLogName=nlmLogName, nlmConfigLogFilterName=nlmConfigLogFilterName, nlmConfigLogEntryLimit=nlmConfigLogEntryLimit, nlmConfigLogAdminStatus=nlmConfigLogAdminStatus, nlmConfigLogOperStatus=nlmConfigLogOperStatus, nlmConfigLogStorageType=nlmConfigLogStorageType, nlmConfigLogEntryStatus=nlmConfigLogEntryStatus, nlmStats=nlmStats, nlmStatsGlobalNotificationsLogged=nlmStatsGlobalNotificationsLogged, nlmStatsGlobalNotificationsBumped=nlmStatsGlobalNotificationsBumped, nlmStatsLogTable=nlmStatsLogTable, nlmStatsLogEntry=nlmStatsLogEntry, nlmStatsLogNotificationsLogged=nlmStatsLogNotificationsLogged, nlmStatsLogNotificationsBumped=nlmStatsLogNotificationsBumped, nlmLog=nlmLog, nlmLogTable=nlmLogTable, nlmLogEntry=nlmLogEntry, nlmLogIndex=nlmLogIndex, nlmLogTime=nlmLogTime, nlmLogDateAndTime=nlmLogDateAndTime, nlmLogEngineID=nlmLogEngineID, nlmLogEngineTAddress=nlmLogEngineTAddress, nlmLogEngineTDomain=nlmLogEngineTDomain, nlmLogContextEngineID=nlmLogContextEngineID, nlmLogContextName=nlmLogContextName, nlmLogNotificationID=nlmLogNotificationID, nlmLogVariableTable=nlmLogVariableTable, nlmLogVariableEntry=nlmLogVariableEntry, nlmLogVariableIndex=nlmLogVariableIndex, nlmLogVariableID=nlmLogVariableID, nlmLogVariableValueType=nlmLogVariableValueType, nlmLogVariableCounter32Val=nlmLogVariableCounter32Val, nlmLogVariableUnsigned32Val=nlmLogVariableUnsigned32Val, nlmLogVariableTimeTicksVal=nlmLogVariableTimeTicksVal, nlmLogVariableInteger32Val=nlmLogVariableInteger32Val, nlmLogVariableOctetStringVal=nlmLogVariableOctetStringVal, nlmLogVariableIpAddressVal=nlmLogVariableIpAddressVal, nlmLogVariableOidVal=nlmLogVariableOidVal, nlmLogVariableCounter64Val=nlmLogVariableCounter64Val, nlmLogVariableOpaqueVal=nlmLogVariableOpaqueVal, notificationLogMIBConformance=notificationLogMIBConformance, notificationLogMIBCompliances=notificationLogMIBCompliances, notificationLogMIBGroups=notificationLogMIBGroups)

# Groups
mibBuilder.exportSymbols("NOTIFICATION-LOG-MIB", notificationLogConfigGroup=notificationLogConfigGroup, notificationLogStatsGroup=notificationLogStatsGroup, notificationLogLogGroup=notificationLogLogGroup, notificationLogDateGroup=notificationLogDateGroup)

# Compliances
mibBuilder.exportSymbols("NOTIFICATION-LOG-MIB", notificationLogMIBCompliance=notificationLogMIBCompliance)
