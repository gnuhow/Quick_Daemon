# PySNMP SMI module. Autogenerated from smidump -f python P-BRIDGE-MIB
# by libsmi2pysnmp-0.1.3 at Mon Apr  2 20:39:25 2012,
# Python version sys.version_info(major=2, minor=7, micro=2, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( dot1dBasePort, dot1dBasePortEntry, dot1dBridge, dot1dTp, dot1dTpPort, ) = mibBuilder.importSymbols("BRIDGE-MIB", "dot1dBasePort", "dot1dBasePortEntry", "dot1dBridge", "dot1dTp", "dot1dTpPort")
( ModuleCompliance, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup")
( Bits, Counter32, Counter64, Integer32, Integer32, ModuleIdentity, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "Counter64", "Integer32", "Integer32", "ModuleIdentity", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks")
( MacAddress, TextualConvention, TimeInterval, TruthValue, ) = mibBuilder.importSymbols("SNMPv2-TC", "MacAddress", "TextualConvention", "TimeInterval", "TruthValue")

# Types

class EnabledStatus(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(2,1,)
    namedValues = NamedValues(("enabled", 1), ("disabled", 2), )
    

# Objects

dot1dTpHCPortTable = MibTable((1, 3, 6, 1, 2, 1, 17, 4, 5))
if mibBuilder.loadTexts: dot1dTpHCPortTable.setDescription("A table that contains information about every high-\ncapacity port that is associated with this transparent\nbridge.")
dot1dTpHCPortEntry = MibTableRow((1, 3, 6, 1, 2, 1, 17, 4, 5, 1)).setIndexNames((0, "BRIDGE-MIB", "dot1dTpPort"))
if mibBuilder.loadTexts: dot1dTpHCPortEntry.setDescription("Statistics information for each high-capacity port of a\ntransparent bridge.")
dot1dTpHCPortInFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 4, 5, 1, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dTpHCPortInFrames.setDescription("The number of frames that have been received by this\nport from its segment.  Note that a frame received on\nthe interface corresponding to this port is only counted\nby this object if and only if it is for a protocol being\nprocessed by the local bridging function, including\nbridge management frames.")
dot1dTpHCPortOutFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 4, 5, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dTpHCPortOutFrames.setDescription("The number of frames that have been transmitted by this\nport to its segment.  Note that a frame transmitted on\nthe interface corresponding to this port is only counted\nby this object if and only if it is for a protocol being\nprocessed by the local bridging function, including\nbridge management frames.")
dot1dTpHCPortInDiscards = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 4, 5, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dTpHCPortInDiscards.setDescription("Count of valid frames that have been received by this\nport from its segment that were discarded (i.e.,\nfiltered) by the Forwarding Process.")
dot1dTpPortOverflowTable = MibTable((1, 3, 6, 1, 2, 1, 17, 4, 6))
if mibBuilder.loadTexts: dot1dTpPortOverflowTable.setDescription("A table that contains the most-significant bits of\nstatistics counters for ports that are associated with this\ntransparent bridge that are on high-capacity interfaces, as\ndefined in the conformance clauses for this table.  This table\nis provided as a way to read 64-bit counters for agents that\nsupport only SNMPv1.\n\nNote that the reporting of most-significant and\nleast-significant counter bits separately runs the risk of\nmissing an overflow of the lower bits in the interval between\nsampling.  The manager must be aware of this possibility, even\nwithin the same varbindlist, when interpreting the results of\na request or asynchronous notification.")
dot1dTpPortOverflowEntry = MibTableRow((1, 3, 6, 1, 2, 1, 17, 4, 6, 1)).setIndexNames((0, "BRIDGE-MIB", "dot1dTpPort"))
if mibBuilder.loadTexts: dot1dTpPortOverflowEntry.setDescription("The most significant bits of statistics counters for a high-\ncapacity interface of a transparent bridge.  Each object is\nassociated with a corresponding object in dot1dTpPortTable\nthat indicates the least significant bits of the counter.")
dot1dTpPortInOverflowFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 4, 6, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dTpPortInOverflowFrames.setDescription("The number of times the associated dot1dTpPortInFrames\ncounter has overflowed.")
dot1dTpPortOutOverflowFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 4, 6, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dTpPortOutOverflowFrames.setDescription("The number of times the associated dot1dTpPortOutFrames\ncounter has overflowed.")
dot1dTpPortInOverflowDiscards = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 4, 6, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dTpPortInOverflowDiscards.setDescription("The number of times the associated\ndot1dTpPortInDiscards counter has overflowed.")
pBridgeMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 17, 6)).setRevisions(("2006-01-09 00:00","1999-08-25 00:00",))
if mibBuilder.loadTexts: pBridgeMIB.setOrganization("IETF Bridge MIB Working Group")
if mibBuilder.loadTexts: pBridgeMIB.setContactInfo("Email:  bridge-mib@ietf.org\nietfmibs@ops.ietf.org\n\nDavid Levi\nPostal: Nortel Networks\n4655 Great America Parkway\nSanta Clara, CA 95054\nUSA\nPhone: +1 865 686 0432\nEmail: dlevi@nortel.com\n\nDavid Harrington\nPostal: Effective Software\n50 Harding Rd.\nPortsmouth, NH 03801\nUSA\nPhone: +1 603 436 8634\nEmail: ietfdbh@comcast.net\n\nLes Bell\nPostal: Hemel Hempstead, Herts. HP2 7YU\nUK\nEmail: elbell@ntlworld.com\n\nVivian Ngai\n\n\n\nEmail: vivian_ngai@acm.org\n\nAndrew Smith\nPostal: Beijing Harbour Networks\nJiuling Building\n21 North Xisanhuan Ave.\nBeijing, 100089\nPRC\nFax: +1 415 345 1827\nEmail: ah_smith@acm.org\n\nPaul Langille\nPostal: Newbridge Networks\n5 Corporate Drive\nAndover, MA 01810\nUSA\nPhone: +1 978 691 4665\nEmail: langille@newbridge.com\n\nAnil Rijhsinghani\nPostal: Accton Technology Corporation\n5 Mount Royal Ave\nMarlboro, MA 01752\nUSA\nPhone:\nEmail: anil@accton.com\n\nKeith McCloghrie\nPostal: Cisco Systems, Inc.\n170 West Tasman Drive\nSan Jose, CA 95134-1706\nUSA\nPhone: +1 408 526 5260\nEmail: kzm@cisco.com")
if mibBuilder.loadTexts: pBridgeMIB.setDescription("The Bridge MIB Extension module for managing Priority\nand Multicast Filtering, defined by IEEE 802.1D-1998,\nincluding Restricted Group Registration defined by\nIEEE 802.1t-2001.\n\nCopyright (C) The Internet Society (2006).  This version of\nthis MIB module is part of RFC 4363; See the RFC itself for\nfull legal notices.")
pBridgeMIBObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 17, 6, 1))
dot1dExtBase = MibIdentifier((1, 3, 6, 1, 2, 1, 17, 6, 1, 1))
dot1dDeviceCapabilities = MibScalar((1, 3, 6, 1, 2, 1, 17, 6, 1, 1, 1), Bits().subtype(namedValues=NamedValues(("dot1dExtendedFilteringServices", 0), ("dot1dTrafficClasses", 1), ("dot1qStaticEntryIndividualPort", 2), ("dot1qIVLCapable", 3), ("dot1qSVLCapable", 4), ("dot1qHybridCapable", 5), ("dot1qConfigurablePvidTagging", 6), ("dot1dLocalVlanCapable", 7), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dDeviceCapabilities.setDescription("Indicates the optional parts of IEEE 802.1D and 802.1Q\nthat are implemented by this device and are manageable\nthrough this MIB.  Capabilities that are allowed on a\nper-port basis are indicated in dot1dPortCapabilities.\n\ndot1dExtendedFilteringServices(0),\n                      -- can perform filtering of\n                      -- individual multicast addresses\n                      -- controlled by GMRP.\ndot1dTrafficClasses(1),\n                      -- can map user priority to\n                      -- multiple traffic classes.\ndot1qStaticEntryIndividualPort(2),\n                      -- dot1qStaticUnicastReceivePort &\n                      -- dot1qStaticMulticastReceivePort\n                      -- can represent non-zero entries.\ndot1qIVLCapable(3),   -- Independent VLAN Learning (IVL).\ndot1qSVLCapable(4),   -- Shared VLAN Learning (SVL).\ndot1qHybridCapable(5),\n                      -- both IVL & SVL simultaneously.\ndot1qConfigurablePvidTagging(6),\n                      -- whether the implementation\n                      -- supports the ability to\n                      -- override the default PVID\n                      -- setting and its egress status\n                      -- (VLAN-Tagged or Untagged) on\n                      -- each port.\ndot1dLocalVlanCapable(7)\n                      -- can support multiple local\n                      -- bridges, outside of the scope\n                      -- of 802.1Q defined VLANs.")
dot1dTrafficClassesEnabled = MibScalar((1, 3, 6, 1, 2, 1, 17, 6, 1, 1, 2), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dTrafficClassesEnabled.setDescription("The value true(1) indicates that Traffic Classes are\nenabled on this bridge.  When false(2), the bridge\noperates with a single priority level for all traffic.\n\nThe value of this object MUST be retained across\nreinitializations of the management system.")
dot1dGmrpStatus = MibScalar((1, 3, 6, 1, 2, 1, 17, 6, 1, 1, 3), EnabledStatus().clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dGmrpStatus.setDescription("The administrative status requested by management for\nGMRP.  The value enabled(1) indicates that GMRP should\nbe enabled on this device, in all VLANs, on all ports\nfor which it has not been specifically disabled.  When\ndisabled(2), GMRP is disabled, in all VLANs and on all\nports, and all GMRP packets will be forwarded\ntransparently.  This object affects both Applicant and\nRegistrar state machines.  A transition from disabled(2)\nto enabled(1) will cause a reset of all GMRP state\nmachines on all ports.\n\nThe value of this object MUST be retained across\nreinitializations of the management system.")
dot1dPortCapabilitiesTable = MibTable((1, 3, 6, 1, 2, 1, 17, 6, 1, 1, 4))
if mibBuilder.loadTexts: dot1dPortCapabilitiesTable.setDescription("A table that contains capabilities information about\nevery port that is associated with this bridge.")
dot1dPortCapabilitiesEntry = MibTableRow((1, 3, 6, 1, 2, 1, 17, 6, 1, 1, 4, 1))
if mibBuilder.loadTexts: dot1dPortCapabilitiesEntry.setDescription("A set of capabilities information about this port\nindexed by dot1dBasePort.")
dot1dPortCapabilities = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 6, 1, 1, 4, 1, 1), Bits().subtype(namedValues=NamedValues(("dot1qDot1qTagging", 0), ("dot1qConfigurableAcceptableFrameTypes", 1), ("dot1qIngressFiltering", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dPortCapabilities.setDescription("Indicates the parts of IEEE 802.1D and 802.1Q that are\noptional on a per-port basis, that are implemented by\nthis device, and that are manageable through this MIB.\n\ndot1qDot1qTagging(0), -- supports 802.1Q VLAN tagging of\n                      -- frames and GVRP.\ndot1qConfigurableAcceptableFrameTypes(1),\n                      -- allows modified values of\n                      -- dot1qPortAcceptableFrameTypes.\ndot1qIngressFiltering(2)\n                      -- supports the discarding of any\n                      -- frame received on a Port whose\n                      -- VLAN classification does not\n                      -- include that Port in its Member\n                      -- set.")
dot1dPriority = MibIdentifier((1, 3, 6, 1, 2, 1, 17, 6, 1, 2))
dot1dPortPriorityTable = MibTable((1, 3, 6, 1, 2, 1, 17, 6, 1, 2, 1))
if mibBuilder.loadTexts: dot1dPortPriorityTable.setDescription("A table that contains information about every port that\nis associated with this transparent bridge.")
dot1dPortPriorityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 17, 6, 1, 2, 1, 1))
if mibBuilder.loadTexts: dot1dPortPriorityEntry.setDescription("A list of Default User Priorities for each port of a\ntransparent bridge.  This is indexed by dot1dBasePort.")
dot1dPortDefaultUserPriority = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 6, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dPortDefaultUserPriority.setDescription("The default ingress User Priority for this port.  This\nonly has effect on media, such as Ethernet, that do not\nsupport native User Priority.\n\nThe value of this object MUST be retained across\nreinitializations of the management system.")
dot1dPortNumTrafficClasses = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 6, 1, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dPortNumTrafficClasses.setDescription("The number of egress traffic classes supported on this\nport.  This object may optionally be read-only.\n\nThe value of this object MUST be retained across\nreinitializations of the management system.")
dot1dUserPriorityRegenTable = MibTable((1, 3, 6, 1, 2, 1, 17, 6, 1, 2, 2))
if mibBuilder.loadTexts: dot1dUserPriorityRegenTable.setDescription("A list of Regenerated User Priorities for each received\nUser Priority on each port of a bridge.  The Regenerated\nUser Priority value may be used to index the Traffic\nClass Table for each input port.  This only has effect\non media that support native User Priority.  The default\nvalues for Regenerated User Priorities are the same as\nthe User Priorities.")
dot1dUserPriorityRegenEntry = MibTableRow((1, 3, 6, 1, 2, 1, 17, 6, 1, 2, 2, 1)).setIndexNames((0, "BRIDGE-MIB", "dot1dBasePort"), (0, "P-BRIDGE-MIB", "dot1dUserPriority"))
if mibBuilder.loadTexts: dot1dUserPriorityRegenEntry.setDescription("A mapping of incoming User Priority to a Regenerated\nUser Priority.")
dot1dUserPriority = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 6, 1, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: dot1dUserPriority.setDescription("The User Priority for a frame received on this port.")
dot1dRegenUserPriority = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 6, 1, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dRegenUserPriority.setDescription("The Regenerated User Priority that the incoming User\n\n\n\nPriority is mapped to for this port.\n\nThe value of this object MUST be retained across\nreinitializations of the management system.")
dot1dTrafficClassTable = MibTable((1, 3, 6, 1, 2, 1, 17, 6, 1, 2, 3))
if mibBuilder.loadTexts: dot1dTrafficClassTable.setDescription("A table mapping evaluated User Priority to Traffic\nClass, for forwarding by the bridge.  Traffic class is a\nnumber in the range (0..(dot1dPortNumTrafficClasses-1)).")
dot1dTrafficClassEntry = MibTableRow((1, 3, 6, 1, 2, 1, 17, 6, 1, 2, 3, 1)).setIndexNames((0, "BRIDGE-MIB", "dot1dBasePort"), (0, "P-BRIDGE-MIB", "dot1dTrafficClassPriority"))
if mibBuilder.loadTexts: dot1dTrafficClassEntry.setDescription("User Priority to Traffic Class mapping.")
dot1dTrafficClassPriority = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 6, 1, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: dot1dTrafficClassPriority.setDescription("The Priority value determined for the received frame.\nThis value is equivalent to the priority indicated in\nthe tagged frame received, or one of the evaluated\npriorities, determined according to the media-type.\n\n\n\nFor untagged frames received from Ethernet media, this\nvalue is equal to the dot1dPortDefaultUserPriority value\nfor the ingress port.\n\nFor untagged frames received from non-Ethernet media,\nthis value is equal to the dot1dRegenUserPriority value\nfor the ingress port and media-specific user priority.")
dot1dTrafficClass = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 6, 1, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dTrafficClass.setDescription("The Traffic Class the received frame is mapped to.\n\nThe value of this object MUST be retained across\nreinitializations of the management system.")
dot1dPortOutboundAccessPriorityTable = MibTable((1, 3, 6, 1, 2, 1, 17, 6, 1, 2, 4))
if mibBuilder.loadTexts: dot1dPortOutboundAccessPriorityTable.setDescription("A table mapping Regenerated User Priority to Outbound\nAccess Priority.  This is a fixed mapping for all port\ntypes, with two options for 802.5 Token Ring.")
dot1dPortOutboundAccessPriorityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 17, 6, 1, 2, 4, 1)).setIndexNames((0, "BRIDGE-MIB", "dot1dBasePort"), (0, "P-BRIDGE-MIB", "dot1dRegenUserPriority"))
if mibBuilder.loadTexts: dot1dPortOutboundAccessPriorityEntry.setDescription("Regenerated User Priority to Outbound Access Priority\nmapping.")
dot1dPortOutboundAccessPriority = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 6, 1, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dPortOutboundAccessPriority.setDescription("The Outbound Access Priority the received frame is\nmapped to.")
dot1dGarp = MibIdentifier((1, 3, 6, 1, 2, 1, 17, 6, 1, 3))
dot1dPortGarpTable = MibTable((1, 3, 6, 1, 2, 1, 17, 6, 1, 3, 1))
if mibBuilder.loadTexts: dot1dPortGarpTable.setDescription("A table of GARP control information about every bridge\nport.  This is indexed by dot1dBasePort.")
dot1dPortGarpEntry = MibTableRow((1, 3, 6, 1, 2, 1, 17, 6, 1, 3, 1, 1))
if mibBuilder.loadTexts: dot1dPortGarpEntry.setDescription("GARP control information for a bridge port.")
dot1dPortGarpJoinTime = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 6, 1, 3, 1, 1, 1), TimeInterval().clone('20')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dPortGarpJoinTime.setDescription("The GARP Join time, in centiseconds.\n\nThe value of this object MUST be retained across\nreinitializations of the management system.")
dot1dPortGarpLeaveTime = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 6, 1, 3, 1, 1, 2), TimeInterval().clone('60')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dPortGarpLeaveTime.setDescription("The GARP Leave time, in centiseconds.\n\nThe value of this object MUST be retained across\nreinitializations of the management system.")
dot1dPortGarpLeaveAllTime = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 6, 1, 3, 1, 1, 3), TimeInterval().clone('1000')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dPortGarpLeaveAllTime.setDescription("The GARP LeaveAll time, in centiseconds.\n\nThe value of this object MUST be retained across\nreinitializations of the management system.")
dot1dGmrp = MibIdentifier((1, 3, 6, 1, 2, 1, 17, 6, 1, 4))
dot1dPortGmrpTable = MibTable((1, 3, 6, 1, 2, 1, 17, 6, 1, 4, 1))
if mibBuilder.loadTexts: dot1dPortGmrpTable.setDescription("A table of GMRP control and status information about\nevery bridge port.  Augments the dot1dBasePortTable.")
dot1dPortGmrpEntry = MibTableRow((1, 3, 6, 1, 2, 1, 17, 6, 1, 4, 1, 1))
if mibBuilder.loadTexts: dot1dPortGmrpEntry.setDescription("GMRP control and status information for a bridge port.")
dot1dPortGmrpStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 6, 1, 4, 1, 1, 1), EnabledStatus().clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dPortGmrpStatus.setDescription("The administrative state of GMRP operation on this port.  The\nvalue enabled(1) indicates that GMRP is enabled on this port\nin all VLANs as long as dot1dGmrpStatus is also enabled(1).\nA value of disabled(2) indicates that GMRP is disabled on\nthis port in all VLANs: any GMRP packets received will\nbe silently discarded, and no GMRP registrations will be\npropagated from other ports.  Setting this to a value of\nenabled(1) will be stored by the agent but will only take\neffect on the GMRP protocol operation if dot1dGmrpStatus\nalso indicates the value enabled(1).  This object affects\nall GMRP Applicant and Registrar state machines on this\nport.  A transition from disabled(2) to enabled(1) will\ncause a reset of all GMRP state machines on this port.\n\nThe value of this object MUST be retained across\nreinitializations of the management system.")
dot1dPortGmrpFailedRegistrations = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 6, 1, 4, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dPortGmrpFailedRegistrations.setDescription("The total number of failed GMRP registrations, for any\nreason, in all VLANs, on this port.")
dot1dPortGmrpLastPduOrigin = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 6, 1, 4, 1, 1, 3), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dPortGmrpLastPduOrigin.setDescription("The Source MAC Address of the last GMRP message\nreceived on this port.")
dot1dPortRestrictedGroupRegistration = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 6, 1, 4, 1, 1, 4), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dPortRestrictedGroupRegistration.setDescription("The state of Restricted Group Registration on this port.\nIf the value of this control is true(1), then creation\nof a new dynamic entry is permitted only if there is a\nStatic Filtering Entry for the VLAN concerned, in which\nthe Registrar Administrative Control value is Normal\nRegistration.\n\nThe value of this object MUST be retained across\nreinitializations of the management system.")
pBridgeConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 17, 6, 2))
pBridgeGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 17, 6, 2, 1))
pBridgeCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 17, 6, 2, 2))

# Augmentions
dot1dBasePortEntry, = mibBuilder.importSymbols("BRIDGE-MIB", "dot1dBasePortEntry")
dot1dBasePortEntry.registerAugmentions(("P-BRIDGE-MIB", "dot1dPortCapabilitiesEntry"))
dot1dPortCapabilitiesEntry.setIndexNames(*dot1dBasePortEntry.getIndexNames())
dot1dBasePortEntry, = mibBuilder.importSymbols("BRIDGE-MIB", "dot1dBasePortEntry")
dot1dBasePortEntry.registerAugmentions(("P-BRIDGE-MIB", "dot1dPortGmrpEntry"))
dot1dPortGmrpEntry.setIndexNames(*dot1dBasePortEntry.getIndexNames())
dot1dBasePortEntry, = mibBuilder.importSymbols("BRIDGE-MIB", "dot1dBasePortEntry")
dot1dBasePortEntry.registerAugmentions(("P-BRIDGE-MIB", "dot1dPortGarpEntry"))
dot1dPortGarpEntry.setIndexNames(*dot1dBasePortEntry.getIndexNames())
dot1dBasePortEntry, = mibBuilder.importSymbols("BRIDGE-MIB", "dot1dBasePortEntry")
dot1dBasePortEntry.registerAugmentions(("P-BRIDGE-MIB", "dot1dPortPriorityEntry"))
dot1dPortPriorityEntry.setIndexNames(*dot1dBasePortEntry.getIndexNames())

# Groups

pBridgeExtCapGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 17, 6, 2, 1, 1)).setObjects(*(("P-BRIDGE-MIB", "dot1dPortCapabilities"), ("P-BRIDGE-MIB", "dot1dDeviceCapabilities"), ) )
if mibBuilder.loadTexts: pBridgeExtCapGroup.setDescription("A collection of objects indicating the optional\ncapabilities of the device.")
pBridgeDeviceGmrpGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 17, 6, 2, 1, 2)).setObjects(*(("P-BRIDGE-MIB", "dot1dGmrpStatus"), ) )
if mibBuilder.loadTexts: pBridgeDeviceGmrpGroup.setDescription("A collection of objects providing device-level control\nfor the Multicast Filtering extended bridge services.")
pBridgeDevicePriorityGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 17, 6, 2, 1, 3)).setObjects(*(("P-BRIDGE-MIB", "dot1dTrafficClassesEnabled"), ) )
if mibBuilder.loadTexts: pBridgeDevicePriorityGroup.setDescription("A collection of objects providing device-level control\nfor the Priority services.")
pBridgeDefaultPriorityGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 17, 6, 2, 1, 4)).setObjects(*(("P-BRIDGE-MIB", "dot1dPortDefaultUserPriority"), ) )
if mibBuilder.loadTexts: pBridgeDefaultPriorityGroup.setDescription("A collection of objects defining the User Priority\napplicable to each port for media that do not support\nnative User Priority.")
pBridgeRegenPriorityGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 17, 6, 2, 1, 5)).setObjects(*(("P-BRIDGE-MIB", "dot1dRegenUserPriority"), ) )
if mibBuilder.loadTexts: pBridgeRegenPriorityGroup.setDescription("A collection of objects defining the User Priorities\napplicable to each port for media that support native\nUser Priority.")
pBridgePriorityGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 17, 6, 2, 1, 6)).setObjects(*(("P-BRIDGE-MIB", "dot1dTrafficClass"), ("P-BRIDGE-MIB", "dot1dPortNumTrafficClasses"), ) )
if mibBuilder.loadTexts: pBridgePriorityGroup.setDescription("A collection of objects defining the traffic classes\nwithin a bridge for each evaluated User Priority.")
pBridgeAccessPriorityGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 17, 6, 2, 1, 7)).setObjects(*(("P-BRIDGE-MIB", "dot1dPortOutboundAccessPriority"), ) )
if mibBuilder.loadTexts: pBridgeAccessPriorityGroup.setDescription("A collection of objects defining the media-dependent\noutbound access level for each priority.")
pBridgePortGarpGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 17, 6, 2, 1, 8)).setObjects(*(("P-BRIDGE-MIB", "dot1dPortGarpLeaveAllTime"), ("P-BRIDGE-MIB", "dot1dPortGarpLeaveTime"), ("P-BRIDGE-MIB", "dot1dPortGarpJoinTime"), ) )
if mibBuilder.loadTexts: pBridgePortGarpGroup.setDescription("A collection of objects providing port level control\nand status information for GARP operation.")
pBridgePortGmrpGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 17, 6, 2, 1, 9)).setObjects(*(("P-BRIDGE-MIB", "dot1dPortGmrpFailedRegistrations"), ("P-BRIDGE-MIB", "dot1dPortGmrpLastPduOrigin"), ("P-BRIDGE-MIB", "dot1dPortGmrpStatus"), ) )
if mibBuilder.loadTexts: pBridgePortGmrpGroup.setDescription("A collection of objects providing port level control\nand status information for GMRP operation.")
pBridgeHCPortGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 17, 6, 2, 1, 10)).setObjects(*(("P-BRIDGE-MIB", "dot1dTpHCPortOutFrames"), ("P-BRIDGE-MIB", "dot1dTpHCPortInDiscards"), ("P-BRIDGE-MIB", "dot1dTpHCPortInFrames"), ) )
if mibBuilder.loadTexts: pBridgeHCPortGroup.setDescription("A collection of objects providing 64-bit statistics\ncounters for high-capacity bridge ports.")
pBridgePortOverflowGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 17, 6, 2, 1, 11)).setObjects(*(("P-BRIDGE-MIB", "dot1dTpPortInOverflowDiscards"), ("P-BRIDGE-MIB", "dot1dTpPortInOverflowFrames"), ("P-BRIDGE-MIB", "dot1dTpPortOutOverflowFrames"), ) )
if mibBuilder.loadTexts: pBridgePortOverflowGroup.setDescription("A collection of objects providing overflow statistics\ncounters for high-capacity bridge ports.")
pBridgePortGmrpGroup2 = ObjectGroup((1, 3, 6, 1, 2, 1, 17, 6, 2, 1, 12)).setObjects(*(("P-BRIDGE-MIB", "dot1dPortGmrpFailedRegistrations"), ("P-BRIDGE-MIB", "dot1dPortGmrpLastPduOrigin"), ("P-BRIDGE-MIB", "dot1dPortGmrpStatus"), ("P-BRIDGE-MIB", "dot1dPortRestrictedGroupRegistration"), ) )
if mibBuilder.loadTexts: pBridgePortGmrpGroup2.setDescription("A collection of objects providing port level control\nand status information for GMRP operation.")

# Compliances

pBridgeCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 17, 6, 2, 2, 1)).setObjects(*(("P-BRIDGE-MIB", "pBridgeRegenPriorityGroup"), ("P-BRIDGE-MIB", "pBridgeDeviceGmrpGroup"), ("P-BRIDGE-MIB", "pBridgeDevicePriorityGroup"), ("P-BRIDGE-MIB", "pBridgeDefaultPriorityGroup"), ("P-BRIDGE-MIB", "pBridgePriorityGroup"), ("P-BRIDGE-MIB", "pBridgeExtCapGroup"), ("P-BRIDGE-MIB", "pBridgeAccessPriorityGroup"), ("P-BRIDGE-MIB", "pBridgeHCPortGroup"), ("P-BRIDGE-MIB", "pBridgePortOverflowGroup"), ("P-BRIDGE-MIB", "pBridgePortGarpGroup"), ("P-BRIDGE-MIB", "pBridgePortGmrpGroup"), ) )
if mibBuilder.loadTexts: pBridgeCompliance.setDescription("The compliance statement for device support of Priority\nand Multicast Filtering extended bridging services.")
pBridgeCompliance2 = ModuleCompliance((1, 3, 6, 1, 2, 1, 17, 6, 2, 2, 2)).setObjects(*(("P-BRIDGE-MIB", "pBridgeRegenPriorityGroup"), ("P-BRIDGE-MIB", "pBridgeDeviceGmrpGroup"), ("P-BRIDGE-MIB", "pBridgeDevicePriorityGroup"), ("P-BRIDGE-MIB", "pBridgeDefaultPriorityGroup"), ("P-BRIDGE-MIB", "pBridgePriorityGroup"), ("P-BRIDGE-MIB", "pBridgePortGmrpGroup2"), ("P-BRIDGE-MIB", "pBridgeExtCapGroup"), ("P-BRIDGE-MIB", "pBridgeAccessPriorityGroup"), ("P-BRIDGE-MIB", "pBridgeHCPortGroup"), ("P-BRIDGE-MIB", "pBridgePortOverflowGroup"), ("P-BRIDGE-MIB", "pBridgePortGarpGroup"), ) )
if mibBuilder.loadTexts: pBridgeCompliance2.setDescription("The compliance statement for device support of Priority\nand Multicast Filtering extended bridging services.")

# Exports

# Module identity
mibBuilder.exportSymbols("P-BRIDGE-MIB", PYSNMP_MODULE_ID=pBridgeMIB)

# Types
mibBuilder.exportSymbols("P-BRIDGE-MIB", EnabledStatus=EnabledStatus)

# Objects
mibBuilder.exportSymbols("P-BRIDGE-MIB", dot1dTpHCPortTable=dot1dTpHCPortTable, dot1dTpHCPortEntry=dot1dTpHCPortEntry, dot1dTpHCPortInFrames=dot1dTpHCPortInFrames, dot1dTpHCPortOutFrames=dot1dTpHCPortOutFrames, dot1dTpHCPortInDiscards=dot1dTpHCPortInDiscards, dot1dTpPortOverflowTable=dot1dTpPortOverflowTable, dot1dTpPortOverflowEntry=dot1dTpPortOverflowEntry, dot1dTpPortInOverflowFrames=dot1dTpPortInOverflowFrames, dot1dTpPortOutOverflowFrames=dot1dTpPortOutOverflowFrames, dot1dTpPortInOverflowDiscards=dot1dTpPortInOverflowDiscards, pBridgeMIB=pBridgeMIB, pBridgeMIBObjects=pBridgeMIBObjects, dot1dExtBase=dot1dExtBase, dot1dDeviceCapabilities=dot1dDeviceCapabilities, dot1dTrafficClassesEnabled=dot1dTrafficClassesEnabled, dot1dGmrpStatus=dot1dGmrpStatus, dot1dPortCapabilitiesTable=dot1dPortCapabilitiesTable, dot1dPortCapabilitiesEntry=dot1dPortCapabilitiesEntry, dot1dPortCapabilities=dot1dPortCapabilities, dot1dPriority=dot1dPriority, dot1dPortPriorityTable=dot1dPortPriorityTable, dot1dPortPriorityEntry=dot1dPortPriorityEntry, dot1dPortDefaultUserPriority=dot1dPortDefaultUserPriority, dot1dPortNumTrafficClasses=dot1dPortNumTrafficClasses, dot1dUserPriorityRegenTable=dot1dUserPriorityRegenTable, dot1dUserPriorityRegenEntry=dot1dUserPriorityRegenEntry, dot1dUserPriority=dot1dUserPriority, dot1dRegenUserPriority=dot1dRegenUserPriority, dot1dTrafficClassTable=dot1dTrafficClassTable, dot1dTrafficClassEntry=dot1dTrafficClassEntry, dot1dTrafficClassPriority=dot1dTrafficClassPriority, dot1dTrafficClass=dot1dTrafficClass, dot1dPortOutboundAccessPriorityTable=dot1dPortOutboundAccessPriorityTable, dot1dPortOutboundAccessPriorityEntry=dot1dPortOutboundAccessPriorityEntry, dot1dPortOutboundAccessPriority=dot1dPortOutboundAccessPriority, dot1dGarp=dot1dGarp, dot1dPortGarpTable=dot1dPortGarpTable, dot1dPortGarpEntry=dot1dPortGarpEntry, dot1dPortGarpJoinTime=dot1dPortGarpJoinTime, dot1dPortGarpLeaveTime=dot1dPortGarpLeaveTime, dot1dPortGarpLeaveAllTime=dot1dPortGarpLeaveAllTime, dot1dGmrp=dot1dGmrp, dot1dPortGmrpTable=dot1dPortGmrpTable, dot1dPortGmrpEntry=dot1dPortGmrpEntry, dot1dPortGmrpStatus=dot1dPortGmrpStatus, dot1dPortGmrpFailedRegistrations=dot1dPortGmrpFailedRegistrations, dot1dPortGmrpLastPduOrigin=dot1dPortGmrpLastPduOrigin, dot1dPortRestrictedGroupRegistration=dot1dPortRestrictedGroupRegistration, pBridgeConformance=pBridgeConformance, pBridgeGroups=pBridgeGroups, pBridgeCompliances=pBridgeCompliances)

# Groups
mibBuilder.exportSymbols("P-BRIDGE-MIB", pBridgeExtCapGroup=pBridgeExtCapGroup, pBridgeDeviceGmrpGroup=pBridgeDeviceGmrpGroup, pBridgeDevicePriorityGroup=pBridgeDevicePriorityGroup, pBridgeDefaultPriorityGroup=pBridgeDefaultPriorityGroup, pBridgeRegenPriorityGroup=pBridgeRegenPriorityGroup, pBridgePriorityGroup=pBridgePriorityGroup, pBridgeAccessPriorityGroup=pBridgeAccessPriorityGroup, pBridgePortGarpGroup=pBridgePortGarpGroup, pBridgePortGmrpGroup=pBridgePortGmrpGroup, pBridgeHCPortGroup=pBridgeHCPortGroup, pBridgePortOverflowGroup=pBridgePortOverflowGroup, pBridgePortGmrpGroup2=pBridgePortGmrpGroup2)

# Compliances
mibBuilder.exportSymbols("P-BRIDGE-MIB", pBridgeCompliance=pBridgeCompliance, pBridgeCompliance2=pBridgeCompliance2)
