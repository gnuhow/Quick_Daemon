# PySNMP SMI module. Autogenerated from smidump -f python IF-CAP-STACK-MIB
# by libsmi2pysnmp-0.1.3 at Mon Apr  2 20:39:07 2012,
# Python version sys.version_info(major=2, minor=7, micro=2, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( ifInvStackGroup, ) = mibBuilder.importSymbols("IF-INVERTED-STACK-MIB", "ifInvStackGroup")
( ifStackGroup2, ifStackHigherLayer, ifStackLowerLayer, ) = mibBuilder.importSymbols("IF-MIB", "ifStackGroup2", "ifStackHigherLayer", "ifStackLowerLayer")
( ModuleCompliance, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup")
( Bits, Integer32, ModuleIdentity, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, mib_2, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Integer32", "ModuleIdentity", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "mib-2")
( TruthValue, ) = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue")

# Objects

ifCapStackMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 166)).setRevisions(("2007-11-07 00:00",))
if mibBuilder.loadTexts: ifCapStackMIB.setOrganization("IETF Ethernet Interfaces and Hub MIB Working Group")
if mibBuilder.loadTexts: ifCapStackMIB.setContactInfo("WG charter:\nhttp://www.ietf.org/html.charters/OLD/hubmib-charter.html\n\nMailing Lists:\nGeneral Discussion: hubmib@ietf.org\n\n\n\nTo Subscribe: hubmib-request@ietf.org\nIn Body: subscribe your_email_address\n\nChair:  Bert Wijnen\nPostal: Alcatel-Lucent\n      Schagen 33\n      3461 GL Linschoten\n      Netherlands\nPhone: +31-348-407-775\nEMail: bwijnen@alcatel-lucent.com\n\nEditor: Edward Beili\nPostal: Actelis Networks Inc.\n      25 Bazel St., P.O.B. 10173\n      Petach-Tikva 10173\n      Israel\nPhone: +972-3-924-3491\nEMail: edward.beili@actelis.com")
if mibBuilder.loadTexts: ifCapStackMIB.setDescription("The objects in this MIB module are used to describe\ncross-connect capabilities of stacked (layered) interfaces,\ncomplementing ifStackTable and ifInvStackTable defined in\nIF-MIB and IF-INVERTED-STACK-MIB, respectively.\n\nCopyright (C) The IETF Trust (2007).  This version\nof this MIB module is part of RFC 5066;  see the RFC\nitself for full legal notices.")
ifCapStackObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 166, 1))
ifCapStackTable = MibTable((1, 3, 6, 1, 2, 1, 166, 1, 1))
if mibBuilder.loadTexts: ifCapStackTable.setDescription("This table, modeled after ifStackTable from IF-MIB,\ncontains information on the possible 'on-top-of'\nrelationships between the multiple sub-layers of network\ninterfaces (as opposed to actual relationships described in\nifStackTable).  In particular, it contains information on\nwhich sub-layers MAY possibly run 'on top of' which other\nsub-layers, as determined by cross-connect capability of the\ndevice, where each sub-layer corresponds to a conceptual row\nin the ifTable.  For example, when the sub-layer with ifIndex\nvalue x can be connected to run on top of the sub-layer with\nifIndex value y, then this table contains:\n\n  ifCapStackStatus.x.y=true\n\nThe ifCapStackStatus.x.y row does not exist if it is\nimpossible to connect between the sub-layers x and y.\n\nNote that for most stacked interfaces (e.g., 2BASE-TL)\nthere's always at least one higher-level interface (e.g., PCS\nport) for each lower-level interface (e.g., PME) and at\nleast one lower-level interface for each higher-level\ninterface, that is, there is at least a single row with a\n'true' status for any such existing value of x or y.\n\nThis table is read-only as it describes device capabilities.")
ifCapStackEntry = MibTableRow((1, 3, 6, 1, 2, 1, 166, 1, 1, 1)).setIndexNames((0, "IF-MIB", "ifStackHigherLayer"), (0, "IF-MIB", "ifStackLowerLayer"))
if mibBuilder.loadTexts: ifCapStackEntry.setDescription("Information on a particular relationship between two\nsub-layers, specifying that one sub-layer MAY possibly run\non 'top' of the other sub-layer.  Each sub-layer corresponds\nto a conceptual row in the ifTable (interface index for\nlower and higher layer, respectively).")
ifCapStackStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 166, 1, 1, 1, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifCapStackStatus.setDescription("The status of the 'cross-connect capability' relationship\nbetween two sub-layers.  The following values can be returned:\n  true(1)         - indicates that the sub-layer interface,\n                    identified by the ifStackLowerLayer MAY\n                    be connected to run 'below' the sub-layer\n                    interface, identified by the\n                    ifStackHigherLayer index.\n  false(2)        - the sub-layer interfaces cannot be\n                    connected temporarily due to\n                    unavailability of the interface(s), e.g.,\n                    one of the interfaces is located on an\n                    absent pluggable module.\n\nNote that lower-layer interface availability per higher-layer,\nindicated by the value of 'true', can be constrained by\nother parameters, for example, by the aggregation capacity of\na higher-layer interface or by the lower-layer interface in\nquestion being already connected to another higher-layer\ninterface.  In order to ensure that a particular sub-layer can\nbe connected to another sub-layer, all respective objects\n(e.g., ifCapStackTable, ifStackTable, and efmCuPAFCapacity for\nEFMCu interfaces) SHALL be inspected.\n\nThis object is read-only, unlike ifStackStatus, as it\ndescribes a cross-connect capability.")
ifInvCapStackTable = MibTable((1, 3, 6, 1, 2, 1, 166, 1, 2))
if mibBuilder.loadTexts: ifInvCapStackTable.setDescription("A table containing information on the possible relationships\nbetween the multiple sub-layers of network interfaces.  This\ntable, modeled after ifInvStackTable from\nIF-INVERTED-STACK-MIB, is an inverse of the ifCapStackTable\ndefined in this MIB module.\n\n\n\nIn particular, this table contains information on which\nsub-layers MAY run 'underneath' which other sub-layers, where\neach sub-layer corresponds to a conceptual row in the ifTable.\nFor example, when the sub-layer with ifIndex value x MAY be\nconnected to run underneath the sub-layer with ifIndex value\ny, then this table contains:\n\n   ifInvCapStackStatus.x.y=true\n\nThis table contains exactly the same number of rows as the\nifCapStackTable, but the rows appear in a different order.\n\nThis table is read-only as it describes a cross-connect\ncapability.")
ifInvCapStackEntry = MibTableRow((1, 3, 6, 1, 2, 1, 166, 1, 2, 1)).setIndexNames((0, "IF-MIB", "ifStackLowerLayer"), (0, "IF-MIB", "ifStackHigherLayer"))
if mibBuilder.loadTexts: ifInvCapStackEntry.setDescription("Information on a particular relationship between two sub-\nlayers, specifying that one sub-layer MAY run underneath the\nother sub-layer.  Each sub-layer corresponds to a conceptual\nrow in the ifTable.")
ifInvCapStackStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 166, 1, 2, 1, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifInvCapStackStatus.setDescription("The status of the possible 'cross-connect capability'\nrelationship between two sub-layers.\n\nAn instance of this object exists for each instance of the\nifCapStackStatus object, and vice versa.  For example, if the\nvariable ifCapStackStatus.H.L exists, then the variable\nifInvCapStackStatus.L.H must also exist, and vice versa.  In\naddition, the two variables always have the same value.\n\n\n\n\nThe ifInvCapStackStatus object is read-only, as it describes\na cross-connect capability.")
ifCapStackConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 166, 2))
ifCapStackGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 166, 2, 1))
ifCapStackCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 166, 2, 2))

# Augmentions

# Groups

ifCapStackGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 166, 2, 1, 1)).setObjects(*(("IF-CAP-STACK-MIB", "ifCapStackStatus"), ("IF-CAP-STACK-MIB", "ifInvCapStackStatus"), ) )
if mibBuilder.loadTexts: ifCapStackGroup.setDescription("A collection of objects providing information on the\ncross-connect capability of multi-layer (stacked) network\ninterfaces.")

# Compliances

ifCapStackCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 166, 2, 2, 1)).setObjects(*(("IF-INVERTED-STACK-MIB", "ifInvStackGroup"), ("IF-CAP-STACK-MIB", "ifCapStackGroup"), ("IF-MIB", "ifStackGroup2"), ) )
if mibBuilder.loadTexts: ifCapStackCompliance.setDescription("The compliance statement for SNMP entities, which provide\ninformation on the cross-connect capability of multi-layer\n(stacked) network interfaces, with flexible cross-connect\nbetween the sub-layers.")

# Exports

# Module identity
mibBuilder.exportSymbols("IF-CAP-STACK-MIB", PYSNMP_MODULE_ID=ifCapStackMIB)

# Objects
mibBuilder.exportSymbols("IF-CAP-STACK-MIB", ifCapStackMIB=ifCapStackMIB, ifCapStackObjects=ifCapStackObjects, ifCapStackTable=ifCapStackTable, ifCapStackEntry=ifCapStackEntry, ifCapStackStatus=ifCapStackStatus, ifInvCapStackTable=ifInvCapStackTable, ifInvCapStackEntry=ifInvCapStackEntry, ifInvCapStackStatus=ifInvCapStackStatus, ifCapStackConformance=ifCapStackConformance, ifCapStackGroups=ifCapStackGroups, ifCapStackCompliances=ifCapStackCompliances)

# Groups
mibBuilder.exportSymbols("IF-CAP-STACK-MIB", ifCapStackGroup=ifCapStackGroup)

# Compliances
mibBuilder.exportSymbols("IF-CAP-STACK-MIB", ifCapStackCompliance=ifCapStackCompliance)
